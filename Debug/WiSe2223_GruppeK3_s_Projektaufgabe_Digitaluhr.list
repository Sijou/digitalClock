
WiSe2223_GruppeK3_s_Projektaufgabe_Digitaluhr.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   00000194  08000000  08000000  00010000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         00002f78  080001a0  080001a0  000101a0  2**4
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       000019d4  08003118  08003118  00013118  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .init_array   00000004  08004aec  08004aec  00014aec  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  4 .fini_array   00000004  08004af0  08004af0  00014af0  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  5 .data         000000dc  20000000  08004af4  00020000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  6 .ccmram       00000000  10000000  10000000  000200dc  2**0
                  CONTENTS
  7 .bss          00000ca8  200000dc  200000dc  000200dc  2**2
                  ALLOC
  8 ._user_heap_stack 00000604  20000d84  20000d84  000200dc  2**0
                  ALLOC
  9 .ARM.attributes 0000002a  00000000  00000000  000200dc  2**0
                  CONTENTS, READONLY
 10 .debug_info   0000334f  00000000  00000000  00020106  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 11 .debug_abbrev 00000d92  00000000  00000000  00023455  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 12 .debug_aranges 00000270  00000000  00000000  000241e8  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 13 .debug_ranges 00000238  00000000  00000000  00024458  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 14 .debug_macro  000190f7  00000000  00000000  00024690  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 15 .debug_line   00003b34  00000000  00000000  0003d787  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 16 .debug_str    000883ed  00000000  00000000  000412bb  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 17 .comment      00000050  00000000  00000000  000c96a8  2**0
                  CONTENTS, READONLY
 18 .debug_frame  00000c74  00000000  00000000  000c96f8  2**2
                  CONTENTS, READONLY, DEBUGGING, OCTETS

Disassembly of section .text:

080001a0 <__do_global_dtors_aux>:
 80001a0:	b510      	push	{r4, lr}
 80001a2:	4c05      	ldr	r4, [pc, #20]	; (80001b8 <__do_global_dtors_aux+0x18>)
 80001a4:	7823      	ldrb	r3, [r4, #0]
 80001a6:	b933      	cbnz	r3, 80001b6 <__do_global_dtors_aux+0x16>
 80001a8:	4b04      	ldr	r3, [pc, #16]	; (80001bc <__do_global_dtors_aux+0x1c>)
 80001aa:	b113      	cbz	r3, 80001b2 <__do_global_dtors_aux+0x12>
 80001ac:	4804      	ldr	r0, [pc, #16]	; (80001c0 <__do_global_dtors_aux+0x20>)
 80001ae:	f3af 8000 	nop.w
 80001b2:	2301      	movs	r3, #1
 80001b4:	7023      	strb	r3, [r4, #0]
 80001b6:	bd10      	pop	{r4, pc}
 80001b8:	200000dc 	.word	0x200000dc
 80001bc:	00000000 	.word	0x00000000
 80001c0:	08003100 	.word	0x08003100

080001c4 <frame_dummy>:
 80001c4:	b508      	push	{r3, lr}
 80001c6:	4b03      	ldr	r3, [pc, #12]	; (80001d4 <frame_dummy+0x10>)
 80001c8:	b11b      	cbz	r3, 80001d2 <frame_dummy+0xe>
 80001ca:	4903      	ldr	r1, [pc, #12]	; (80001d8 <frame_dummy+0x14>)
 80001cc:	4803      	ldr	r0, [pc, #12]	; (80001dc <frame_dummy+0x18>)
 80001ce:	f3af 8000 	nop.w
 80001d2:	bd08      	pop	{r3, pc}
 80001d4:	00000000 	.word	0x00000000
 80001d8:	200000e0 	.word	0x200000e0
 80001dc:	08003100 	.word	0x08003100

080001e0 <strlen>:
 80001e0:	4603      	mov	r3, r0
 80001e2:	f813 2b01 	ldrb.w	r2, [r3], #1
 80001e6:	2a00      	cmp	r2, #0
 80001e8:	d1fb      	bne.n	80001e2 <strlen+0x2>
 80001ea:	1a18      	subs	r0, r3, r0
 80001ec:	3801      	subs	r0, #1
 80001ee:	4770      	bx	lr

080001f0 <memchr>:
 80001f0:	f001 01ff 	and.w	r1, r1, #255	; 0xff
 80001f4:	2a10      	cmp	r2, #16
 80001f6:	db2b      	blt.n	8000250 <memchr+0x60>
 80001f8:	f010 0f07 	tst.w	r0, #7
 80001fc:	d008      	beq.n	8000210 <memchr+0x20>
 80001fe:	f810 3b01 	ldrb.w	r3, [r0], #1
 8000202:	3a01      	subs	r2, #1
 8000204:	428b      	cmp	r3, r1
 8000206:	d02d      	beq.n	8000264 <memchr+0x74>
 8000208:	f010 0f07 	tst.w	r0, #7
 800020c:	b342      	cbz	r2, 8000260 <memchr+0x70>
 800020e:	d1f6      	bne.n	80001fe <memchr+0xe>
 8000210:	b4f0      	push	{r4, r5, r6, r7}
 8000212:	ea41 2101 	orr.w	r1, r1, r1, lsl #8
 8000216:	ea41 4101 	orr.w	r1, r1, r1, lsl #16
 800021a:	f022 0407 	bic.w	r4, r2, #7
 800021e:	f07f 0700 	mvns.w	r7, #0
 8000222:	2300      	movs	r3, #0
 8000224:	e8f0 5602 	ldrd	r5, r6, [r0], #8
 8000228:	3c08      	subs	r4, #8
 800022a:	ea85 0501 	eor.w	r5, r5, r1
 800022e:	ea86 0601 	eor.w	r6, r6, r1
 8000232:	fa85 f547 	uadd8	r5, r5, r7
 8000236:	faa3 f587 	sel	r5, r3, r7
 800023a:	fa86 f647 	uadd8	r6, r6, r7
 800023e:	faa5 f687 	sel	r6, r5, r7
 8000242:	b98e      	cbnz	r6, 8000268 <memchr+0x78>
 8000244:	d1ee      	bne.n	8000224 <memchr+0x34>
 8000246:	bcf0      	pop	{r4, r5, r6, r7}
 8000248:	f001 01ff 	and.w	r1, r1, #255	; 0xff
 800024c:	f002 0207 	and.w	r2, r2, #7
 8000250:	b132      	cbz	r2, 8000260 <memchr+0x70>
 8000252:	f810 3b01 	ldrb.w	r3, [r0], #1
 8000256:	3a01      	subs	r2, #1
 8000258:	ea83 0301 	eor.w	r3, r3, r1
 800025c:	b113      	cbz	r3, 8000264 <memchr+0x74>
 800025e:	d1f8      	bne.n	8000252 <memchr+0x62>
 8000260:	2000      	movs	r0, #0
 8000262:	4770      	bx	lr
 8000264:	3801      	subs	r0, #1
 8000266:	4770      	bx	lr
 8000268:	2d00      	cmp	r5, #0
 800026a:	bf06      	itte	eq
 800026c:	4635      	moveq	r5, r6
 800026e:	3803      	subeq	r0, #3
 8000270:	3807      	subne	r0, #7
 8000272:	f015 0f01 	tst.w	r5, #1
 8000276:	d107      	bne.n	8000288 <memchr+0x98>
 8000278:	3001      	adds	r0, #1
 800027a:	f415 7f80 	tst.w	r5, #256	; 0x100
 800027e:	bf02      	ittt	eq
 8000280:	3001      	addeq	r0, #1
 8000282:	f415 3fc0 	tsteq.w	r5, #98304	; 0x18000
 8000286:	3001      	addeq	r0, #1
 8000288:	bcf0      	pop	{r4, r5, r6, r7}
 800028a:	3801      	subs	r0, #1
 800028c:	4770      	bx	lr
 800028e:	bf00      	nop

08000290 <__NVIC_SetPriority>:
  \param [in]      IRQn  Interrupt number.
  \param [in]  priority  Priority to set.
  \note    The priority cannot be set for every processor exception.
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
 8000290:	b480      	push	{r7}
 8000292:	b083      	sub	sp, #12
 8000294:	af00      	add	r7, sp, #0
 8000296:	4603      	mov	r3, r0
 8000298:	6039      	str	r1, [r7, #0]
 800029a:	71fb      	strb	r3, [r7, #7]
  if ((int32_t)(IRQn) >= 0)
 800029c:	f997 3007 	ldrsb.w	r3, [r7, #7]
 80002a0:	2b00      	cmp	r3, #0
 80002a2:	db0a      	blt.n	80002ba <__NVIC_SetPriority+0x2a>
  {
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 80002a4:	683b      	ldr	r3, [r7, #0]
 80002a6:	b2da      	uxtb	r2, r3
 80002a8:	490c      	ldr	r1, [pc, #48]	; (80002dc <__NVIC_SetPriority+0x4c>)
 80002aa:	f997 3007 	ldrsb.w	r3, [r7, #7]
 80002ae:	0112      	lsls	r2, r2, #4
 80002b0:	b2d2      	uxtb	r2, r2
 80002b2:	440b      	add	r3, r1
 80002b4:	f883 2300 	strb.w	r2, [r3, #768]	; 0x300
  }
  else
  {
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
  }
}
 80002b8:	e00a      	b.n	80002d0 <__NVIC_SetPriority+0x40>
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 80002ba:	683b      	ldr	r3, [r7, #0]
 80002bc:	b2da      	uxtb	r2, r3
 80002be:	4908      	ldr	r1, [pc, #32]	; (80002e0 <__NVIC_SetPriority+0x50>)
 80002c0:	79fb      	ldrb	r3, [r7, #7]
 80002c2:	f003 030f 	and.w	r3, r3, #15
 80002c6:	3b04      	subs	r3, #4
 80002c8:	0112      	lsls	r2, r2, #4
 80002ca:	b2d2      	uxtb	r2, r2
 80002cc:	440b      	add	r3, r1
 80002ce:	761a      	strb	r2, [r3, #24]
}
 80002d0:	bf00      	nop
 80002d2:	370c      	adds	r7, #12
 80002d4:	46bd      	mov	sp, r7
 80002d6:	bc80      	pop	{r7}
 80002d8:	4770      	bx	lr
 80002da:	bf00      	nop
 80002dc:	e000e100 	.word	0xe000e100
 80002e0:	e000ed00 	.word	0xe000ed00

080002e4 <my_alarm1_callback>:
 * In this specific implementation, it sets the state of GPIO pin A5 to high.
 * This could be used, for example, to turn on an LED or trigger some other action in response to the alarm event.
 * The exact behavior of the function may depend on how it is used within the larger program and what the intended purpose of the alarm is.
 */
void my_alarm1_callback()
{
 80002e4:	b580      	push	{r7, lr}
 80002e6:	af00      	add	r7, sp, #0
	//

	gpio_set_pinState(GPIOA , 5 , HIGH) ;
 80002e8:	2200      	movs	r2, #0
 80002ea:	2105      	movs	r1, #5
 80002ec:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
 80002f0:	f001 fbf0 	bl	8001ad4 <gpio_set_pinState>
	rtc_alarm_clear() ;
 80002f4:	f002 fa14 	bl	8002720 <rtc_alarm_clear>
	g_alarm_start_time = get_mtick() ;
 80002f8:	f000 ff28 	bl	800114c <get_mtick>
 80002fc:	4603      	mov	r3, r0
 80002fe:	4a03      	ldr	r2, [pc, #12]	; (800030c <my_alarm1_callback+0x28>)
 8000300:	6013      	str	r3, [r2, #0]
	handle_alarm = true ;
 8000302:	4b03      	ldr	r3, [pc, #12]	; (8000310 <my_alarm1_callback+0x2c>)
 8000304:	2201      	movs	r2, #1
 8000306:	701a      	strb	r2, [r3, #0]

	//
}
 8000308:	bf00      	nop
 800030a:	bd80      	pop	{r7, pc}
 800030c:	20000d24 	.word	0x20000d24
 8000310:	20000d20 	.word	0x20000d20

08000314 <main>:
uint32_t night_mode_timer = 0 ;

uint32_t night_mode_start_time = 0 ;

int main()
{
 8000314:	b580      	push	{r7, lr}
 8000316:	b098      	sub	sp, #96	; 0x60
 8000318:	af04      	add	r7, sp, #16
	rtc_time_t t ,tm;
	rtc_date_t d ;

  	while ((RCC->CR & 2) == 0);  // RCC Clock control register (RCC_CR) , wait until HSI is Ready
 800031a:	bf00      	nop
 800031c:	4b93      	ldr	r3, [pc, #588]	; (800056c <main+0x258>)
 800031e:	681b      	ldr	r3, [r3, #0]
 8000320:	f003 0302 	and.w	r3, r3, #2
 8000324:	2b00      	cmp	r3, #0
 8000326:	d0f9      	beq.n	800031c <main+0x8>

	systick_enable() ;
 8000328:	f000 fece 	bl	80010c8 <systick_enable>
    //Clock configuration register (RCC_CFGR)
	RCC->CFGR &= ~(1<<7)  ; //reset HPRE4 The AHB clock frequency == sys clk
 800032c:	4b8f      	ldr	r3, [pc, #572]	; (800056c <main+0x258>)
 800032e:	685b      	ldr	r3, [r3, #4]
 8000330:	4a8e      	ldr	r2, [pc, #568]	; (800056c <main+0x258>)
 8000332:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 8000336:	6053      	str	r3, [r2, #4]
	RCC->CFGR &= ~(1<<12) ; // APB1 clock no division
 8000338:	4b8c      	ldr	r3, [pc, #560]	; (800056c <main+0x258>)
 800033a:	685b      	ldr	r3, [r3, #4]
 800033c:	4a8b      	ldr	r2, [pc, #556]	; (800056c <main+0x258>)
 800033e:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
 8000342:	6053      	str	r3, [r2, #4]
	RCC->CFGR &= ~(1<<15) ; // APB2 clock no division
 8000344:	4b89      	ldr	r3, [pc, #548]	; (800056c <main+0x258>)
 8000346:	685b      	ldr	r3, [r3, #4]
 8000348:	4a88      	ldr	r2, [pc, #544]	; (800056c <main+0x258>)
 800034a:	f423 4300 	bic.w	r3, r3, #32768	; 0x8000
 800034e:	6053      	str	r3, [r2, #4]

	gpio_clock_enable(GPIOA) ;
 8000350:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
 8000354:	f001 fb02 	bl	800195c <gpio_clock_enable>

	gpio_config_pin(GPIOA,5,GPIO_OUT,GPIO_SPEED_LOW,GPIO_NO_PULL ,GPIO_PUSHPULL);
 8000358:	2300      	movs	r3, #0
 800035a:	9301      	str	r3, [sp, #4]
 800035c:	2300      	movs	r3, #0
 800035e:	9300      	str	r3, [sp, #0]
 8000360:	2300      	movs	r3, #0
 8000362:	2201      	movs	r2, #1
 8000364:	2105      	movs	r1, #5
 8000366:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
 800036a:	f001 fb7c 	bl	8001a66 <gpio_config_pin>
	gpio_config_pin(GPIOA,7,GPIO_OUT,GPIO_SPEED_LOW,GPIO_NO_PULL ,GPIO_PUSHPULL);
 800036e:	2300      	movs	r3, #0
 8000370:	9301      	str	r3, [sp, #4]
 8000372:	2300      	movs	r3, #0
 8000374:	9300      	str	r3, [sp, #0]
 8000376:	2300      	movs	r3, #0
 8000378:	2201      	movs	r2, #1
 800037a:	2107      	movs	r1, #7
 800037c:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
 8000380:	f001 fb71 	bl	8001a66 <gpio_config_pin>

	gpio_set_pinState(GPIOA , 5 , LOW) ;
 8000384:	2201      	movs	r2, #1
 8000386:	2105      	movs	r1, #5
 8000388:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
 800038c:	f001 fba2 	bl	8001ad4 <gpio_set_pinState>


	gpio_config_pin(LED_PORT, LED_TAB[0] ,GPIO_OUT,GPIO_SPEED_LOW,GPIO_NO_PULL ,GPIO_PUSHPULL);
 8000390:	4b77      	ldr	r3, [pc, #476]	; (8000570 <main+0x25c>)
 8000392:	6818      	ldr	r0, [r3, #0]
 8000394:	4b77      	ldr	r3, [pc, #476]	; (8000574 <main+0x260>)
 8000396:	6819      	ldr	r1, [r3, #0]
 8000398:	2300      	movs	r3, #0
 800039a:	9301      	str	r3, [sp, #4]
 800039c:	2300      	movs	r3, #0
 800039e:	9300      	str	r3, [sp, #0]
 80003a0:	2300      	movs	r3, #0
 80003a2:	2201      	movs	r2, #1
 80003a4:	f001 fb5f 	bl	8001a66 <gpio_config_pin>
	gpio_config_pin(LED_PORT, LED_TAB[1] ,GPIO_OUT,GPIO_SPEED_LOW,GPIO_NO_PULL ,GPIO_PUSHPULL);
 80003a8:	4b71      	ldr	r3, [pc, #452]	; (8000570 <main+0x25c>)
 80003aa:	6818      	ldr	r0, [r3, #0]
 80003ac:	4b71      	ldr	r3, [pc, #452]	; (8000574 <main+0x260>)
 80003ae:	6859      	ldr	r1, [r3, #4]
 80003b0:	2300      	movs	r3, #0
 80003b2:	9301      	str	r3, [sp, #4]
 80003b4:	2300      	movs	r3, #0
 80003b6:	9300      	str	r3, [sp, #0]
 80003b8:	2300      	movs	r3, #0
 80003ba:	2201      	movs	r2, #1
 80003bc:	f001 fb53 	bl	8001a66 <gpio_config_pin>
	gpio_config_pin(LED_PORT, LED_TAB[2] ,GPIO_OUT,GPIO_SPEED_LOW,GPIO_NO_PULL ,GPIO_PUSHPULL);
 80003c0:	4b6b      	ldr	r3, [pc, #428]	; (8000570 <main+0x25c>)
 80003c2:	6818      	ldr	r0, [r3, #0]
 80003c4:	4b6b      	ldr	r3, [pc, #428]	; (8000574 <main+0x260>)
 80003c6:	6899      	ldr	r1, [r3, #8]
 80003c8:	2300      	movs	r3, #0
 80003ca:	9301      	str	r3, [sp, #4]
 80003cc:	2300      	movs	r3, #0
 80003ce:	9300      	str	r3, [sp, #0]
 80003d0:	2300      	movs	r3, #0
 80003d2:	2201      	movs	r2, #1
 80003d4:	f001 fb47 	bl	8001a66 <gpio_config_pin>

	lcd1.dev = I2C1 ;
 80003d8:	4b67      	ldr	r3, [pc, #412]	; (8000578 <main+0x264>)
 80003da:	4a68      	ldr	r2, [pc, #416]	; (800057c <main+0x268>)
 80003dc:	601a      	str	r2, [r3, #0]
	lcd2.dev = I2C2 ;
 80003de:	4b68      	ldr	r3, [pc, #416]	; (8000580 <main+0x26c>)
 80003e0:	4a68      	ldr	r2, [pc, #416]	; (8000584 <main+0x270>)
 80003e2:	601a      	str	r2, [r3, #0]
	lcd3.dev = I2C3 ;
 80003e4:	4b68      	ldr	r3, [pc, #416]	; (8000588 <main+0x274>)
 80003e6:	4a69      	ldr	r2, [pc, #420]	; (800058c <main+0x278>)
 80003e8:	601a      	str	r2, [r3, #0]

	I2C_Init(I2C1) ;
 80003ea:	4864      	ldr	r0, [pc, #400]	; (800057c <main+0x268>)
 80003ec:	f001 fb96 	bl	8001b1c <I2C_Init>
	I2C_Init(I2C2) ;
 80003f0:	4864      	ldr	r0, [pc, #400]	; (8000584 <main+0x270>)
 80003f2:	f001 fb93 	bl	8001b1c <I2C_Init>
	I2C_Init(I2C3) ;
 80003f6:	4865      	ldr	r0, [pc, #404]	; (800058c <main+0x278>)
 80003f8:	f001 fb90 	bl	8001b1c <I2C_Init>
//	 t.min = 31 ;
//	 t.sec = 30 ;
//	 t.mode = H_24 ;


	 rtc_init(I2C1);
 80003fc:	485f      	ldr	r0, [pc, #380]	; (800057c <main+0x268>)
 80003fe:	f001 fecf 	bl	80021a0 <rtc_init>

//	 rtc_set_date( &d);
//	 rtc_set_time(&t) ;

	 tm.hr = 19;
 8000402:	2313      	movs	r3, #19
 8000404:	f887 3026 	strb.w	r3, [r7, #38]	; 0x26
	 tm.min = 15 ;
 8000408:	230f      	movs	r3, #15
 800040a:	f887 3025 	strb.w	r3, [r7, #37]	; 0x25
	 tm.sec = 00 ;
 800040e:	2300      	movs	r3, #0
 8000410:	f887 3024 	strb.w	r3, [r7, #36]	; 0x24
	 //rtc_set_alarm(&tm) ;

	 alarm_state_t alarm_state = alarm_state_active ; ;
 8000414:	2300      	movs	r3, #0
 8000416:	f887 304f 	strb.w	r3, [r7, #79]	; 0x4f
	 rtc_set_alarm_callback(&my_alarm1_callback) ;
 800041a:	485d      	ldr	r0, [pc, #372]	; (8000590 <main+0x27c>)
 800041c:	f002 f996 	bl	800274c <rtc_set_alarm_callback>

	 Display_Init(&lcd3);	//Configure Display
 8000420:	4859      	ldr	r0, [pc, #356]	; (8000588 <main+0x274>)
 8000422:	f000 ff24 	bl	800126e <Display_Init>
	 Display_Init(&lcd2);	//Configure Display
 8000426:	4856      	ldr	r0, [pc, #344]	; (8000580 <main+0x26c>)
 8000428:	f000 ff21 	bl	800126e <Display_Init>
	 Display_Init(&lcd1);	//Configure Display
 800042c:	4852      	ldr	r0, [pc, #328]	; (8000578 <main+0x264>)
 800042e:	f000 ff1e 	bl	800126e <Display_Init>
	 keypad_init(GPIOC , 0) ;
 8000432:	2100      	movs	r1, #0
 8000434:	4857      	ldr	r0, [pc, #348]	; (8000594 <main+0x280>)
 8000436:	f001 fcf3 	bl	8001e20 <keypad_init>

	 char key = 0 ;
 800043a:	2300      	movs	r3, #0
 800043c:	f887 304e 	strb.w	r3, [r7, #78]	; 0x4e

	system_state_t sys_state = state_init;
 8000440:	2300      	movs	r3, #0
 8000442:	f887 304d 	strb.w	r3, [r7, #77]	; 0x4d
	idle_sub_state  idel_sub_state = state_display_date ;
 8000446:	2300      	movs	r3, #0
 8000448:	f887 304c 	strb.w	r3, [r7, #76]	; 0x4c
	menu_nav_sub_state_t menu_nav_sub_state = menu_nav_start;
 800044c:	2300      	movs	r3, #0
 800044e:	f887 304b 	strb.w	r3, [r7, #75]	; 0x4b


	uint32_t start_timer = get_mtick();
 8000452:	f000 fe7b 	bl	800114c <get_mtick>
 8000456:	63b8      	str	r0, [r7, #56]	; 0x38
	uint32_t state_idle_timer = 0 ;
 8000458:	2300      	movs	r3, #0
 800045a:	647b      	str	r3, [r7, #68]	; 0x44
	uint32_t led_timer  = 0 ;
 800045c:	2300      	movs	r3, #0
 800045e:	643b      	str	r3, [r7, #64]	; 0x40

	Display_Fill(&lcd1, Display_COLOR_BLACK);
 8000460:	2100      	movs	r1, #0
 8000462:	4845      	ldr	r0, [pc, #276]	; (8000578 <main+0x264>)
 8000464:	f001 f849 	bl	80014fa <Display_Fill>
	Display_Fill(&lcd2, Display_COLOR_BLACK);
 8000468:	2100      	movs	r1, #0
 800046a:	4845      	ldr	r0, [pc, #276]	; (8000580 <main+0x26c>)
 800046c:	f001 f845 	bl	80014fa <Display_Fill>
	Display_Fill(&lcd3, Display_COLOR_BLACK);
 8000470:	2100      	movs	r1, #0
 8000472:	4845      	ldr	r0, [pc, #276]	; (8000588 <main+0x274>)
 8000474:	f001 f841 	bl	80014fa <Display_Fill>

	Display_DrawBitmap(&lcd1 ,0, 0, titel_image, 128, 64, Display_COLOR_WHITE);
 8000478:	2301      	movs	r3, #1
 800047a:	9302      	str	r3, [sp, #8]
 800047c:	2340      	movs	r3, #64	; 0x40
 800047e:	9301      	str	r3, [sp, #4]
 8000480:	2380      	movs	r3, #128	; 0x80
 8000482:	9300      	str	r3, [sp, #0]
 8000484:	4b44      	ldr	r3, [pc, #272]	; (8000598 <main+0x284>)
 8000486:	2200      	movs	r2, #0
 8000488:	2100      	movs	r1, #0
 800048a:	483b      	ldr	r0, [pc, #236]	; (8000578 <main+0x264>)
 800048c:	f000 fe8f 	bl	80011ae <Display_DrawBitmap>
	Display_DrawBitmap(&lcd2 ,0, 0, titel_image, 128, 64, Display_COLOR_WHITE);
 8000490:	2301      	movs	r3, #1
 8000492:	9302      	str	r3, [sp, #8]
 8000494:	2340      	movs	r3, #64	; 0x40
 8000496:	9301      	str	r3, [sp, #4]
 8000498:	2380      	movs	r3, #128	; 0x80
 800049a:	9300      	str	r3, [sp, #0]
 800049c:	4b3e      	ldr	r3, [pc, #248]	; (8000598 <main+0x284>)
 800049e:	2200      	movs	r2, #0
 80004a0:	2100      	movs	r1, #0
 80004a2:	4837      	ldr	r0, [pc, #220]	; (8000580 <main+0x26c>)
 80004a4:	f000 fe83 	bl	80011ae <Display_DrawBitmap>
	Display_DrawBitmap(&lcd3 ,0, 0, titel_image, 128, 64, Display_COLOR_WHITE);
 80004a8:	2301      	movs	r3, #1
 80004aa:	9302      	str	r3, [sp, #8]
 80004ac:	2340      	movs	r3, #64	; 0x40
 80004ae:	9301      	str	r3, [sp, #4]
 80004b0:	2380      	movs	r3, #128	; 0x80
 80004b2:	9300      	str	r3, [sp, #0]
 80004b4:	4b38      	ldr	r3, [pc, #224]	; (8000598 <main+0x284>)
 80004b6:	2200      	movs	r2, #0
 80004b8:	2100      	movs	r1, #0
 80004ba:	4833      	ldr	r0, [pc, #204]	; (8000588 <main+0x274>)
 80004bc:	f000 fe77 	bl	80011ae <Display_DrawBitmap>

	Display_UpdateScreen(&lcd1);
 80004c0:	482d      	ldr	r0, [pc, #180]	; (8000578 <main+0x264>)
 80004c2:	f000 ffe2 	bl	800148a <Display_UpdateScreen>
	Display_UpdateScreen(&lcd2);
 80004c6:	482e      	ldr	r0, [pc, #184]	; (8000580 <main+0x26c>)
 80004c8:	f000 ffdf 	bl	800148a <Display_UpdateScreen>
	Display_UpdateScreen(&lcd3);
 80004cc:	482e      	ldr	r0, [pc, #184]	; (8000588 <main+0x274>)
 80004ce:	f000 ffdc 	bl	800148a <Display_UpdateScreen>


	gpio_set_pinState(GPIOA , LED_TAB[0]  , LOW) ;
 80004d2:	4b28      	ldr	r3, [pc, #160]	; (8000574 <main+0x260>)
 80004d4:	681b      	ldr	r3, [r3, #0]
 80004d6:	2201      	movs	r2, #1
 80004d8:	4619      	mov	r1, r3
 80004da:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
 80004de:	f001 faf9 	bl	8001ad4 <gpio_set_pinState>
	gpio_set_pinState(GPIOA , LED_TAB[1]  , LOW) ;
 80004e2:	4b24      	ldr	r3, [pc, #144]	; (8000574 <main+0x260>)
 80004e4:	685b      	ldr	r3, [r3, #4]
 80004e6:	2201      	movs	r2, #1
 80004e8:	4619      	mov	r1, r3
 80004ea:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
 80004ee:	f001 faf1 	bl	8001ad4 <gpio_set_pinState>
	gpio_set_pinState(GPIOA , LED_TAB[2]  , LOW) ;
 80004f2:	4b20      	ldr	r3, [pc, #128]	; (8000574 <main+0x260>)
 80004f4:	689b      	ldr	r3, [r3, #8]
 80004f6:	2201      	movs	r2, #1
 80004f8:	4619      	mov	r1, r3
 80004fa:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
 80004fe:	f001 fae9 	bl	8001ad4 <gpio_set_pinState>

	gpio_set_pinState(GPIOA , 5 , LOW) ;  //alarm pin
 8000502:	2201      	movs	r2, #1
 8000504:	2105      	movs	r1, #5
 8000506:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
 800050a:	f001 fae3 	bl	8001ad4 <gpio_set_pinState>

	while(1)
	{

		switch(sys_state)
 800050e:	f897 304d 	ldrb.w	r3, [r7, #77]	; 0x4d
 8000512:	2b03      	cmp	r3, #3
 8000514:	f200 82fb 	bhi.w	8000b0e <main+0x7fa>
 8000518:	a201      	add	r2, pc, #4	; (adr r2, 8000520 <main+0x20c>)
 800051a:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800051e:	bf00      	nop
 8000520:	08000531 	.word	0x08000531
 8000524:	0800059d 	.word	0x0800059d
 8000528:	080007ad 	.word	0x080007ad
 800052c:	08000b0f 	.word	0x08000b0f
		{
			case state_init:
			{
				if(get_mtick() - start_timer > 3000)
 8000530:	f000 fe0c 	bl	800114c <get_mtick>
 8000534:	4602      	mov	r2, r0
 8000536:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8000538:	1ad3      	subs	r3, r2, r3
 800053a:	f640 32b8 	movw	r2, #3000	; 0xbb8
 800053e:	4293      	cmp	r3, r2
 8000540:	f240 82e7 	bls.w	8000b12 <main+0x7fe>
				{
					Display_Clear(&lcd1) ;
 8000544:	480c      	ldr	r0, [pc, #48]	; (8000578 <main+0x264>)
 8000546:	f001 f915 	bl	8001774 <Display_Clear>
					Display_Clear(&lcd2) ;
 800054a:	480d      	ldr	r0, [pc, #52]	; (8000580 <main+0x26c>)
 800054c:	f001 f912 	bl	8001774 <Display_Clear>
					Display_Clear(&lcd3) ;
 8000550:	480d      	ldr	r0, [pc, #52]	; (8000588 <main+0x274>)
 8000552:	f001 f90f 	bl	8001774 <Display_Clear>
					sys_state = state_idle ;  //trans
 8000556:	2301      	movs	r3, #1
 8000558:	f887 304d 	strb.w	r3, [r7, #77]	; 0x4d
					state_idle_timer = get_mtick() +1000;
 800055c:	f000 fdf6 	bl	800114c <get_mtick>
 8000560:	4603      	mov	r3, r0
 8000562:	f503 737a 	add.w	r3, r3, #1000	; 0x3e8
 8000566:	647b      	str	r3, [r7, #68]	; 0x44
				}

				break ;
 8000568:	e2d3      	b.n	8000b12 <main+0x7fe>
 800056a:	bf00      	nop
 800056c:	40021000 	.word	0x40021000
 8000570:	20000048 	.word	0x20000048
 8000574:	2000004c 	.word	0x2000004c
 8000578:	200000fc 	.word	0x200000fc
 800057c:	40005400 	.word	0x40005400
 8000580:	20000508 	.word	0x20000508
 8000584:	40005800 	.word	0x40005800
 8000588:	20000914 	.word	0x20000914
 800058c:	40007800 	.word	0x40007800
 8000590:	080002e5 	.word	0x080002e5
 8000594:	48000800 	.word	0x48000800
 8000598:	080031e4 	.word	0x080031e4
			}

			case state_idle:
			{
				gpio_set_pinState(GPIOA , LED_TAB[0]  , LOW ) ;
 800059c:	4bbf      	ldr	r3, [pc, #764]	; (800089c <main+0x588>)
 800059e:	681b      	ldr	r3, [r3, #0]
 80005a0:	2201      	movs	r2, #1
 80005a2:	4619      	mov	r1, r3
 80005a4:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
 80005a8:	f001 fa94 	bl	8001ad4 <gpio_set_pinState>
				gpio_set_pinState(GPIOA , LED_TAB[1]  , LOW ) ;
 80005ac:	4bbb      	ldr	r3, [pc, #748]	; (800089c <main+0x588>)
 80005ae:	685b      	ldr	r3, [r3, #4]
 80005b0:	2201      	movs	r2, #1
 80005b2:	4619      	mov	r1, r3
 80005b4:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
 80005b8:	f001 fa8c 	bl	8001ad4 <gpio_set_pinState>
				gpio_set_pinState(GPIOA , LED_TAB[2]  , LOW ) ;
 80005bc:	4bb7      	ldr	r3, [pc, #732]	; (800089c <main+0x588>)
 80005be:	689b      	ldr	r3, [r3, #8]
 80005c0:	2201      	movs	r2, #1
 80005c2:	4619      	mov	r1, r3
 80005c4:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
 80005c8:	f001 fa84 	bl	8001ad4 <gpio_set_pinState>

				static uint32_t sub_state_timer = 0 ;

				switch(idel_sub_state)
 80005cc:	f897 304c 	ldrb.w	r3, [r7, #76]	; 0x4c
 80005d0:	2b00      	cmp	r3, #0
 80005d2:	d076      	beq.n	80006c2 <main+0x3ae>
 80005d4:	2b01      	cmp	r3, #1
 80005d6:	f040 80db 	bne.w	8000790 <main+0x47c>
				{

					case state_display_time :
					{
						if(get_mtick() - state_idle_timer >= 960)
 80005da:	f000 fdb7 	bl	800114c <get_mtick>
 80005de:	4602      	mov	r2, r0
 80005e0:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 80005e2:	1ad3      	subs	r3, r2, r3
 80005e4:	f5b3 7f70 	cmp.w	r3, #960	; 0x3c0
 80005e8:	d34f      	bcc.n	800068a <main+0x376>
						{
							///
							rtc_get_time(&t) ;
 80005ea:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 80005ee:	4618      	mov	r0, r3
 80005f0:	f001 fe02 	bl	80021f8 <rtc_get_time>
							char hour[4] ;
							char minute[4] ;
							char second[4] ;

							sprintf(hour , "%.2d" , t.hr) ;
 80005f4:	f897 302e 	ldrb.w	r3, [r7, #46]	; 0x2e
 80005f8:	461a      	mov	r2, r3
 80005fa:	f107 031c 	add.w	r3, r7, #28
 80005fe:	49a8      	ldr	r1, [pc, #672]	; (80008a0 <main+0x58c>)
 8000600:	4618      	mov	r0, r3
 8000602:	f002 f8ef 	bl	80027e4 <siprintf>
							sprintf(minute , "%.2d" , t.min) ;
 8000606:	f897 302d 	ldrb.w	r3, [r7, #45]	; 0x2d
 800060a:	461a      	mov	r2, r3
 800060c:	f107 0318 	add.w	r3, r7, #24
 8000610:	49a3      	ldr	r1, [pc, #652]	; (80008a0 <main+0x58c>)
 8000612:	4618      	mov	r0, r3
 8000614:	f002 f8e6 	bl	80027e4 <siprintf>
							sprintf(second , "%.2d" , t.sec) ;
 8000618:	f897 302c 	ldrb.w	r3, [r7, #44]	; 0x2c
 800061c:	461a      	mov	r2, r3
 800061e:	f107 0314 	add.w	r3, r7, #20
 8000622:	499f      	ldr	r1, [pc, #636]	; (80008a0 <main+0x58c>)
 8000624:	4618      	mov	r0, r3
 8000626:	f002 f8dd 	bl	80027e4 <siprintf>

							Display_GotoXY(&lcd1 , 50,20);
 800062a:	2214      	movs	r2, #20
 800062c:	2132      	movs	r1, #50	; 0x32
 800062e:	489d      	ldr	r0, [pc, #628]	; (80008a4 <main+0x590>)
 8000630:	f000 ffdf 	bl	80015f2 <Display_GotoXY>

							Display_Puts(&lcd1 ,hour ,& Font_11x18 , Display_COLOR_WHITE ) ;
 8000634:	f107 011c 	add.w	r1, r7, #28
 8000638:	2301      	movs	r3, #1
 800063a:	4a9b      	ldr	r2, [pc, #620]	; (80008a8 <main+0x594>)
 800063c:	4899      	ldr	r0, [pc, #612]	; (80008a4 <main+0x590>)
 800063e:	f001 f874 	bl	800172a <Display_Puts>

							Display_GotoXY(&lcd2 , 50,20);
 8000642:	2214      	movs	r2, #20
 8000644:	2132      	movs	r1, #50	; 0x32
 8000646:	4899      	ldr	r0, [pc, #612]	; (80008ac <main+0x598>)
 8000648:	f000 ffd3 	bl	80015f2 <Display_GotoXY>

							Display_Puts(&lcd2 ,minute ,& Font_11x18 , Display_COLOR_WHITE ) ;
 800064c:	f107 0118 	add.w	r1, r7, #24
 8000650:	2301      	movs	r3, #1
 8000652:	4a95      	ldr	r2, [pc, #596]	; (80008a8 <main+0x594>)
 8000654:	4895      	ldr	r0, [pc, #596]	; (80008ac <main+0x598>)
 8000656:	f001 f868 	bl	800172a <Display_Puts>

							Display_GotoXY(&lcd3 , 50,20);
 800065a:	2214      	movs	r2, #20
 800065c:	2132      	movs	r1, #50	; 0x32
 800065e:	4894      	ldr	r0, [pc, #592]	; (80008b0 <main+0x59c>)
 8000660:	f000 ffc7 	bl	80015f2 <Display_GotoXY>

							Display_Puts(&lcd3 ,second ,& Font_11x18 , Display_COLOR_WHITE ) ;
 8000664:	f107 0114 	add.w	r1, r7, #20
 8000668:	2301      	movs	r3, #1
 800066a:	4a8f      	ldr	r2, [pc, #572]	; (80008a8 <main+0x594>)
 800066c:	4890      	ldr	r0, [pc, #576]	; (80008b0 <main+0x59c>)
 800066e:	f001 f85c 	bl	800172a <Display_Puts>

							Display_UpdateScreen(&lcd1);
 8000672:	488c      	ldr	r0, [pc, #560]	; (80008a4 <main+0x590>)
 8000674:	f000 ff09 	bl	800148a <Display_UpdateScreen>
							Display_UpdateScreen(&lcd2);
 8000678:	488c      	ldr	r0, [pc, #560]	; (80008ac <main+0x598>)
 800067a:	f000 ff06 	bl	800148a <Display_UpdateScreen>
							Display_UpdateScreen(&lcd3);
 800067e:	488c      	ldr	r0, [pc, #560]	; (80008b0 <main+0x59c>)
 8000680:	f000 ff03 	bl	800148a <Display_UpdateScreen>

							state_idle_timer = get_mtick() ;
 8000684:	f000 fd62 	bl	800114c <get_mtick>
 8000688:	6478      	str	r0, [r7, #68]	; 0x44
						}

						if(get_mtick() - sub_state_timer > 3000)
 800068a:	f000 fd5f 	bl	800114c <get_mtick>
 800068e:	4602      	mov	r2, r0
 8000690:	4b88      	ldr	r3, [pc, #544]	; (80008b4 <main+0x5a0>)
 8000692:	681b      	ldr	r3, [r3, #0]
 8000694:	1ad3      	subs	r3, r2, r3
 8000696:	f640 32b8 	movw	r2, #3000	; 0xbb8
 800069a:	4293      	cmp	r3, r2
 800069c:	d97a      	bls.n	8000794 <main+0x480>
						{
							idel_sub_state =  state_display_date ;
 800069e:	2300      	movs	r3, #0
 80006a0:	f887 304c 	strb.w	r3, [r7, #76]	; 0x4c
							sub_state_timer = get_mtick() ;
 80006a4:	f000 fd52 	bl	800114c <get_mtick>
 80006a8:	4603      	mov	r3, r0
 80006aa:	4a82      	ldr	r2, [pc, #520]	; (80008b4 <main+0x5a0>)
 80006ac:	6013      	str	r3, [r2, #0]
							Display_Clear(&lcd1) ;
 80006ae:	487d      	ldr	r0, [pc, #500]	; (80008a4 <main+0x590>)
 80006b0:	f001 f860 	bl	8001774 <Display_Clear>
							Display_Clear(&lcd2) ;
 80006b4:	487d      	ldr	r0, [pc, #500]	; (80008ac <main+0x598>)
 80006b6:	f001 f85d 	bl	8001774 <Display_Clear>
							Display_Clear(&lcd3) ;
 80006ba:	487d      	ldr	r0, [pc, #500]	; (80008b0 <main+0x59c>)
 80006bc:	f001 f85a 	bl	8001774 <Display_Clear>
						}

						break ;
 80006c0:	e068      	b.n	8000794 <main+0x480>
					}
					case state_display_date:
					{

						rtc_get_date(&d) ;
 80006c2:	f107 0320 	add.w	r3, r7, #32
 80006c6:	4618      	mov	r0, r3
 80006c8:	f001 feee 	bl	80024a8 <rtc_get_date>

						char year[6] ;
						char month[4] ;
						char day[4] ;

						sprintf(year , "20%.2d" , d.year) ;
 80006cc:	f897 3022 	ldrb.w	r3, [r7, #34]	; 0x22
 80006d0:	461a      	mov	r2, r3
 80006d2:	f107 030c 	add.w	r3, r7, #12
 80006d6:	4978      	ldr	r1, [pc, #480]	; (80008b8 <main+0x5a4>)
 80006d8:	4618      	mov	r0, r3
 80006da:	f002 f883 	bl	80027e4 <siprintf>
						sprintf(month , "%.2d" , d.month) ;
 80006de:	f897 3021 	ldrb.w	r3, [r7, #33]	; 0x21
 80006e2:	461a      	mov	r2, r3
 80006e4:	f107 0308 	add.w	r3, r7, #8
 80006e8:	496d      	ldr	r1, [pc, #436]	; (80008a0 <main+0x58c>)
 80006ea:	4618      	mov	r0, r3
 80006ec:	f002 f87a 	bl	80027e4 <siprintf>
						sprintf(day  , "%.2d" , d.day) ;
 80006f0:	f897 3020 	ldrb.w	r3, [r7, #32]
 80006f4:	461a      	mov	r2, r3
 80006f6:	1d3b      	adds	r3, r7, #4
 80006f8:	4969      	ldr	r1, [pc, #420]	; (80008a0 <main+0x58c>)
 80006fa:	4618      	mov	r0, r3
 80006fc:	f002 f872 	bl	80027e4 <siprintf>

						Display_GotoXY(&lcd1 , 50,20);
 8000700:	2214      	movs	r2, #20
 8000702:	2132      	movs	r1, #50	; 0x32
 8000704:	4867      	ldr	r0, [pc, #412]	; (80008a4 <main+0x590>)
 8000706:	f000 ff74 	bl	80015f2 <Display_GotoXY>

						Display_Puts(&lcd1 ,day ,& Font_11x18 , Display_COLOR_WHITE ) ;
 800070a:	1d39      	adds	r1, r7, #4
 800070c:	2301      	movs	r3, #1
 800070e:	4a66      	ldr	r2, [pc, #408]	; (80008a8 <main+0x594>)
 8000710:	4864      	ldr	r0, [pc, #400]	; (80008a4 <main+0x590>)
 8000712:	f001 f80a 	bl	800172a <Display_Puts>

						Display_GotoXY(&lcd2 , 50,20);
 8000716:	2214      	movs	r2, #20
 8000718:	2132      	movs	r1, #50	; 0x32
 800071a:	4864      	ldr	r0, [pc, #400]	; (80008ac <main+0x598>)
 800071c:	f000 ff69 	bl	80015f2 <Display_GotoXY>

						Display_Puts(&lcd2 ,month ,& Font_11x18 , Display_COLOR_WHITE ) ;
 8000720:	f107 0108 	add.w	r1, r7, #8
 8000724:	2301      	movs	r3, #1
 8000726:	4a60      	ldr	r2, [pc, #384]	; (80008a8 <main+0x594>)
 8000728:	4860      	ldr	r0, [pc, #384]	; (80008ac <main+0x598>)
 800072a:	f000 fffe 	bl	800172a <Display_Puts>

						Display_GotoXY(&lcd3 , 40,20);
 800072e:	2214      	movs	r2, #20
 8000730:	2128      	movs	r1, #40	; 0x28
 8000732:	485f      	ldr	r0, [pc, #380]	; (80008b0 <main+0x59c>)
 8000734:	f000 ff5d 	bl	80015f2 <Display_GotoXY>

						Display_Puts(&lcd3 ,year ,& Font_11x18 , Display_COLOR_WHITE ) ;
 8000738:	f107 010c 	add.w	r1, r7, #12
 800073c:	2301      	movs	r3, #1
 800073e:	4a5a      	ldr	r2, [pc, #360]	; (80008a8 <main+0x594>)
 8000740:	485b      	ldr	r0, [pc, #364]	; (80008b0 <main+0x59c>)
 8000742:	f000 fff2 	bl	800172a <Display_Puts>

						Display_UpdateScreen(&lcd1);
 8000746:	4857      	ldr	r0, [pc, #348]	; (80008a4 <main+0x590>)
 8000748:	f000 fe9f 	bl	800148a <Display_UpdateScreen>
						Display_UpdateScreen(&lcd2);
 800074c:	4857      	ldr	r0, [pc, #348]	; (80008ac <main+0x598>)
 800074e:	f000 fe9c 	bl	800148a <Display_UpdateScreen>
						Display_UpdateScreen(&lcd3);
 8000752:	4857      	ldr	r0, [pc, #348]	; (80008b0 <main+0x59c>)
 8000754:	f000 fe99 	bl	800148a <Display_UpdateScreen>

						if(get_mtick() - sub_state_timer > 3000)
 8000758:	f000 fcf8 	bl	800114c <get_mtick>
 800075c:	4602      	mov	r2, r0
 800075e:	4b55      	ldr	r3, [pc, #340]	; (80008b4 <main+0x5a0>)
 8000760:	681b      	ldr	r3, [r3, #0]
 8000762:	1ad3      	subs	r3, r2, r3
 8000764:	f640 32b8 	movw	r2, #3000	; 0xbb8
 8000768:	4293      	cmp	r3, r2
 800076a:	d915      	bls.n	8000798 <main+0x484>
						{
							idel_sub_state =  state_display_time ;
 800076c:	2301      	movs	r3, #1
 800076e:	f887 304c 	strb.w	r3, [r7, #76]	; 0x4c
							Display_Clear(&lcd1) ;
 8000772:	484c      	ldr	r0, [pc, #304]	; (80008a4 <main+0x590>)
 8000774:	f000 fffe 	bl	8001774 <Display_Clear>
							Display_Clear(&lcd2) ;
 8000778:	484c      	ldr	r0, [pc, #304]	; (80008ac <main+0x598>)
 800077a:	f000 fffb 	bl	8001774 <Display_Clear>
							Display_Clear(&lcd3) ;
 800077e:	484c      	ldr	r0, [pc, #304]	; (80008b0 <main+0x59c>)
 8000780:	f000 fff8 	bl	8001774 <Display_Clear>
							sub_state_timer = get_mtick() ;
 8000784:	f000 fce2 	bl	800114c <get_mtick>
 8000788:	4603      	mov	r3, r0
 800078a:	4a4a      	ldr	r2, [pc, #296]	; (80008b4 <main+0x5a0>)
 800078c:	6013      	str	r3, [r2, #0]
						}

						break ;
 800078e:	e003      	b.n	8000798 <main+0x484>
					}
					default :
						break ;
 8000790:	bf00      	nop
 8000792:	e002      	b.n	800079a <main+0x486>
						break ;
 8000794:	bf00      	nop
 8000796:	e000      	b.n	800079a <main+0x486>
						break ;
 8000798:	bf00      	nop
				}

				if( key != 0)
 800079a:	f897 304e 	ldrb.w	r3, [r7, #78]	; 0x4e
 800079e:	2b00      	cmp	r3, #0
 80007a0:	f000 81b9 	beq.w	8000b16 <main+0x802>
				{
					sys_state = state_menu_nav ; //transition
 80007a4:	2302      	movs	r3, #2
 80007a6:	f887 304d 	strb.w	r3, [r7, #77]	; 0x4d
				}

				break ;
 80007aa:	e1b4      	b.n	8000b16 <main+0x802>
			}
			case state_menu_nav:
			{
				switch(menu_nav_sub_state)
 80007ac:	f897 304b 	ldrb.w	r3, [r7, #75]	; 0x4b
 80007b0:	2b05      	cmp	r3, #5
 80007b2:	f200 81b2 	bhi.w	8000b1a <main+0x806>
 80007b6:	a201      	add	r2, pc, #4	; (adr r2, 80007bc <main+0x4a8>)
 80007b8:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 80007bc:	080007d5 	.word	0x080007d5
 80007c0:	08000843 	.word	0x08000843
 80007c4:	08000961 	.word	0x08000961
 80007c8:	080009eb 	.word	0x080009eb
 80007cc:	08000abd 	.word	0x08000abd
 80007d0:	08000b07 	.word	0x08000b07
					static int menu_index = 0 ;
					static int menu_index_prev  = 0 ;
					static char * selected_sub_menu_item ;
					case menu_nav_start:
					{
						Display_Clear(&lcd1) ;
 80007d4:	4833      	ldr	r0, [pc, #204]	; (80008a4 <main+0x590>)
 80007d6:	f000 ffcd 	bl	8001774 <Display_Clear>
						Display_Clear(&lcd2) ;
 80007da:	4834      	ldr	r0, [pc, #208]	; (80008ac <main+0x598>)
 80007dc:	f000 ffca 	bl	8001774 <Display_Clear>
						Display_Clear(&lcd3) ;
 80007e0:	4833      	ldr	r0, [pc, #204]	; (80008b0 <main+0x59c>)
 80007e2:	f000 ffc7 	bl	8001774 <Display_Clear>
						Display_GotoXY(&lcd1 , 10,20);
 80007e6:	2214      	movs	r2, #20
 80007e8:	210a      	movs	r1, #10
 80007ea:	482e      	ldr	r0, [pc, #184]	; (80008a4 <main+0x590>)
 80007ec:	f000 ff01 	bl	80015f2 <Display_GotoXY>

						Display_Puts(&lcd1 ,"Zeit" ,& Font_11x18 , Display_COLOR_WHITE ) ;
 80007f0:	2301      	movs	r3, #1
 80007f2:	4a2d      	ldr	r2, [pc, #180]	; (80008a8 <main+0x594>)
 80007f4:	4931      	ldr	r1, [pc, #196]	; (80008bc <main+0x5a8>)
 80007f6:	482b      	ldr	r0, [pc, #172]	; (80008a4 <main+0x590>)
 80007f8:	f000 ff97 	bl	800172a <Display_Puts>

						Display_GotoXY(&lcd2 , 10,20);
 80007fc:	2214      	movs	r2, #20
 80007fe:	210a      	movs	r1, #10
 8000800:	482a      	ldr	r0, [pc, #168]	; (80008ac <main+0x598>)
 8000802:	f000 fef6 	bl	80015f2 <Display_GotoXY>

						Display_Puts(&lcd2 ,"date" ,& Font_11x18 , Display_COLOR_WHITE ) ;
 8000806:	2301      	movs	r3, #1
 8000808:	4a27      	ldr	r2, [pc, #156]	; (80008a8 <main+0x594>)
 800080a:	492d      	ldr	r1, [pc, #180]	; (80008c0 <main+0x5ac>)
 800080c:	4827      	ldr	r0, [pc, #156]	; (80008ac <main+0x598>)
 800080e:	f000 ff8c 	bl	800172a <Display_Puts>

						Display_GotoXY(&lcd3 , 10,20);
 8000812:	2214      	movs	r2, #20
 8000814:	210a      	movs	r1, #10
 8000816:	4826      	ldr	r0, [pc, #152]	; (80008b0 <main+0x59c>)
 8000818:	f000 feeb 	bl	80015f2 <Display_GotoXY>

						Display_Puts(&lcd3 ,"parametre" ,& Font_11x18 , Display_COLOR_WHITE ) ;
 800081c:	2301      	movs	r3, #1
 800081e:	4a22      	ldr	r2, [pc, #136]	; (80008a8 <main+0x594>)
 8000820:	4928      	ldr	r1, [pc, #160]	; (80008c4 <main+0x5b0>)
 8000822:	4823      	ldr	r0, [pc, #140]	; (80008b0 <main+0x59c>)
 8000824:	f000 ff81 	bl	800172a <Display_Puts>

						Display_UpdateScreen(&lcd1);
 8000828:	481e      	ldr	r0, [pc, #120]	; (80008a4 <main+0x590>)
 800082a:	f000 fe2e 	bl	800148a <Display_UpdateScreen>
						Display_UpdateScreen(&lcd2);
 800082e:	481f      	ldr	r0, [pc, #124]	; (80008ac <main+0x598>)
 8000830:	f000 fe2b 	bl	800148a <Display_UpdateScreen>
						Display_UpdateScreen(&lcd3);
 8000834:	481e      	ldr	r0, [pc, #120]	; (80008b0 <main+0x59c>)
 8000836:	f000 fe28 	bl	800148a <Display_UpdateScreen>

						menu_nav_sub_state = menu_nav_update ;
 800083a:	2301      	movs	r3, #1
 800083c:	f887 304b 	strb.w	r3, [r7, #75]	; 0x4b
						break ;
 8000840:	e164      	b.n	8000b0c <main+0x7f8>
					}
					case menu_nav_update:
					{


						if( key == '6' )
 8000842:	f897 304e 	ldrb.w	r3, [r7, #78]	; 0x4e
 8000846:	2b36      	cmp	r3, #54	; 0x36
 8000848:	d109      	bne.n	800085e <main+0x54a>
						{
							//right
							menu_index_prev = menu_index ;
 800084a:	4b1f      	ldr	r3, [pc, #124]	; (80008c8 <main+0x5b4>)
 800084c:	681b      	ldr	r3, [r3, #0]
 800084e:	4a1f      	ldr	r2, [pc, #124]	; (80008cc <main+0x5b8>)
 8000850:	6013      	str	r3, [r2, #0]
							menu_index++;
 8000852:	4b1d      	ldr	r3, [pc, #116]	; (80008c8 <main+0x5b4>)
 8000854:	681b      	ldr	r3, [r3, #0]
 8000856:	3301      	adds	r3, #1
 8000858:	4a1b      	ldr	r2, [pc, #108]	; (80008c8 <main+0x5b4>)
 800085a:	6013      	str	r3, [r2, #0]
 800085c:	e05a      	b.n	8000914 <main+0x600>
						}
						else if( key == '4')
 800085e:	f897 304e 	ldrb.w	r3, [r7, #78]	; 0x4e
 8000862:	2b34      	cmp	r3, #52	; 0x34
 8000864:	d109      	bne.n	800087a <main+0x566>
						{
							//left
							menu_index_prev = menu_index ;
 8000866:	4b18      	ldr	r3, [pc, #96]	; (80008c8 <main+0x5b4>)
 8000868:	681b      	ldr	r3, [r3, #0]
 800086a:	4a18      	ldr	r2, [pc, #96]	; (80008cc <main+0x5b8>)
 800086c:	6013      	str	r3, [r2, #0]
							menu_index--;
 800086e:	4b16      	ldr	r3, [pc, #88]	; (80008c8 <main+0x5b4>)
 8000870:	681b      	ldr	r3, [r3, #0]
 8000872:	3b01      	subs	r3, #1
 8000874:	4a14      	ldr	r2, [pc, #80]	; (80008c8 <main+0x5b4>)
 8000876:	6013      	str	r3, [r2, #0]
 8000878:	e04c      	b.n	8000914 <main+0x600>
						}
						else if( key == '#' )
 800087a:	f897 304e 	ldrb.w	r3, [r7, #78]	; 0x4e
 800087e:	2b23      	cmp	r3, #35	; 0x23
 8000880:	d126      	bne.n	80008d0 <main+0x5bc>
						{
							//transition
							//confirm
							menu_nav_sub_state = menu_nav_submenu_start ; //go to submenu
 8000882:	2302      	movs	r3, #2
 8000884:	f887 304b 	strb.w	r3, [r7, #75]	; 0x4b
							Display_Clear(&lcd1) ;
 8000888:	4806      	ldr	r0, [pc, #24]	; (80008a4 <main+0x590>)
 800088a:	f000 ff73 	bl	8001774 <Display_Clear>
							Display_Clear(&lcd2) ;
 800088e:	4807      	ldr	r0, [pc, #28]	; (80008ac <main+0x598>)
 8000890:	f000 ff70 	bl	8001774 <Display_Clear>
							Display_Clear(&lcd3) ;
 8000894:	4806      	ldr	r0, [pc, #24]	; (80008b0 <main+0x59c>)
 8000896:	f000 ff6d 	bl	8001774 <Display_Clear>
 800089a:	e03b      	b.n	8000914 <main+0x600>
 800089c:	2000004c 	.word	0x2000004c
 80008a0:	080031c0 	.word	0x080031c0
 80008a4:	200000fc 	.word	0x200000fc
 80008a8:	20000060 	.word	0x20000060
 80008ac:	20000508 	.word	0x20000508
 80008b0:	20000914 	.word	0x20000914
 80008b4:	20000d34 	.word	0x20000d34
 80008b8:	080031c8 	.word	0x080031c8
 80008bc:	080031d0 	.word	0x080031d0
 80008c0:	08003120 	.word	0x08003120
 80008c4:	080031d8 	.word	0x080031d8
 80008c8:	20000d38 	.word	0x20000d38
 80008cc:	20000d3c 	.word	0x20000d3c
							//sys_state =
						}
						else if(key == '*')
 80008d0:	f897 304e 	ldrb.w	r3, [r7, #78]	; 0x4e
 80008d4:	2b2a      	cmp	r3, #42	; 0x2a
 80008d6:	d11d      	bne.n	8000914 <main+0x600>
						{
							//transiton
							//back
							menu_nav_sub_state = menu_nav_start ; //reset substate
 80008d8:	2300      	movs	r3, #0
 80008da:	f887 304b 	strb.w	r3, [r7, #75]	; 0x4b
							sys_state = state_idle ;
 80008de:	2301      	movs	r3, #1
 80008e0:	f887 304d 	strb.w	r3, [r7, #77]	; 0x4d

							/*
							 * turn off LEDs
							 */
							gpio_set_pinState(GPIOA , LED_TAB[0]  , LOW ) ;
 80008e4:	4bab      	ldr	r3, [pc, #684]	; (8000b94 <main+0x880>)
 80008e6:	681b      	ldr	r3, [r3, #0]
 80008e8:	2201      	movs	r2, #1
 80008ea:	4619      	mov	r1, r3
 80008ec:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
 80008f0:	f001 f8f0 	bl	8001ad4 <gpio_set_pinState>
							gpio_set_pinState(GPIOA , LED_TAB[1]  , LOW ) ;
 80008f4:	4ba7      	ldr	r3, [pc, #668]	; (8000b94 <main+0x880>)
 80008f6:	685b      	ldr	r3, [r3, #4]
 80008f8:	2201      	movs	r2, #1
 80008fa:	4619      	mov	r1, r3
 80008fc:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
 8000900:	f001 f8e8 	bl	8001ad4 <gpio_set_pinState>
							gpio_set_pinState(GPIOA , LED_TAB[2]  , LOW ) ;
 8000904:	4ba3      	ldr	r3, [pc, #652]	; (8000b94 <main+0x880>)
 8000906:	689b      	ldr	r3, [r3, #8]
 8000908:	2201      	movs	r2, #1
 800090a:	4619      	mov	r1, r3
 800090c:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
 8000910:	f001 f8e0 	bl	8001ad4 <gpio_set_pinState>
						}
						else{

						}

						if(menu_index >= 3)
 8000914:	4ba0      	ldr	r3, [pc, #640]	; (8000b98 <main+0x884>)
 8000916:	681b      	ldr	r3, [r3, #0]
 8000918:	2b02      	cmp	r3, #2
 800091a:	dd03      	ble.n	8000924 <main+0x610>
						{
							menu_index = 0 ;
 800091c:	4b9e      	ldr	r3, [pc, #632]	; (8000b98 <main+0x884>)
 800091e:	2200      	movs	r2, #0
 8000920:	601a      	str	r2, [r3, #0]
 8000922:	e006      	b.n	8000932 <main+0x61e>
						}

						else if(menu_index < 0)
 8000924:	4b9c      	ldr	r3, [pc, #624]	; (8000b98 <main+0x884>)
 8000926:	681b      	ldr	r3, [r3, #0]
 8000928:	2b00      	cmp	r3, #0
 800092a:	da02      	bge.n	8000932 <main+0x61e>
						{
							menu_index = 2 ;
 800092c:	4b9a      	ldr	r3, [pc, #616]	; (8000b98 <main+0x884>)
 800092e:	2202      	movs	r2, #2
 8000930:	601a      	str	r2, [r3, #0]
						}
						else{

						}

						gpio_set_pinState(GPIOA , LED_TAB[menu_index_prev]  , LOW ) ;
 8000932:	4b9a      	ldr	r3, [pc, #616]	; (8000b9c <main+0x888>)
 8000934:	681b      	ldr	r3, [r3, #0]
 8000936:	4a97      	ldr	r2, [pc, #604]	; (8000b94 <main+0x880>)
 8000938:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 800093c:	2201      	movs	r2, #1
 800093e:	4619      	mov	r1, r3
 8000940:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
 8000944:	f001 f8c6 	bl	8001ad4 <gpio_set_pinState>
						gpio_set_pinState(GPIOA , LED_TAB[menu_index]  , HIGH  ) ;
 8000948:	4b93      	ldr	r3, [pc, #588]	; (8000b98 <main+0x884>)
 800094a:	681b      	ldr	r3, [r3, #0]
 800094c:	4a91      	ldr	r2, [pc, #580]	; (8000b94 <main+0x880>)
 800094e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8000952:	2200      	movs	r2, #0
 8000954:	4619      	mov	r1, r3
 8000956:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
 800095a:	f001 f8bb 	bl	8001ad4 <gpio_set_pinState>

						//current_lcd

						break ;
 800095e:	e0d5      	b.n	8000b0c <main+0x7f8>
					}
					case menu_nav_submenu_start :
					{
						//executed once when entring  submenu
						Display_GotoXY(&lcd1 , 10,20);
 8000960:	2214      	movs	r2, #20
 8000962:	210a      	movs	r1, #10
 8000964:	488e      	ldr	r0, [pc, #568]	; (8000ba0 <main+0x88c>)
 8000966:	f000 fe44 	bl	80015f2 <Display_GotoXY>

						Display_Puts(&lcd1 ,(char*)MENU[menu_index] ,& Font_11x18 , Display_COLOR_WHITE ) ;
 800096a:	4b8b      	ldr	r3, [pc, #556]	; (8000b98 <main+0x884>)
 800096c:	681b      	ldr	r3, [r3, #0]
 800096e:	4a8d      	ldr	r2, [pc, #564]	; (8000ba4 <main+0x890>)
 8000970:	f852 1023 	ldr.w	r1, [r2, r3, lsl #2]
 8000974:	2301      	movs	r3, #1
 8000976:	4a8c      	ldr	r2, [pc, #560]	; (8000ba8 <main+0x894>)
 8000978:	4889      	ldr	r0, [pc, #548]	; (8000ba0 <main+0x88c>)
 800097a:	f000 fed6 	bl	800172a <Display_Puts>

						for(int i = 0 ; i < submenu_item_lenght[menu_index] ; i++ )
 800097e:	2300      	movs	r3, #0
 8000980:	63fb      	str	r3, [r7, #60]	; 0x3c
 8000982:	e01d      	b.n	80009c0 <main+0x6ac>
						{
							Display_GotoXY(&lcd2 , 10 , 5 + (9 * i) );
 8000984:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8000986:	b29b      	uxth	r3, r3
 8000988:	461a      	mov	r2, r3
 800098a:	00d2      	lsls	r2, r2, #3
 800098c:	4413      	add	r3, r2
 800098e:	b29b      	uxth	r3, r3
 8000990:	3305      	adds	r3, #5
 8000992:	b29b      	uxth	r3, r3
 8000994:	461a      	mov	r2, r3
 8000996:	210a      	movs	r1, #10
 8000998:	4884      	ldr	r0, [pc, #528]	; (8000bac <main+0x898>)
 800099a:	f000 fe2a 	bl	80015f2 <Display_GotoXY>
							Display_Puts(&lcd2 ,(char*)SUB_MENU[menu_index][i] ,& Font_7x10 , Display_COLOR_WHITE ) ;
 800099e:	4b7e      	ldr	r3, [pc, #504]	; (8000b98 <main+0x884>)
 80009a0:	681b      	ldr	r3, [r3, #0]
 80009a2:	4a83      	ldr	r2, [pc, #524]	; (8000bb0 <main+0x89c>)
 80009a4:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
 80009a8:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80009aa:	009b      	lsls	r3, r3, #2
 80009ac:	4413      	add	r3, r2
 80009ae:	6819      	ldr	r1, [r3, #0]
 80009b0:	2301      	movs	r3, #1
 80009b2:	4a80      	ldr	r2, [pc, #512]	; (8000bb4 <main+0x8a0>)
 80009b4:	487d      	ldr	r0, [pc, #500]	; (8000bac <main+0x898>)
 80009b6:	f000 feb8 	bl	800172a <Display_Puts>
						for(int i = 0 ; i < submenu_item_lenght[menu_index] ; i++ )
 80009ba:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80009bc:	3301      	adds	r3, #1
 80009be:	63fb      	str	r3, [r7, #60]	; 0x3c
 80009c0:	4b75      	ldr	r3, [pc, #468]	; (8000b98 <main+0x884>)
 80009c2:	681b      	ldr	r3, [r3, #0]
 80009c4:	4a7c      	ldr	r2, [pc, #496]	; (8000bb8 <main+0x8a4>)
 80009c6:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 80009ca:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 80009cc:	429a      	cmp	r2, r3
 80009ce:	dbd9      	blt.n	8000984 <main+0x670>
						}

						Display_UpdateScreen(&lcd1);
 80009d0:	4873      	ldr	r0, [pc, #460]	; (8000ba0 <main+0x88c>)
 80009d2:	f000 fd5a 	bl	800148a <Display_UpdateScreen>
						Display_UpdateScreen(&lcd2);
 80009d6:	4875      	ldr	r0, [pc, #468]	; (8000bac <main+0x898>)
 80009d8:	f000 fd57 	bl	800148a <Display_UpdateScreen>
						Display_UpdateScreen(&lcd3);
 80009dc:	4877      	ldr	r0, [pc, #476]	; (8000bbc <main+0x8a8>)
 80009de:	f000 fd54 	bl	800148a <Display_UpdateScreen>

						menu_nav_sub_state = menu_nav_submenu_update ;
 80009e2:	2303      	movs	r3, #3
 80009e4:	f887 304b 	strb.w	r3, [r7, #75]	; 0x4b

						break ;
 80009e8:	e090      	b.n	8000b0c <main+0x7f8>

					case menu_nav_submenu_update :
					{
						static int submenu_index = 0 ;

						if(key == '2')
 80009ea:	f897 304e 	ldrb.w	r3, [r7, #78]	; 0x4e
 80009ee:	2b32      	cmp	r3, #50	; 0x32
 80009f0:	d108      	bne.n	8000a04 <main+0x6f0>
						{
							Display_Clear(&lcd3) ;
 80009f2:	4872      	ldr	r0, [pc, #456]	; (8000bbc <main+0x8a8>)
 80009f4:	f000 febe 	bl	8001774 <Display_Clear>
							submenu_index--;
 80009f8:	4b71      	ldr	r3, [pc, #452]	; (8000bc0 <main+0x8ac>)
 80009fa:	681b      	ldr	r3, [r3, #0]
 80009fc:	3b01      	subs	r3, #1
 80009fe:	4a70      	ldr	r2, [pc, #448]	; (8000bc0 <main+0x8ac>)
 8000a00:	6013      	str	r3, [r2, #0]
 8000a02:	e02a      	b.n	8000a5a <main+0x746>
						}
						else if(key == '8')
 8000a04:	f897 304e 	ldrb.w	r3, [r7, #78]	; 0x4e
 8000a08:	2b38      	cmp	r3, #56	; 0x38
 8000a0a:	d108      	bne.n	8000a1e <main+0x70a>
						{
							Display_Clear(&lcd3) ;
 8000a0c:	486b      	ldr	r0, [pc, #428]	; (8000bbc <main+0x8a8>)
 8000a0e:	f000 feb1 	bl	8001774 <Display_Clear>
							submenu_index++;
 8000a12:	4b6b      	ldr	r3, [pc, #428]	; (8000bc0 <main+0x8ac>)
 8000a14:	681b      	ldr	r3, [r3, #0]
 8000a16:	3301      	adds	r3, #1
 8000a18:	4a69      	ldr	r2, [pc, #420]	; (8000bc0 <main+0x8ac>)
 8000a1a:	6013      	str	r3, [r2, #0]
 8000a1c:	e01d      	b.n	8000a5a <main+0x746>
						}

						else if(key == '*')
 8000a1e:	f897 304e 	ldrb.w	r3, [r7, #78]	; 0x4e
 8000a22:	2b2a      	cmp	r3, #42	; 0x2a
 8000a24:	d103      	bne.n	8000a2e <main+0x71a>
						{
							//transition
							menu_nav_sub_state = menu_nav_start ; //reset substate
 8000a26:	2300      	movs	r3, #0
 8000a28:	f887 304b 	strb.w	r3, [r7, #75]	; 0x4b
 8000a2c:	e015      	b.n	8000a5a <main+0x746>
						}
						else if( key == '#')
 8000a2e:	f897 304e 	ldrb.w	r3, [r7, #78]	; 0x4e
 8000a32:	2b23      	cmp	r3, #35	; 0x23
 8000a34:	d111      	bne.n	8000a5a <main+0x746>
						{
							//transition to configuration
							Display_Clear(&lcd3) ;
 8000a36:	4861      	ldr	r0, [pc, #388]	; (8000bbc <main+0x8a8>)
 8000a38:	f000 fe9c 	bl	8001774 <Display_Clear>
							menu_nav_sub_state = menu_nav_submenu_config ;
 8000a3c:	2304      	movs	r3, #4
 8000a3e:	f887 304b 	strb.w	r3, [r7, #75]	; 0x4b
							selected_sub_menu_item = (char*)SUB_MENU[menu_index][submenu_index] ;
 8000a42:	4b55      	ldr	r3, [pc, #340]	; (8000b98 <main+0x884>)
 8000a44:	681b      	ldr	r3, [r3, #0]
 8000a46:	4a5a      	ldr	r2, [pc, #360]	; (8000bb0 <main+0x89c>)
 8000a48:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
 8000a4c:	4b5c      	ldr	r3, [pc, #368]	; (8000bc0 <main+0x8ac>)
 8000a4e:	681b      	ldr	r3, [r3, #0]
 8000a50:	009b      	lsls	r3, r3, #2
 8000a52:	4413      	add	r3, r2
 8000a54:	681b      	ldr	r3, [r3, #0]
 8000a56:	4a5b      	ldr	r2, [pc, #364]	; (8000bc4 <main+0x8b0>)
 8000a58:	6013      	str	r3, [r2, #0]
						}


						//test boundry

						if(submenu_index >= submenu_item_lenght[menu_index])
 8000a5a:	4b4f      	ldr	r3, [pc, #316]	; (8000b98 <main+0x884>)
 8000a5c:	681b      	ldr	r3, [r3, #0]
 8000a5e:	4a56      	ldr	r2, [pc, #344]	; (8000bb8 <main+0x8a4>)
 8000a60:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
 8000a64:	4b56      	ldr	r3, [pc, #344]	; (8000bc0 <main+0x8ac>)
 8000a66:	681b      	ldr	r3, [r3, #0]
 8000a68:	429a      	cmp	r2, r3
 8000a6a:	dc03      	bgt.n	8000a74 <main+0x760>
						{
							submenu_index = 0 ;
 8000a6c:	4b54      	ldr	r3, [pc, #336]	; (8000bc0 <main+0x8ac>)
 8000a6e:	2200      	movs	r2, #0
 8000a70:	601a      	str	r2, [r3, #0]
 8000a72:	e00b      	b.n	8000a8c <main+0x778>
						}
						else if(submenu_index < 0)
 8000a74:	4b52      	ldr	r3, [pc, #328]	; (8000bc0 <main+0x8ac>)
 8000a76:	681b      	ldr	r3, [r3, #0]
 8000a78:	2b00      	cmp	r3, #0
 8000a7a:	da07      	bge.n	8000a8c <main+0x778>
						{
							submenu_index = submenu_item_lenght[menu_index] - 1 ;
 8000a7c:	4b46      	ldr	r3, [pc, #280]	; (8000b98 <main+0x884>)
 8000a7e:	681b      	ldr	r3, [r3, #0]
 8000a80:	4a4d      	ldr	r2, [pc, #308]	; (8000bb8 <main+0x8a4>)
 8000a82:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8000a86:	3b01      	subs	r3, #1
 8000a88:	4a4d      	ldr	r2, [pc, #308]	; (8000bc0 <main+0x8ac>)
 8000a8a:	6013      	str	r3, [r2, #0]
						}

						Display_GotoXY(&lcd3 , 10 , 20 );
 8000a8c:	2214      	movs	r2, #20
 8000a8e:	210a      	movs	r1, #10
 8000a90:	484a      	ldr	r0, [pc, #296]	; (8000bbc <main+0x8a8>)
 8000a92:	f000 fdae 	bl	80015f2 <Display_GotoXY>
						Display_Puts(&lcd3 ,(char*)SUB_MENU[menu_index][submenu_index] ,& Font_7x10 , Display_COLOR_WHITE ) ;
 8000a96:	4b40      	ldr	r3, [pc, #256]	; (8000b98 <main+0x884>)
 8000a98:	681b      	ldr	r3, [r3, #0]
 8000a9a:	4a45      	ldr	r2, [pc, #276]	; (8000bb0 <main+0x89c>)
 8000a9c:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
 8000aa0:	4b47      	ldr	r3, [pc, #284]	; (8000bc0 <main+0x8ac>)
 8000aa2:	681b      	ldr	r3, [r3, #0]
 8000aa4:	009b      	lsls	r3, r3, #2
 8000aa6:	4413      	add	r3, r2
 8000aa8:	6819      	ldr	r1, [r3, #0]
 8000aaa:	2301      	movs	r3, #1
 8000aac:	4a41      	ldr	r2, [pc, #260]	; (8000bb4 <main+0x8a0>)
 8000aae:	4843      	ldr	r0, [pc, #268]	; (8000bbc <main+0x8a8>)
 8000ab0:	f000 fe3b 	bl	800172a <Display_Puts>
						Display_UpdateScreen(&lcd3);
 8000ab4:	4841      	ldr	r0, [pc, #260]	; (8000bbc <main+0x8a8>)
 8000ab6:	f000 fce8 	bl	800148a <Display_UpdateScreen>

						break ;
 8000aba:	e027      	b.n	8000b0c <main+0x7f8>
					}
					case menu_nav_submenu_config :
					{
						//this state will handle user input
						int ret = handle_user_input(selected_sub_menu_item , key) ;
 8000abc:	4b41      	ldr	r3, [pc, #260]	; (8000bc4 <main+0x8b0>)
 8000abe:	681b      	ldr	r3, [r3, #0]
 8000ac0:	f897 204e 	ldrb.w	r2, [r7, #78]	; 0x4e
 8000ac4:	4611      	mov	r1, r2
 8000ac6:	4618      	mov	r0, r3
 8000ac8:	f000 f902 	bl	8000cd0 <handle_user_input>
 8000acc:	6378      	str	r0, [r7, #52]	; 0x34
						//-1 back
						// -2 nothink
						//other int
						if( ret == -1)
 8000ace:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8000ad0:	f1b3 3fff 	cmp.w	r3, #4294967295
 8000ad4:	d109      	bne.n	8000aea <main+0x7d6>
						{
							//
							Display_Clear(&lcd3) ;
 8000ad6:	4839      	ldr	r0, [pc, #228]	; (8000bbc <main+0x8a8>)
 8000ad8:	f000 fe4c 	bl	8001774 <Display_Clear>
							Display_UpdateScreen(&lcd3);
 8000adc:	4837      	ldr	r0, [pc, #220]	; (8000bbc <main+0x8a8>)
 8000ade:	f000 fcd4 	bl	800148a <Display_UpdateScreen>
							menu_nav_sub_state = menu_nav_submenu_update ;
 8000ae2:	2303      	movs	r3, #3
 8000ae4:	f887 304b 	strb.w	r3, [r7, #75]	; 0x4b
						{
							//save config
							save_config(selected_sub_menu_item , ret) ;
							menu_nav_sub_state = menu_nav_submenu_update ;
						}
						break ;
 8000ae8:	e00f      	b.n	8000b0a <main+0x7f6>
						else if( ret == -2)
 8000aea:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8000aec:	f113 0f02 	cmn.w	r3, #2
 8000af0:	d00b      	beq.n	8000b0a <main+0x7f6>
							save_config(selected_sub_menu_item , ret) ;
 8000af2:	4b34      	ldr	r3, [pc, #208]	; (8000bc4 <main+0x8b0>)
 8000af4:	681b      	ldr	r3, [r3, #0]
 8000af6:	6b79      	ldr	r1, [r7, #52]	; 0x34
 8000af8:	4618      	mov	r0, r3
 8000afa:	f000 f9a9 	bl	8000e50 <save_config>
							menu_nav_sub_state = menu_nav_submenu_update ;
 8000afe:	2303      	movs	r3, #3
 8000b00:	f887 304b 	strb.w	r3, [r7, #75]	; 0x4b
						break ;
 8000b04:	e001      	b.n	8000b0a <main+0x7f6>
					}
					case menu_nav_exit:
					{


						break ;
 8000b06:	bf00      	nop
 8000b08:	e007      	b.n	8000b1a <main+0x806>
						break ;
 8000b0a:	bf00      	nop
					}
				}

				break ;
 8000b0c:	e005      	b.n	8000b1a <main+0x806>
			case state_configuration:
			{
				break ;
			}
			default :
				break ;
 8000b0e:	bf00      	nop
 8000b10:	e004      	b.n	8000b1c <main+0x808>
				break ;
 8000b12:	bf00      	nop
 8000b14:	e002      	b.n	8000b1c <main+0x808>
				break ;
 8000b16:	bf00      	nop
 8000b18:	e000      	b.n	8000b1c <main+0x808>
				break ;
 8000b1a:	bf00      	nop
		}


		key = keypad_get_pressedkey() ;
 8000b1c:	f001 fa72 	bl	8002004 <keypad_get_pressedkey>
 8000b20:	4603      	mov	r3, r0
 8000b22:	f887 304e 	strb.w	r3, [r7, #78]	; 0x4e

		rtc_update() ;
 8000b26:	f001 fe1f 	bl	8002768 <rtc_update>

		if(get_mtick() - led_timer > 1000)
 8000b2a:	f000 fb0f 	bl	800114c <get_mtick>
 8000b2e:	4602      	mov	r2, r0
 8000b30:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8000b32:	1ad3      	subs	r3, r2, r3
 8000b34:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
 8000b38:	d902      	bls.n	8000b40 <main+0x82c>
		{
			//
			//gpio_toggel(GPIOA , 5) ;
			led_timer = get_mtick() ;
 8000b3a:	f000 fb07 	bl	800114c <get_mtick>
 8000b3e:	6438      	str	r0, [r7, #64]	; 0x40
		}


		if(handle_alarm == true)
 8000b40:	4b21      	ldr	r3, [pc, #132]	; (8000bc8 <main+0x8b4>)
 8000b42:	781b      	ldrb	r3, [r3, #0]
 8000b44:	b2db      	uxtb	r3, r3
 8000b46:	2b00      	cmp	r3, #0
 8000b48:	f000 8093 	beq.w	8000c72 <main+0x95e>
		{

			if(key == '5')
 8000b4c:	f897 304e 	ldrb.w	r3, [r7, #78]	; 0x4e
 8000b50:	2b35      	cmp	r3, #53	; 0x35
 8000b52:	d105      	bne.n	8000b60 <main+0x84c>
			{
				alarm_state = alarm_exit ;
 8000b54:	2302      	movs	r3, #2
 8000b56:	f887 304f 	strb.w	r3, [r7, #79]	; 0x4f
				key = 0;
 8000b5a:	2300      	movs	r3, #0
 8000b5c:	f887 304e 	strb.w	r3, [r7, #78]	; 0x4e
			}

			static int alarm_counter = 0;
			static uint32_t state_low_timer = 0 ;
			activate_naght_mode = true ;
 8000b60:	4b1a      	ldr	r3, [pc, #104]	; (8000bcc <main+0x8b8>)
 8000b62:	2201      	movs	r2, #1
 8000b64:	701a      	strb	r2, [r3, #0]
			night_mode_start_time = get_mtick() ;
 8000b66:	f000 faf1 	bl	800114c <get_mtick>
 8000b6a:	4603      	mov	r3, r0
 8000b6c:	4a18      	ldr	r2, [pc, #96]	; (8000bd0 <main+0x8bc>)
 8000b6e:	6013      	str	r3, [r2, #0]
			gpio_set_pinState(GPIOA , 7,HIGH) ;
 8000b70:	2200      	movs	r2, #0
 8000b72:	2107      	movs	r1, #7
 8000b74:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
 8000b78:	f000 ffac 	bl	8001ad4 <gpio_set_pinState>

			switch(alarm_state)
 8000b7c:	f897 304f 	ldrb.w	r3, [r7, #79]	; 0x4f
 8000b80:	2b02      	cmp	r3, #2
 8000b82:	d066      	beq.n	8000c52 <main+0x93e>
 8000b84:	2b02      	cmp	r3, #2
 8000b86:	dc76      	bgt.n	8000c76 <main+0x962>
 8000b88:	2b00      	cmp	r3, #0
 8000b8a:	d023      	beq.n	8000bd4 <main+0x8c0>
 8000b8c:	2b01      	cmp	r3, #1
 8000b8e:	d03f      	beq.n	8000c10 <main+0x8fc>
					alarm_counter = 0 ;
					//alarm
					gpio_set_pinState(GPIOA , 5,LOW) ;
					break ;
				}
				default : break;
 8000b90:	e071      	b.n	8000c76 <main+0x962>
 8000b92:	bf00      	nop
 8000b94:	2000004c 	.word	0x2000004c
 8000b98:	20000d38 	.word	0x20000d38
 8000b9c:	20000d3c 	.word	0x20000d3c
 8000ba0:	200000fc 	.word	0x200000fc
 8000ba4:	20000004 	.word	0x20000004
 8000ba8:	20000060 	.word	0x20000060
 8000bac:	20000508 	.word	0x20000508
 8000bb0:	2000003c 	.word	0x2000003c
 8000bb4:	20000058 	.word	0x20000058
 8000bb8:	080035e4 	.word	0x080035e4
 8000bbc:	20000914 	.word	0x20000914
 8000bc0:	20000d40 	.word	0x20000d40
 8000bc4:	20000d44 	.word	0x20000d44
 8000bc8:	20000d20 	.word	0x20000d20
 8000bcc:	20000d28 	.word	0x20000d28
 8000bd0:	20000d30 	.word	0x20000d30
					gpio_set_pinState(GPIOA , 5,HIGH) ;
 8000bd4:	2200      	movs	r2, #0
 8000bd6:	2105      	movs	r1, #5
 8000bd8:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
 8000bdc:	f000 ff7a 	bl	8001ad4 <gpio_set_pinState>
					if( get_mtick() - g_alarm_start_time >= 30 * 1000) // 30 second on
 8000be0:	f000 fab4 	bl	800114c <get_mtick>
 8000be4:	4602      	mov	r2, r0
 8000be6:	4b33      	ldr	r3, [pc, #204]	; (8000cb4 <main+0x9a0>)
 8000be8:	681b      	ldr	r3, [r3, #0]
 8000bea:	1ad3      	subs	r3, r2, r3
 8000bec:	f247 522f 	movw	r2, #29999	; 0x752f
 8000bf0:	4293      	cmp	r3, r2
 8000bf2:	d942      	bls.n	8000c7a <main+0x966>
						alarm_state = alarm_state_desactive ;
 8000bf4:	2301      	movs	r3, #1
 8000bf6:	f887 304f 	strb.w	r3, [r7, #79]	; 0x4f
						alarm_counter++ ;
 8000bfa:	4b2f      	ldr	r3, [pc, #188]	; (8000cb8 <main+0x9a4>)
 8000bfc:	681b      	ldr	r3, [r3, #0]
 8000bfe:	3301      	adds	r3, #1
 8000c00:	4a2d      	ldr	r2, [pc, #180]	; (8000cb8 <main+0x9a4>)
 8000c02:	6013      	str	r3, [r2, #0]
						state_low_timer = get_mtick() ;
 8000c04:	f000 faa2 	bl	800114c <get_mtick>
 8000c08:	4603      	mov	r3, r0
 8000c0a:	4a2c      	ldr	r2, [pc, #176]	; (8000cbc <main+0x9a8>)
 8000c0c:	6013      	str	r3, [r2, #0]
					break ;
 8000c0e:	e034      	b.n	8000c7a <main+0x966>
					gpio_set_pinState(GPIOA , 5,LOW) ;
 8000c10:	2201      	movs	r2, #1
 8000c12:	2105      	movs	r1, #5
 8000c14:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
 8000c18:	f000 ff5c 	bl	8001ad4 <gpio_set_pinState>
					if( get_mtick()  - state_low_timer >= 1*60*1000)  //4 min passed
 8000c1c:	f000 fa96 	bl	800114c <get_mtick>
 8000c20:	4602      	mov	r2, r0
 8000c22:	4b26      	ldr	r3, [pc, #152]	; (8000cbc <main+0x9a8>)
 8000c24:	681b      	ldr	r3, [r3, #0]
 8000c26:	1ad3      	subs	r3, r2, r3
 8000c28:	f64e 225f 	movw	r2, #59999	; 0xea5f
 8000c2c:	4293      	cmp	r3, r2
 8000c2e:	d908      	bls.n	8000c42 <main+0x92e>
						alarm_state = alarm_state_active ;
 8000c30:	2300      	movs	r3, #0
 8000c32:	f887 304f 	strb.w	r3, [r7, #79]	; 0x4f
						g_alarm_start_time =  get_mtick() ;
 8000c36:	f000 fa89 	bl	800114c <get_mtick>
 8000c3a:	4603      	mov	r3, r0
 8000c3c:	4a1d      	ldr	r2, [pc, #116]	; (8000cb4 <main+0x9a0>)
 8000c3e:	6013      	str	r3, [r2, #0]
					break ;
 8000c40:	e01d      	b.n	8000c7e <main+0x96a>
					else if(alarm_counter >= 5)
 8000c42:	4b1d      	ldr	r3, [pc, #116]	; (8000cb8 <main+0x9a4>)
 8000c44:	681b      	ldr	r3, [r3, #0]
 8000c46:	2b04      	cmp	r3, #4
 8000c48:	dd19      	ble.n	8000c7e <main+0x96a>
						alarm_state = alarm_exit ;
 8000c4a:	2302      	movs	r3, #2
 8000c4c:	f887 304f 	strb.w	r3, [r7, #79]	; 0x4f
					break ;
 8000c50:	e015      	b.n	8000c7e <main+0x96a>
					handle_alarm = false ;
 8000c52:	4b1b      	ldr	r3, [pc, #108]	; (8000cc0 <main+0x9ac>)
 8000c54:	2200      	movs	r2, #0
 8000c56:	701a      	strb	r2, [r3, #0]
					alarm_state = alarm_state_active ;
 8000c58:	2300      	movs	r3, #0
 8000c5a:	f887 304f 	strb.w	r3, [r7, #79]	; 0x4f
					alarm_counter = 0 ;
 8000c5e:	4b16      	ldr	r3, [pc, #88]	; (8000cb8 <main+0x9a4>)
 8000c60:	2200      	movs	r2, #0
 8000c62:	601a      	str	r2, [r3, #0]
					gpio_set_pinState(GPIOA , 5,LOW) ;
 8000c64:	2201      	movs	r2, #1
 8000c66:	2105      	movs	r1, #5
 8000c68:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
 8000c6c:	f000 ff32 	bl	8001ad4 <gpio_set_pinState>
					break ;
 8000c70:	e006      	b.n	8000c80 <main+0x96c>
			}

		}
 8000c72:	bf00      	nop
 8000c74:	e004      	b.n	8000c80 <main+0x96c>
				default : break;
 8000c76:	bf00      	nop
 8000c78:	e002      	b.n	8000c80 <main+0x96c>
					break ;
 8000c7a:	bf00      	nop
 8000c7c:	e000      	b.n	8000c80 <main+0x96c>
					break ;
 8000c7e:	bf00      	nop

		if(activate_naght_mode == true )
 8000c80:	4b10      	ldr	r3, [pc, #64]	; (8000cc4 <main+0x9b0>)
 8000c82:	781b      	ldrb	r3, [r3, #0]
 8000c84:	2b00      	cmp	r3, #0
 8000c86:	f43f ac42 	beq.w	800050e <main+0x1fa>
		{
			if( get_mtick() - night_mode_start_time >= night_mode_timer)
 8000c8a:	f000 fa5f 	bl	800114c <get_mtick>
 8000c8e:	4602      	mov	r2, r0
 8000c90:	4b0d      	ldr	r3, [pc, #52]	; (8000cc8 <main+0x9b4>)
 8000c92:	681b      	ldr	r3, [r3, #0]
 8000c94:	1ad2      	subs	r2, r2, r3
 8000c96:	4b0d      	ldr	r3, [pc, #52]	; (8000ccc <main+0x9b8>)
 8000c98:	681b      	ldr	r3, [r3, #0]
 8000c9a:	429a      	cmp	r2, r3
 8000c9c:	f4ff ac37 	bcc.w	800050e <main+0x1fa>
			{
				activate_naght_mode = false ;
 8000ca0:	4b08      	ldr	r3, [pc, #32]	; (8000cc4 <main+0x9b0>)
 8000ca2:	2200      	movs	r2, #0
 8000ca4:	701a      	strb	r2, [r3, #0]
				gpio_set_pinState(GPIOA , 7,LOW) ;
 8000ca6:	2201      	movs	r2, #1
 8000ca8:	2107      	movs	r1, #7
 8000caa:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
 8000cae:	f000 ff11 	bl	8001ad4 <gpio_set_pinState>
		switch(sys_state)
 8000cb2:	e42c      	b.n	800050e <main+0x1fa>
 8000cb4:	20000d24 	.word	0x20000d24
 8000cb8:	20000d48 	.word	0x20000d48
 8000cbc:	20000d4c 	.word	0x20000d4c
 8000cc0:	20000d20 	.word	0x20000d20
 8000cc4:	20000d28 	.word	0x20000d28
 8000cc8:	20000d30 	.word	0x20000d30
 8000ccc:	20000d2c 	.word	0x20000d2c

08000cd0 <handle_user_input>:
int handle_2_digit_input(char key) ;
//int handle_4_digit_input(char *key) ;

//
int handle_user_input(const char * submenu_item , char pressed_key)
{
 8000cd0:	b580      	push	{r7, lr}
 8000cd2:	b084      	sub	sp, #16
 8000cd4:	af00      	add	r7, sp, #0
 8000cd6:	6078      	str	r0, [r7, #4]
 8000cd8:	460b      	mov	r3, r1
 8000cda:	70fb      	strb	r3, [r7, #3]
	int ret = 0 ;
 8000cdc:	2300      	movs	r3, #0
 8000cde:	60fb      	str	r3, [r7, #12]

	ret = handle_2_digit_input(pressed_key) ;
 8000ce0:	78fb      	ldrb	r3, [r7, #3]
 8000ce2:	4618      	mov	r0, r3
 8000ce4:	f000 f812 	bl	8000d0c <handle_2_digit_input>
 8000ce8:	60f8      	str	r0, [r7, #12]

	return ret ;
 8000cea:	68fb      	ldr	r3, [r7, #12]
}
 8000cec:	4618      	mov	r0, r3
 8000cee:	3710      	adds	r7, #16
 8000cf0:	46bd      	mov	sp, r7
 8000cf2:	bd80      	pop	{r7, pc}

08000cf4 <key_to_digit>:

static int key_to_digit(char key)
{
 8000cf4:	b480      	push	{r7}
 8000cf6:	b083      	sub	sp, #12
 8000cf8:	af00      	add	r7, sp, #0
 8000cfa:	4603      	mov	r3, r0
 8000cfc:	71fb      	strb	r3, [r7, #7]
	//assure key in['0'..'9']
	return (key - 48) ;
 8000cfe:	79fb      	ldrb	r3, [r7, #7]
 8000d00:	3b30      	subs	r3, #48	; 0x30
}
 8000d02:	4618      	mov	r0, r3
 8000d04:	370c      	adds	r7, #12
 8000d06:	46bd      	mov	sp, r7
 8000d08:	bc80      	pop	{r7}
 8000d0a:	4770      	bx	lr

08000d0c <handle_2_digit_input>:

/**
 * return 0 if the state machine still running , -1 is '*' is pressed ,the user input if '#" is pressed
 */
int handle_2_digit_input(char key)
{
 8000d0c:	b580      	push	{r7, lr}
 8000d0e:	b084      	sub	sp, #16
 8000d10:	af00      	add	r7, sp, #0
 8000d12:	4603      	mov	r3, r0
 8000d14:	71fb      	strb	r3, [r7, #7]
	static input_state_t inp_state = inp_state_one ;
	//char input_string[2] ;
	//static int  input_str_index = 0 ;
	static int  input = 0 ;

	int ret = -2  ;
 8000d16:	f06f 0301 	mvn.w	r3, #1
 8000d1a:	60fb      	str	r3, [r7, #12]

	switch(inp_state)
 8000d1c:	4b48      	ldr	r3, [pc, #288]	; (8000e40 <handle_2_digit_input+0x134>)
 8000d1e:	781b      	ldrb	r3, [r3, #0]
 8000d20:	2b04      	cmp	r3, #4
 8000d22:	d052      	beq.n	8000dca <handle_2_digit_input+0xbe>
 8000d24:	2b04      	cmp	r3, #4
 8000d26:	dc7f      	bgt.n	8000e28 <handle_2_digit_input+0x11c>
 8000d28:	2b00      	cmp	r3, #0
 8000d2a:	d002      	beq.n	8000d32 <handle_2_digit_input+0x26>
 8000d2c:	2b01      	cmp	r3, #1
 8000d2e:	d027      	beq.n	8000d80 <handle_2_digit_input+0x74>

			}
			break ;
		}
		default :
			break ;
 8000d30:	e07a      	b.n	8000e28 <handle_2_digit_input+0x11c>
			if( key != 0 && key != '#' && key != '*')
 8000d32:	79fb      	ldrb	r3, [r7, #7]
 8000d34:	2b00      	cmp	r3, #0
 8000d36:	d079      	beq.n	8000e2c <handle_2_digit_input+0x120>
 8000d38:	79fb      	ldrb	r3, [r7, #7]
 8000d3a:	2b23      	cmp	r3, #35	; 0x23
 8000d3c:	d076      	beq.n	8000e2c <handle_2_digit_input+0x120>
 8000d3e:	79fb      	ldrb	r3, [r7, #7]
 8000d40:	2b2a      	cmp	r3, #42	; 0x2a
 8000d42:	d073      	beq.n	8000e2c <handle_2_digit_input+0x120>
				inp_state = inp_state_two ;
 8000d44:	4b3e      	ldr	r3, [pc, #248]	; (8000e40 <handle_2_digit_input+0x134>)
 8000d46:	2201      	movs	r2, #1
 8000d48:	701a      	strb	r2, [r3, #0]
				Display_GotoXY(&lcd3 , 10 , 30 );
 8000d4a:	221e      	movs	r2, #30
 8000d4c:	210a      	movs	r1, #10
 8000d4e:	483d      	ldr	r0, [pc, #244]	; (8000e44 <handle_2_digit_input+0x138>)
 8000d50:	f000 fc4f 	bl	80015f2 <Display_GotoXY>
				Display_Putc(&lcd3 ,key,& Font_7x10 , Display_COLOR_WHITE ) ;
 8000d54:	79f9      	ldrb	r1, [r7, #7]
 8000d56:	2301      	movs	r3, #1
 8000d58:	4a3b      	ldr	r2, [pc, #236]	; (8000e48 <handle_2_digit_input+0x13c>)
 8000d5a:	483a      	ldr	r0, [pc, #232]	; (8000e44 <handle_2_digit_input+0x138>)
 8000d5c:	f000 fc5e 	bl	800161c <Display_Putc>
				Display_UpdateScreen(&lcd3);
 8000d60:	4838      	ldr	r0, [pc, #224]	; (8000e44 <handle_2_digit_input+0x138>)
 8000d62:	f000 fb92 	bl	800148a <Display_UpdateScreen>
				input = key_to_digit(key) * 10 ;
 8000d66:	79fb      	ldrb	r3, [r7, #7]
 8000d68:	4618      	mov	r0, r3
 8000d6a:	f7ff ffc3 	bl	8000cf4 <key_to_digit>
 8000d6e:	4602      	mov	r2, r0
 8000d70:	4613      	mov	r3, r2
 8000d72:	009b      	lsls	r3, r3, #2
 8000d74:	4413      	add	r3, r2
 8000d76:	005b      	lsls	r3, r3, #1
 8000d78:	461a      	mov	r2, r3
 8000d7a:	4b34      	ldr	r3, [pc, #208]	; (8000e4c <handle_2_digit_input+0x140>)
 8000d7c:	601a      	str	r2, [r3, #0]
			break ;
 8000d7e:	e055      	b.n	8000e2c <handle_2_digit_input+0x120>
			if( key != 0 && key != '#' && key != '*')
 8000d80:	79fb      	ldrb	r3, [r7, #7]
 8000d82:	2b00      	cmp	r3, #0
 8000d84:	d054      	beq.n	8000e30 <handle_2_digit_input+0x124>
 8000d86:	79fb      	ldrb	r3, [r7, #7]
 8000d88:	2b23      	cmp	r3, #35	; 0x23
 8000d8a:	d051      	beq.n	8000e30 <handle_2_digit_input+0x124>
 8000d8c:	79fb      	ldrb	r3, [r7, #7]
 8000d8e:	2b2a      	cmp	r3, #42	; 0x2a
 8000d90:	d04e      	beq.n	8000e30 <handle_2_digit_input+0x124>
				inp_state = inp_state_validate ;
 8000d92:	4b2b      	ldr	r3, [pc, #172]	; (8000e40 <handle_2_digit_input+0x134>)
 8000d94:	2204      	movs	r2, #4
 8000d96:	701a      	strb	r2, [r3, #0]
				Display_GotoXY(&lcd3 , 20 , 30 );
 8000d98:	221e      	movs	r2, #30
 8000d9a:	2114      	movs	r1, #20
 8000d9c:	4829      	ldr	r0, [pc, #164]	; (8000e44 <handle_2_digit_input+0x138>)
 8000d9e:	f000 fc28 	bl	80015f2 <Display_GotoXY>
				Display_Putc(&lcd3 ,key,& Font_7x10 , Display_COLOR_WHITE ) ;
 8000da2:	79f9      	ldrb	r1, [r7, #7]
 8000da4:	2301      	movs	r3, #1
 8000da6:	4a28      	ldr	r2, [pc, #160]	; (8000e48 <handle_2_digit_input+0x13c>)
 8000da8:	4826      	ldr	r0, [pc, #152]	; (8000e44 <handle_2_digit_input+0x138>)
 8000daa:	f000 fc37 	bl	800161c <Display_Putc>
				input = input + key_to_digit(key) ;
 8000dae:	79fb      	ldrb	r3, [r7, #7]
 8000db0:	4618      	mov	r0, r3
 8000db2:	f7ff ff9f 	bl	8000cf4 <key_to_digit>
 8000db6:	4602      	mov	r2, r0
 8000db8:	4b24      	ldr	r3, [pc, #144]	; (8000e4c <handle_2_digit_input+0x140>)
 8000dba:	681b      	ldr	r3, [r3, #0]
 8000dbc:	4413      	add	r3, r2
 8000dbe:	4a23      	ldr	r2, [pc, #140]	; (8000e4c <handle_2_digit_input+0x140>)
 8000dc0:	6013      	str	r3, [r2, #0]
				Display_UpdateScreen(&lcd3);
 8000dc2:	4820      	ldr	r0, [pc, #128]	; (8000e44 <handle_2_digit_input+0x138>)
 8000dc4:	f000 fb61 	bl	800148a <Display_UpdateScreen>
			break ;
 8000dc8:	e032      	b.n	8000e30 <handle_2_digit_input+0x124>
			if( key == '#' )
 8000dca:	79fb      	ldrb	r3, [r7, #7]
 8000dcc:	2b23      	cmp	r3, #35	; 0x23
 8000dce:	d103      	bne.n	8000dd8 <handle_2_digit_input+0xcc>
				ret = input ;
 8000dd0:	4b1e      	ldr	r3, [pc, #120]	; (8000e4c <handle_2_digit_input+0x140>)
 8000dd2:	681b      	ldr	r3, [r3, #0]
 8000dd4:	60fb      	str	r3, [r7, #12]
			break ;
 8000dd6:	e02d      	b.n	8000e34 <handle_2_digit_input+0x128>
			else if(key == '*')
 8000dd8:	79fb      	ldrb	r3, [r7, #7]
 8000dda:	2b2a      	cmp	r3, #42	; 0x2a
 8000ddc:	d103      	bne.n	8000de6 <handle_2_digit_input+0xda>
				ret = -1 ;
 8000dde:	f04f 33ff 	mov.w	r3, #4294967295
 8000de2:	60fb      	str	r3, [r7, #12]
			break ;
 8000de4:	e026      	b.n	8000e34 <handle_2_digit_input+0x128>
			else if( key != 0)
 8000de6:	79fb      	ldrb	r3, [r7, #7]
 8000de8:	2b00      	cmp	r3, #0
 8000dea:	d023      	beq.n	8000e34 <handle_2_digit_input+0x128>
				inp_state = inp_state_two ;
 8000dec:	4b14      	ldr	r3, [pc, #80]	; (8000e40 <handle_2_digit_input+0x134>)
 8000dee:	2201      	movs	r2, #1
 8000df0:	701a      	strb	r2, [r3, #0]
				Display_GotoXY(&lcd3 , 10 , 30 );
 8000df2:	221e      	movs	r2, #30
 8000df4:	210a      	movs	r1, #10
 8000df6:	4813      	ldr	r0, [pc, #76]	; (8000e44 <handle_2_digit_input+0x138>)
 8000df8:	f000 fbfb 	bl	80015f2 <Display_GotoXY>
				Display_Putc(&lcd3 ,key,& Font_7x10 , Display_COLOR_WHITE ) ;
 8000dfc:	79f9      	ldrb	r1, [r7, #7]
 8000dfe:	2301      	movs	r3, #1
 8000e00:	4a11      	ldr	r2, [pc, #68]	; (8000e48 <handle_2_digit_input+0x13c>)
 8000e02:	4810      	ldr	r0, [pc, #64]	; (8000e44 <handle_2_digit_input+0x138>)
 8000e04:	f000 fc0a 	bl	800161c <Display_Putc>
				Display_UpdateScreen(&lcd3);
 8000e08:	480e      	ldr	r0, [pc, #56]	; (8000e44 <handle_2_digit_input+0x138>)
 8000e0a:	f000 fb3e 	bl	800148a <Display_UpdateScreen>
				input = key_to_digit(key) * 10 ;
 8000e0e:	79fb      	ldrb	r3, [r7, #7]
 8000e10:	4618      	mov	r0, r3
 8000e12:	f7ff ff6f 	bl	8000cf4 <key_to_digit>
 8000e16:	4602      	mov	r2, r0
 8000e18:	4613      	mov	r3, r2
 8000e1a:	009b      	lsls	r3, r3, #2
 8000e1c:	4413      	add	r3, r2
 8000e1e:	005b      	lsls	r3, r3, #1
 8000e20:	461a      	mov	r2, r3
 8000e22:	4b0a      	ldr	r3, [pc, #40]	; (8000e4c <handle_2_digit_input+0x140>)
 8000e24:	601a      	str	r2, [r3, #0]
			break ;
 8000e26:	e005      	b.n	8000e34 <handle_2_digit_input+0x128>
			break ;
 8000e28:	bf00      	nop
 8000e2a:	e004      	b.n	8000e36 <handle_2_digit_input+0x12a>
			break ;
 8000e2c:	bf00      	nop
 8000e2e:	e002      	b.n	8000e36 <handle_2_digit_input+0x12a>
			break ;
 8000e30:	bf00      	nop
 8000e32:	e000      	b.n	8000e36 <handle_2_digit_input+0x12a>
			break ;
 8000e34:	bf00      	nop
	}
	return ret ;
 8000e36:	68fb      	ldr	r3, [r7, #12]
}
 8000e38:	4618      	mov	r0, r3
 8000e3a:	3710      	adds	r7, #16
 8000e3c:	46bd      	mov	sp, r7
 8000e3e:	bd80      	pop	{r7, pc}
 8000e40:	20000d50 	.word	0x20000d50
 8000e44:	20000914 	.word	0x20000914
 8000e48:	20000058 	.word	0x20000058
 8000e4c:	20000d54 	.word	0x20000d54

08000e50 <save_config>:
const char * SUB_MENU_TIME[] = {"hour config","minute config","second config"};
const char * SUB_MENU_DATE[] = {"day config","month config","year config"};
const char * SUB_MENU_PARM[] = {"alarm1 config","alarm2 config","buzze config" , "night mode"};
 */
void save_config(const char * param , int val)
{
 8000e50:	b580      	push	{r7, lr}
 8000e52:	b092      	sub	sp, #72	; 0x48
 8000e54:	af00      	add	r7, sp, #0
 8000e56:	6078      	str	r0, [r7, #4]
 8000e58:	6039      	str	r1, [r7, #0]
	if(strncmp( param , "hour config" , strlen(param)) == 0)
 8000e5a:	6878      	ldr	r0, [r7, #4]
 8000e5c:	f7ff f9c0 	bl	80001e0 <strlen>
 8000e60:	4603      	mov	r3, r0
 8000e62:	461a      	mov	r2, r3
 8000e64:	498c      	ldr	r1, [pc, #560]	; (8001098 <save_config+0x248>)
 8000e66:	6878      	ldr	r0, [r7, #4]
 8000e68:	f001 fcdc 	bl	8002824 <strncmp>
 8000e6c:	4603      	mov	r3, r0
 8000e6e:	2b00      	cmp	r3, #0
 8000e70:	d10e      	bne.n	8000e90 <save_config+0x40>
	{
		rtc_time_t my_time ;
		rtc_get_time(&my_time) ;
 8000e72:	f107 0340 	add.w	r3, r7, #64	; 0x40
 8000e76:	4618      	mov	r0, r3
 8000e78:	f001 f9be 	bl	80021f8 <rtc_get_time>
		my_time.hr = val ;
 8000e7c:	683b      	ldr	r3, [r7, #0]
 8000e7e:	b2db      	uxtb	r3, r3
 8000e80:	f887 3042 	strb.w	r3, [r7, #66]	; 0x42
		rtc_set_time(&my_time) ;
 8000e84:	f107 0340 	add.w	r3, r7, #64	; 0x40
 8000e88:	4618      	mov	r0, r3
 8000e8a:	f001 fa31 	bl	80022f0 <rtc_set_time>
 8000e8e:	e085      	b.n	8000f9c <save_config+0x14c>
	}
	else if(strncmp( param , "minute config" , strlen(param)) == 0)
 8000e90:	6878      	ldr	r0, [r7, #4]
 8000e92:	f7ff f9a5 	bl	80001e0 <strlen>
 8000e96:	4603      	mov	r3, r0
 8000e98:	461a      	mov	r2, r3
 8000e9a:	4980      	ldr	r1, [pc, #512]	; (800109c <save_config+0x24c>)
 8000e9c:	6878      	ldr	r0, [r7, #4]
 8000e9e:	f001 fcc1 	bl	8002824 <strncmp>
 8000ea2:	4603      	mov	r3, r0
 8000ea4:	2b00      	cmp	r3, #0
 8000ea6:	d10e      	bne.n	8000ec6 <save_config+0x76>
	{
		rtc_time_t my_time ;
		rtc_get_time(&my_time) ;
 8000ea8:	f107 0338 	add.w	r3, r7, #56	; 0x38
 8000eac:	4618      	mov	r0, r3
 8000eae:	f001 f9a3 	bl	80021f8 <rtc_get_time>
		my_time.min = val ;
 8000eb2:	683b      	ldr	r3, [r7, #0]
 8000eb4:	b2db      	uxtb	r3, r3
 8000eb6:	f887 3039 	strb.w	r3, [r7, #57]	; 0x39
		rtc_set_time(&my_time) ;
 8000eba:	f107 0338 	add.w	r3, r7, #56	; 0x38
 8000ebe:	4618      	mov	r0, r3
 8000ec0:	f001 fa16 	bl	80022f0 <rtc_set_time>
 8000ec4:	e06a      	b.n	8000f9c <save_config+0x14c>
	}
	else if(strncmp( param , "second config" , strlen(param)) == 0)
 8000ec6:	6878      	ldr	r0, [r7, #4]
 8000ec8:	f7ff f98a 	bl	80001e0 <strlen>
 8000ecc:	4603      	mov	r3, r0
 8000ece:	461a      	mov	r2, r3
 8000ed0:	4973      	ldr	r1, [pc, #460]	; (80010a0 <save_config+0x250>)
 8000ed2:	6878      	ldr	r0, [r7, #4]
 8000ed4:	f001 fca6 	bl	8002824 <strncmp>
 8000ed8:	4603      	mov	r3, r0
 8000eda:	2b00      	cmp	r3, #0
 8000edc:	d10e      	bne.n	8000efc <save_config+0xac>
	{
		rtc_time_t my_time ;
		rtc_get_time(&my_time) ;
 8000ede:	f107 0330 	add.w	r3, r7, #48	; 0x30
 8000ee2:	4618      	mov	r0, r3
 8000ee4:	f001 f988 	bl	80021f8 <rtc_get_time>
		my_time.sec = val ;
 8000ee8:	683b      	ldr	r3, [r7, #0]
 8000eea:	b2db      	uxtb	r3, r3
 8000eec:	f887 3030 	strb.w	r3, [r7, #48]	; 0x30
		rtc_set_time(&my_time) ;
 8000ef0:	f107 0330 	add.w	r3, r7, #48	; 0x30
 8000ef4:	4618      	mov	r0, r3
 8000ef6:	f001 f9fb 	bl	80022f0 <rtc_set_time>
 8000efa:	e04f      	b.n	8000f9c <save_config+0x14c>
	}
	else if(strncmp( param , "day config" , strlen(param)) == 0)
 8000efc:	6878      	ldr	r0, [r7, #4]
 8000efe:	f7ff f96f 	bl	80001e0 <strlen>
 8000f02:	4603      	mov	r3, r0
 8000f04:	461a      	mov	r2, r3
 8000f06:	4967      	ldr	r1, [pc, #412]	; (80010a4 <save_config+0x254>)
 8000f08:	6878      	ldr	r0, [r7, #4]
 8000f0a:	f001 fc8b 	bl	8002824 <strncmp>
 8000f0e:	4603      	mov	r3, r0
 8000f10:	2b00      	cmp	r3, #0
 8000f12:	d10e      	bne.n	8000f32 <save_config+0xe2>
	{
		rtc_date_t my_date ;
		rtc_get_date(&my_date) ;
 8000f14:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 8000f18:	4618      	mov	r0, r3
 8000f1a:	f001 fac5 	bl	80024a8 <rtc_get_date>
		my_date.day = val ;
 8000f1e:	683b      	ldr	r3, [r7, #0]
 8000f20:	b2db      	uxtb	r3, r3
 8000f22:	f887 302c 	strb.w	r3, [r7, #44]	; 0x2c
		rtc_set_date(&my_date) ;
 8000f26:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 8000f2a:	4618      	mov	r0, r3
 8000f2c:	f001 fa4e 	bl	80023cc <rtc_set_date>
 8000f30:	e034      	b.n	8000f9c <save_config+0x14c>

	}
	else if(strncmp( param , "month config" , strlen(param)) == 0)
 8000f32:	6878      	ldr	r0, [r7, #4]
 8000f34:	f7ff f954 	bl	80001e0 <strlen>
 8000f38:	4603      	mov	r3, r0
 8000f3a:	461a      	mov	r2, r3
 8000f3c:	495a      	ldr	r1, [pc, #360]	; (80010a8 <save_config+0x258>)
 8000f3e:	6878      	ldr	r0, [r7, #4]
 8000f40:	f001 fc70 	bl	8002824 <strncmp>
 8000f44:	4603      	mov	r3, r0
 8000f46:	2b00      	cmp	r3, #0
 8000f48:	d10e      	bne.n	8000f68 <save_config+0x118>
	{
		rtc_date_t my_date ;
		rtc_get_date(&my_date) ;
 8000f4a:	f107 0328 	add.w	r3, r7, #40	; 0x28
 8000f4e:	4618      	mov	r0, r3
 8000f50:	f001 faaa 	bl	80024a8 <rtc_get_date>
		my_date.month = val ;
 8000f54:	683b      	ldr	r3, [r7, #0]
 8000f56:	b2db      	uxtb	r3, r3
 8000f58:	f887 3029 	strb.w	r3, [r7, #41]	; 0x29
		rtc_set_date(&my_date) ;
 8000f5c:	f107 0328 	add.w	r3, r7, #40	; 0x28
 8000f60:	4618      	mov	r0, r3
 8000f62:	f001 fa33 	bl	80023cc <rtc_set_date>
 8000f66:	e019      	b.n	8000f9c <save_config+0x14c>
	}
	else if(strncmp( param , "year config" , strlen(param)) == 0)
 8000f68:	6878      	ldr	r0, [r7, #4]
 8000f6a:	f7ff f939 	bl	80001e0 <strlen>
 8000f6e:	4603      	mov	r3, r0
 8000f70:	461a      	mov	r2, r3
 8000f72:	494e      	ldr	r1, [pc, #312]	; (80010ac <save_config+0x25c>)
 8000f74:	6878      	ldr	r0, [r7, #4]
 8000f76:	f001 fc55 	bl	8002824 <strncmp>
 8000f7a:	4603      	mov	r3, r0
 8000f7c:	2b00      	cmp	r3, #0
 8000f7e:	d10d      	bne.n	8000f9c <save_config+0x14c>
	{
		rtc_date_t my_date ;
		rtc_get_date(&my_date) ;
 8000f80:	f107 0324 	add.w	r3, r7, #36	; 0x24
 8000f84:	4618      	mov	r0, r3
 8000f86:	f001 fa8f 	bl	80024a8 <rtc_get_date>
		my_date.year = val ;
 8000f8a:	683b      	ldr	r3, [r7, #0]
 8000f8c:	b2db      	uxtb	r3, r3
 8000f8e:	f887 3026 	strb.w	r3, [r7, #38]	; 0x26
		rtc_set_date(&my_date) ;
 8000f92:	f107 0324 	add.w	r3, r7, #36	; 0x24
 8000f96:	4618      	mov	r0, r3
 8000f98:	f001 fa18 	bl	80023cc <rtc_set_date>
	}
	if(strncmp( param , "ALARM hour" , strlen(param)) == 0)
 8000f9c:	6878      	ldr	r0, [r7, #4]
 8000f9e:	f7ff f91f 	bl	80001e0 <strlen>
 8000fa2:	4603      	mov	r3, r0
 8000fa4:	461a      	mov	r2, r3
 8000fa6:	4942      	ldr	r1, [pc, #264]	; (80010b0 <save_config+0x260>)
 8000fa8:	6878      	ldr	r0, [r7, #4]
 8000faa:	f001 fc3b 	bl	8002824 <strncmp>
 8000fae:	4603      	mov	r3, r0
 8000fb0:	2b00      	cmp	r3, #0
 8000fb2:	d10d      	bne.n	8000fd0 <save_config+0x180>
	{
		rtc_time_t my_time ;
		rtc_get_alarm(&my_time) ;
 8000fb4:	f107 031c 	add.w	r3, r7, #28
 8000fb8:	4618      	mov	r0, r3
 8000fba:	f001 fb53 	bl	8002664 <rtc_get_alarm>
		my_time.hr = val ;
 8000fbe:	683b      	ldr	r3, [r7, #0]
 8000fc0:	b2db      	uxtb	r3, r3
 8000fc2:	77bb      	strb	r3, [r7, #30]
		rtc_set_alarm(&my_time) ;
 8000fc4:	f107 031c 	add.w	r3, r7, #28
 8000fc8:	4618      	mov	r0, r3
 8000fca:	f001 fab9 	bl	8002540 <rtc_set_alarm>
	}
	else
	{

	}
}
 8000fce:	e05f      	b.n	8001090 <save_config+0x240>
	else if(strncmp( param , "ALARM min" , strlen(param)) == 0)
 8000fd0:	6878      	ldr	r0, [r7, #4]
 8000fd2:	f7ff f905 	bl	80001e0 <strlen>
 8000fd6:	4603      	mov	r3, r0
 8000fd8:	461a      	mov	r2, r3
 8000fda:	4936      	ldr	r1, [pc, #216]	; (80010b4 <save_config+0x264>)
 8000fdc:	6878      	ldr	r0, [r7, #4]
 8000fde:	f001 fc21 	bl	8002824 <strncmp>
 8000fe2:	4603      	mov	r3, r0
 8000fe4:	2b00      	cmp	r3, #0
 8000fe6:	d10d      	bne.n	8001004 <save_config+0x1b4>
		rtc_get_alarm(&my_time) ;
 8000fe8:	f107 0314 	add.w	r3, r7, #20
 8000fec:	4618      	mov	r0, r3
 8000fee:	f001 fb39 	bl	8002664 <rtc_get_alarm>
		my_time.min = val ;
 8000ff2:	683b      	ldr	r3, [r7, #0]
 8000ff4:	b2db      	uxtb	r3, r3
 8000ff6:	757b      	strb	r3, [r7, #21]
		rtc_set_alarm(&my_time) ;
 8000ff8:	f107 0314 	add.w	r3, r7, #20
 8000ffc:	4618      	mov	r0, r3
 8000ffe:	f001 fa9f 	bl	8002540 <rtc_set_alarm>
}
 8001002:	e045      	b.n	8001090 <save_config+0x240>
	else if(strncmp( param , "ALARM second" , strlen(param)) == 0)
 8001004:	6878      	ldr	r0, [r7, #4]
 8001006:	f7ff f8eb 	bl	80001e0 <strlen>
 800100a:	4603      	mov	r3, r0
 800100c:	461a      	mov	r2, r3
 800100e:	492a      	ldr	r1, [pc, #168]	; (80010b8 <save_config+0x268>)
 8001010:	6878      	ldr	r0, [r7, #4]
 8001012:	f001 fc07 	bl	8002824 <strncmp>
 8001016:	4603      	mov	r3, r0
 8001018:	2b00      	cmp	r3, #0
 800101a:	d10d      	bne.n	8001038 <save_config+0x1e8>
		rtc_get_alarm(&my_time) ;
 800101c:	f107 030c 	add.w	r3, r7, #12
 8001020:	4618      	mov	r0, r3
 8001022:	f001 fb1f 	bl	8002664 <rtc_get_alarm>
		my_time.sec = val ;
 8001026:	683b      	ldr	r3, [r7, #0]
 8001028:	b2db      	uxtb	r3, r3
 800102a:	733b      	strb	r3, [r7, #12]
		rtc_set_alarm(&my_time) ;
 800102c:	f107 030c 	add.w	r3, r7, #12
 8001030:	4618      	mov	r0, r3
 8001032:	f001 fa85 	bl	8002540 <rtc_set_alarm>
}
 8001036:	e02b      	b.n	8001090 <save_config+0x240>
	else if(strncmp( param ,"NM hour" , 7) == 0)
 8001038:	2207      	movs	r2, #7
 800103a:	4920      	ldr	r1, [pc, #128]	; (80010bc <save_config+0x26c>)
 800103c:	6878      	ldr	r0, [r7, #4]
 800103e:	f001 fbf1 	bl	8002824 <strncmp>
 8001042:	4603      	mov	r3, r0
 8001044:	2b00      	cmp	r3, #0
 8001046:	d108      	bne.n	800105a <save_config+0x20a>
		night_mode_timer = val * 60 *60 ;
 8001048:	683b      	ldr	r3, [r7, #0]
 800104a:	f44f 6261 	mov.w	r2, #3600	; 0xe10
 800104e:	fb02 f303 	mul.w	r3, r2, r3
 8001052:	461a      	mov	r2, r3
 8001054:	4b1a      	ldr	r3, [pc, #104]	; (80010c0 <save_config+0x270>)
 8001056:	601a      	str	r2, [r3, #0]
}
 8001058:	e01a      	b.n	8001090 <save_config+0x240>
	else if(strncmp( param ,"NM min" , 6) == 0)
 800105a:	2206      	movs	r2, #6
 800105c:	4919      	ldr	r1, [pc, #100]	; (80010c4 <save_config+0x274>)
 800105e:	6878      	ldr	r0, [r7, #4]
 8001060:	f001 fbe0 	bl	8002824 <strncmp>
 8001064:	4603      	mov	r3, r0
 8001066:	2b00      	cmp	r3, #0
 8001068:	d112      	bne.n	8001090 <save_config+0x240>
		night_mode_timer += val *60 ;
 800106a:	683a      	ldr	r2, [r7, #0]
 800106c:	4613      	mov	r3, r2
 800106e:	011b      	lsls	r3, r3, #4
 8001070:	1a9b      	subs	r3, r3, r2
 8001072:	009b      	lsls	r3, r3, #2
 8001074:	461a      	mov	r2, r3
 8001076:	4b12      	ldr	r3, [pc, #72]	; (80010c0 <save_config+0x270>)
 8001078:	681b      	ldr	r3, [r3, #0]
 800107a:	4413      	add	r3, r2
 800107c:	4a10      	ldr	r2, [pc, #64]	; (80010c0 <save_config+0x270>)
 800107e:	6013      	str	r3, [r2, #0]
		night_mode_timer *= 1000 ;
 8001080:	4b0f      	ldr	r3, [pc, #60]	; (80010c0 <save_config+0x270>)
 8001082:	681b      	ldr	r3, [r3, #0]
 8001084:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 8001088:	fb02 f303 	mul.w	r3, r2, r3
 800108c:	4a0c      	ldr	r2, [pc, #48]	; (80010c0 <save_config+0x270>)
 800108e:	6013      	str	r3, [r2, #0]
}
 8001090:	bf00      	nop
 8001092:	3748      	adds	r7, #72	; 0x48
 8001094:	46bd      	mov	sp, r7
 8001096:	bd80      	pop	{r7, pc}
 8001098:	08003134 	.word	0x08003134
 800109c:	08003140 	.word	0x08003140
 80010a0:	08003150 	.word	0x08003150
 80010a4:	08003160 	.word	0x08003160
 80010a8:	0800316c 	.word	0x0800316c
 80010ac:	0800317c 	.word	0x0800317c
 80010b0:	08003188 	.word	0x08003188
 80010b4:	08003194 	.word	0x08003194
 80010b8:	080031a0 	.word	0x080031a0
 80010bc:	080031b0 	.word	0x080031b0
 80010c0:	20000d2c 	.word	0x20000d2c
 80010c4:	080031b8 	.word	0x080031b8

080010c8 <systick_enable>:
 */
/*
  \brief  Structure type to access the System Timer (SysTick).
 */
void systick_enable()
{    //uint32_t SystemCoreClock_ = 8000000; //8 Mhz
 80010c8:	b580      	push	{r7, lr}
 80010ca:	af00      	add	r7, sp, #0
	SysTick->LOAD  = (SystemCoreClock_/1000) - 1;                  /* set reload register */
 80010cc:	4b0a      	ldr	r3, [pc, #40]	; (80010f8 <systick_enable+0x30>)
 80010ce:	681b      	ldr	r3, [r3, #0]
 80010d0:	4a0a      	ldr	r2, [pc, #40]	; (80010fc <systick_enable+0x34>)
 80010d2:	fba2 2303 	umull	r2, r3, r2, r3
 80010d6:	099b      	lsrs	r3, r3, #6
 80010d8:	4a09      	ldr	r2, [pc, #36]	; (8001100 <systick_enable+0x38>)
 80010da:	3b01      	subs	r3, #1
 80010dc:	6053      	str	r3, [r2, #4]
	NVIC_SetPriority (SysTick_IRQn, (1<<__NVIC_PRIO_BITS) - 1);  /* set Priority for Systick Interrupt */
 80010de:	210f      	movs	r1, #15
 80010e0:	f04f 30ff 	mov.w	r0, #4294967295
 80010e4:	f7ff f8d4 	bl	8000290 <__NVIC_SetPriority>
	SysTick->VAL   = 0;                                          /* Load the SysTick Counter Value */
 80010e8:	4b05      	ldr	r3, [pc, #20]	; (8001100 <systick_enable+0x38>)
 80010ea:	2200      	movs	r2, #0
 80010ec:	609a      	str	r2, [r3, #8]
	SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |  /*!< SysTick CTRL: CLKSOURCE Mask */
 80010ee:	4b04      	ldr	r3, [pc, #16]	; (8001100 <systick_enable+0x38>)
 80010f0:	2207      	movs	r2, #7
 80010f2:	601a      	str	r2, [r3, #0]
					 SysTick_CTRL_TICKINT_Msk   |
					 SysTick_CTRL_ENABLE_Msk;
}
 80010f4:	bf00      	nop
 80010f6:	bd80      	pop	{r7, pc}
 80010f8:	20000000 	.word	0x20000000
 80010fc:	10624dd3 	.word	0x10624dd3
 8001100:	e000e010 	.word	0xe000e010

08001104 <SysTick_Handler>:


void SysTick_Handler()
{
 8001104:	b480      	push	{r7}
 8001106:	af00      	add	r7, sp, #0
  mtick++;
 8001108:	4b04      	ldr	r3, [pc, #16]	; (800111c <SysTick_Handler+0x18>)
 800110a:	681b      	ldr	r3, [r3, #0]
 800110c:	3301      	adds	r3, #1
 800110e:	4a03      	ldr	r2, [pc, #12]	; (800111c <SysTick_Handler+0x18>)
 8001110:	6013      	str	r3, [r2, #0]
}
 8001112:	bf00      	nop
 8001114:	46bd      	mov	sp, r7
 8001116:	bc80      	pop	{r7}
 8001118:	4770      	bx	lr
 800111a:	bf00      	nop
 800111c:	200000f8 	.word	0x200000f8

08001120 <delay_ms>:

void delay_ms(uint32_t ms)
{
 8001120:	b580      	push	{r7, lr}
 8001122:	b084      	sub	sp, #16
 8001124:	af00      	add	r7, sp, #0
 8001126:	6078      	str	r0, [r7, #4]
  uint32_t st = get_mtick();
 8001128:	f000 f810 	bl	800114c <get_mtick>
 800112c:	60f8      	str	r0, [r7, #12]

  while( get_mtick() - st <ms);
 800112e:	bf00      	nop
 8001130:	f000 f80c 	bl	800114c <get_mtick>
 8001134:	4602      	mov	r2, r0
 8001136:	68fb      	ldr	r3, [r7, #12]
 8001138:	1ad3      	subs	r3, r2, r3
 800113a:	687a      	ldr	r2, [r7, #4]
 800113c:	429a      	cmp	r2, r3
 800113e:	d8f7      	bhi.n	8001130 <delay_ms+0x10>
}
 8001140:	bf00      	nop
 8001142:	bf00      	nop
 8001144:	3710      	adds	r7, #16
 8001146:	46bd      	mov	sp, r7
 8001148:	bd80      	pop	{r7, pc}
	...

0800114c <get_mtick>:

uint32_t get_mtick()
{
 800114c:	b480      	push	{r7}
 800114e:	af00      	add	r7, sp, #0
  return mtick;
 8001150:	4b02      	ldr	r3, [pc, #8]	; (800115c <get_mtick+0x10>)
 8001152:	681b      	ldr	r3, [r3, #0]
}
 8001154:	4618      	mov	r0, r3
 8001156:	46bd      	mov	sp, r7
 8001158:	bc80      	pop	{r7}
 800115a:	4770      	bx	lr
 800115c:	200000f8 	.word	0x200000f8

08001160 <Reset_Handler>:

    .section	.text.Reset_Handler
	.weak	Reset_Handler
	.type	Reset_Handler, %function
Reset_Handler:
  ldr   sp, =_estack    /* Atollic update: set stack pointer */
 8001160:	f8df d030 	ldr.w	sp, [pc, #48]	; 8001194 <LoopForever+0x2>

/* Copy the data segment initializers from flash to SRAM */
  movs	r1, #0
 8001164:	2100      	movs	r1, #0
  b	LoopCopyDataInit
 8001166:	e003      	b.n	8001170 <LoopCopyDataInit>

08001168 <CopyDataInit>:

CopyDataInit:
	ldr	r3, =_sidata
 8001168:	4b0b      	ldr	r3, [pc, #44]	; (8001198 <LoopForever+0x6>)
	ldr	r3, [r3, r1]
 800116a:	585b      	ldr	r3, [r3, r1]
	str	r3, [r0, r1]
 800116c:	5043      	str	r3, [r0, r1]
	adds	r1, r1, #4
 800116e:	3104      	adds	r1, #4

08001170 <LoopCopyDataInit>:

LoopCopyDataInit:

	ldr	r0, =_sdata
 8001170:	480a      	ldr	r0, [pc, #40]	; (800119c <LoopForever+0xa>)
	ldr	r3, =_edata
 8001172:	4b0b      	ldr	r3, [pc, #44]	; (80011a0 <LoopForever+0xe>)
	adds	r2, r0, r1
 8001174:	1842      	adds	r2, r0, r1
	cmp	r2, r3
 8001176:	429a      	cmp	r2, r3
	bcc	CopyDataInit
 8001178:	d3f6      	bcc.n	8001168 <CopyDataInit>
	ldr	r2, =_sbss
 800117a:	4a0a      	ldr	r2, [pc, #40]	; (80011a4 <LoopForever+0x12>)
	b	LoopFillZerobss
 800117c:	e002      	b.n	8001184 <LoopFillZerobss>

0800117e <FillZerobss>:
/* Zero fill the bss segment. */
FillZerobss:
	movs	r3, #0
 800117e:	2300      	movs	r3, #0
	str	r3, [r2], #4
 8001180:	f842 3b04 	str.w	r3, [r2], #4

08001184 <LoopFillZerobss>:

LoopFillZerobss:
	ldr	r3, = _ebss
 8001184:	4b08      	ldr	r3, [pc, #32]	; (80011a8 <LoopForever+0x16>)
	cmp	r2, r3
 8001186:	429a      	cmp	r2, r3
	bcc	FillZerobss
 8001188:	d3f9      	bcc.n	800117e <FillZerobss>

/* Call the clock system intitialization function.*/
    //bl  SystemInit
/* Call static constructors */
    bl __libc_init_array
 800118a:	f001 faff 	bl	800278c <__libc_init_array>
/* Call the application's entry point.*/
	bl	main
 800118e:	f7ff f8c1 	bl	8000314 <main>

08001192 <LoopForever>:

LoopForever:
    b LoopForever
 8001192:	e7fe      	b.n	8001192 <LoopForever>
  ldr   sp, =_estack    /* Atollic update: set stack pointer */
 8001194:	20010000 	.word	0x20010000
	ldr	r3, =_sidata
 8001198:	08004af4 	.word	0x08004af4
	ldr	r0, =_sdata
 800119c:	20000000 	.word	0x20000000
	ldr	r3, =_edata
 80011a0:	200000dc 	.word	0x200000dc
	ldr	r2, =_sbss
 80011a4:	200000dc 	.word	0x200000dc
	ldr	r3, = _ebss
 80011a8:	20000d84 	.word	0x20000d84

080011ac <ADC1_2_IRQHandler>:
 * @retval : None
*/
    .section	.text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
	b	Infinite_Loop
 80011ac:	e7fe      	b.n	80011ac <ADC1_2_IRQHandler>

080011ae <Display_DrawBitmap>:
 * The function uses a nested loop to iterate through the image data and draw each pixel on the OLED display using the Display_DrawPixel function.
 * The function also calculates the byte width of the image and uses bit shifting to extract the appropriate pixel data from the bitmap image data.
 */

void Display_DrawBitmap(OLED_t *oled ,uint16_t x, uint16_t y, const unsigned char *bitmap, uint16_t w, uint16_t h, Display_COLOR_t color)
{
 80011ae:	b580      	push	{r7, lr}
 80011b0:	b086      	sub	sp, #24
 80011b2:	af00      	add	r7, sp, #0
 80011b4:	60f8      	str	r0, [r7, #12]
 80011b6:	607b      	str	r3, [r7, #4]
 80011b8:	460b      	mov	r3, r1
 80011ba:	817b      	strh	r3, [r7, #10]
 80011bc:	4613      	mov	r3, r2
 80011be:	813b      	strh	r3, [r7, #8]

    int16_t byteWidth = (w + 7) / 8; // Bitmap scanline pad = whole byte
 80011c0:	8c3b      	ldrh	r3, [r7, #32]
 80011c2:	3307      	adds	r3, #7
 80011c4:	2b00      	cmp	r3, #0
 80011c6:	da00      	bge.n	80011ca <Display_DrawBitmap+0x1c>
 80011c8:	3307      	adds	r3, #7
 80011ca:	10db      	asrs	r3, r3, #3
 80011cc:	823b      	strh	r3, [r7, #16]
    uint8_t byte = 0;
 80011ce:	2300      	movs	r3, #0
 80011d0:	75fb      	strb	r3, [r7, #23]

    for(int16_t j=0; j<h; j++, y++)
 80011d2:	2300      	movs	r3, #0
 80011d4:	82bb      	strh	r3, [r7, #20]
 80011d6:	e040      	b.n	800125a <Display_DrawBitmap+0xac>
    {
        for(int16_t i=0; i<w; i++)
 80011d8:	2300      	movs	r3, #0
 80011da:	827b      	strh	r3, [r7, #18]
 80011dc:	e02f      	b.n	800123e <Display_DrawBitmap+0x90>
        {
            if(i & 7)
 80011de:	8a7b      	ldrh	r3, [r7, #18]
 80011e0:	f003 0307 	and.w	r3, r3, #7
 80011e4:	2b00      	cmp	r3, #0
 80011e6:	d003      	beq.n	80011f0 <Display_DrawBitmap+0x42>
            {
               byte <<= 1;
 80011e8:	7dfb      	ldrb	r3, [r7, #23]
 80011ea:	005b      	lsls	r3, r3, #1
 80011ec:	75fb      	strb	r3, [r7, #23]
 80011ee:	e012      	b.n	8001216 <Display_DrawBitmap+0x68>
            }
            else
            {
               byte = (*(const unsigned char *)(&bitmap[j * byteWidth + i / 8]));
 80011f0:	f9b7 3014 	ldrsh.w	r3, [r7, #20]
 80011f4:	f9b7 2010 	ldrsh.w	r2, [r7, #16]
 80011f8:	fb03 f202 	mul.w	r2, r3, r2
 80011fc:	f9b7 3012 	ldrsh.w	r3, [r7, #18]
 8001200:	2b00      	cmp	r3, #0
 8001202:	da00      	bge.n	8001206 <Display_DrawBitmap+0x58>
 8001204:	3307      	adds	r3, #7
 8001206:	10db      	asrs	r3, r3, #3
 8001208:	b21b      	sxth	r3, r3
 800120a:	4413      	add	r3, r2
 800120c:	461a      	mov	r2, r3
 800120e:	687b      	ldr	r3, [r7, #4]
 8001210:	4413      	add	r3, r2
 8001212:	781b      	ldrb	r3, [r3, #0]
 8001214:	75fb      	strb	r3, [r7, #23]
            }
            if(byte & 0x80)
 8001216:	f997 3017 	ldrsb.w	r3, [r7, #23]
 800121a:	2b00      	cmp	r3, #0
 800121c:	da09      	bge.n	8001232 <Display_DrawBitmap+0x84>
            	Display_DrawPixel(oled ,x+i, y, color);
 800121e:	8a7a      	ldrh	r2, [r7, #18]
 8001220:	897b      	ldrh	r3, [r7, #10]
 8001222:	4413      	add	r3, r2
 8001224:	b299      	uxth	r1, r3
 8001226:	f897 3028 	ldrb.w	r3, [r7, #40]	; 0x28
 800122a:	893a      	ldrh	r2, [r7, #8]
 800122c:	68f8      	ldr	r0, [r7, #12]
 800122e:	f000 f97b 	bl	8001528 <Display_DrawPixel>
        for(int16_t i=0; i<w; i++)
 8001232:	f9b7 3012 	ldrsh.w	r3, [r7, #18]
 8001236:	b29b      	uxth	r3, r3
 8001238:	3301      	adds	r3, #1
 800123a:	b29b      	uxth	r3, r3
 800123c:	827b      	strh	r3, [r7, #18]
 800123e:	f9b7 2012 	ldrsh.w	r2, [r7, #18]
 8001242:	8c3b      	ldrh	r3, [r7, #32]
 8001244:	429a      	cmp	r2, r3
 8001246:	dbca      	blt.n	80011de <Display_DrawBitmap+0x30>
    for(int16_t j=0; j<h; j++, y++)
 8001248:	f9b7 3014 	ldrsh.w	r3, [r7, #20]
 800124c:	b29b      	uxth	r3, r3
 800124e:	3301      	adds	r3, #1
 8001250:	b29b      	uxth	r3, r3
 8001252:	82bb      	strh	r3, [r7, #20]
 8001254:	893b      	ldrh	r3, [r7, #8]
 8001256:	3301      	adds	r3, #1
 8001258:	813b      	strh	r3, [r7, #8]
 800125a:	f9b7 2014 	ldrsh.w	r2, [r7, #20]
 800125e:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
 8001260:	429a      	cmp	r2, r3
 8001262:	dbb9      	blt.n	80011d8 <Display_DrawBitmap+0x2a>
        }
    }
}
 8001264:	bf00      	nop
 8001266:	bf00      	nop
 8001268:	3718      	adds	r7, #24
 800126a:	46bd      	mov	sp, r7
 800126c:	bd80      	pop	{r7, pc}

0800126e <Display_Init>:
 * The function also deactivates scrolling on the OLED and fills the screen with black color.
 * At the end, the function returns 1 to indicate that the initialization was successful.
 */


uint8_t Display_Init(OLED_t * oled) {
 800126e:	b580      	push	{r7, lr}
 8001270:	b086      	sub	sp, #24
 8001272:	af02      	add	r7, sp, #8
 8001274:	6078      	str	r0, [r7, #4]

	//delay
	uint32_t p = 2500;
 8001276:	f640 13c4 	movw	r3, #2500	; 0x9c4
 800127a:	60fb      	str	r3, [r7, #12]
	while(p>0)
 800127c:	e002      	b.n	8001284 <Display_Init+0x16>
		p--;
 800127e:	68fb      	ldr	r3, [r7, #12]
 8001280:	3b01      	subs	r3, #1
 8001282:	60fb      	str	r3, [r7, #12]
	while(p>0)
 8001284:	68fb      	ldr	r3, [r7, #12]
 8001286:	2b00      	cmp	r3, #0
 8001288:	d1f9      	bne.n	800127e <Display_Init+0x10>

	Display_WriteCommand(oled , 0xAE); //display off
 800128a:	2302      	movs	r3, #2
 800128c:	9300      	str	r3, [sp, #0]
 800128e:	23ae      	movs	r3, #174	; 0xae
 8001290:	2200      	movs	r2, #0
 8001292:	213c      	movs	r1, #60	; 0x3c
 8001294:	6878      	ldr	r0, [r7, #4]
 8001296:	f000 fb09 	bl	80018ac <Display_I2C_Write>
	Display_WriteCommand(oled , 0x20); //Set Memory Addressing Mode
 800129a:	2302      	movs	r3, #2
 800129c:	9300      	str	r3, [sp, #0]
 800129e:	2320      	movs	r3, #32
 80012a0:	2200      	movs	r2, #0
 80012a2:	213c      	movs	r1, #60	; 0x3c
 80012a4:	6878      	ldr	r0, [r7, #4]
 80012a6:	f000 fb01 	bl	80018ac <Display_I2C_Write>
	Display_WriteCommand(oled , 0x10); //00,Horizontal Addressing Mode;01,Vertical Addressing Mode;10,Page Addressing Mode (RESET);11,Invalid
 80012aa:	2302      	movs	r3, #2
 80012ac:	9300      	str	r3, [sp, #0]
 80012ae:	2310      	movs	r3, #16
 80012b0:	2200      	movs	r2, #0
 80012b2:	213c      	movs	r1, #60	; 0x3c
 80012b4:	6878      	ldr	r0, [r7, #4]
 80012b6:	f000 faf9 	bl	80018ac <Display_I2C_Write>
	Display_WriteCommand(oled , 0xB0); //Set Page Start Address for Page Addressing Mode,0-7
 80012ba:	2302      	movs	r3, #2
 80012bc:	9300      	str	r3, [sp, #0]
 80012be:	23b0      	movs	r3, #176	; 0xb0
 80012c0:	2200      	movs	r2, #0
 80012c2:	213c      	movs	r1, #60	; 0x3c
 80012c4:	6878      	ldr	r0, [r7, #4]
 80012c6:	f000 faf1 	bl	80018ac <Display_I2C_Write>
	Display_WriteCommand(oled , 0xC8); //Set COM Output Scan Direction
 80012ca:	2302      	movs	r3, #2
 80012cc:	9300      	str	r3, [sp, #0]
 80012ce:	23c8      	movs	r3, #200	; 0xc8
 80012d0:	2200      	movs	r2, #0
 80012d2:	213c      	movs	r1, #60	; 0x3c
 80012d4:	6878      	ldr	r0, [r7, #4]
 80012d6:	f000 fae9 	bl	80018ac <Display_I2C_Write>
	Display_WriteCommand(oled , 0x00); //---set low column address
 80012da:	2302      	movs	r3, #2
 80012dc:	9300      	str	r3, [sp, #0]
 80012de:	2300      	movs	r3, #0
 80012e0:	2200      	movs	r2, #0
 80012e2:	213c      	movs	r1, #60	; 0x3c
 80012e4:	6878      	ldr	r0, [r7, #4]
 80012e6:	f000 fae1 	bl	80018ac <Display_I2C_Write>
	Display_WriteCommand(oled , 0x10); //---set high column address
 80012ea:	2302      	movs	r3, #2
 80012ec:	9300      	str	r3, [sp, #0]
 80012ee:	2310      	movs	r3, #16
 80012f0:	2200      	movs	r2, #0
 80012f2:	213c      	movs	r1, #60	; 0x3c
 80012f4:	6878      	ldr	r0, [r7, #4]
 80012f6:	f000 fad9 	bl	80018ac <Display_I2C_Write>
	Display_WriteCommand(oled , 0x40); //--set start line address
 80012fa:	2302      	movs	r3, #2
 80012fc:	9300      	str	r3, [sp, #0]
 80012fe:	2340      	movs	r3, #64	; 0x40
 8001300:	2200      	movs	r2, #0
 8001302:	213c      	movs	r1, #60	; 0x3c
 8001304:	6878      	ldr	r0, [r7, #4]
 8001306:	f000 fad1 	bl	80018ac <Display_I2C_Write>
	Display_WriteCommand(oled , 0x81); //--set contrast control register
 800130a:	2302      	movs	r3, #2
 800130c:	9300      	str	r3, [sp, #0]
 800130e:	2381      	movs	r3, #129	; 0x81
 8001310:	2200      	movs	r2, #0
 8001312:	213c      	movs	r1, #60	; 0x3c
 8001314:	6878      	ldr	r0, [r7, #4]
 8001316:	f000 fac9 	bl	80018ac <Display_I2C_Write>
	Display_WriteCommand(oled , 0xFF);
 800131a:	2302      	movs	r3, #2
 800131c:	9300      	str	r3, [sp, #0]
 800131e:	23ff      	movs	r3, #255	; 0xff
 8001320:	2200      	movs	r2, #0
 8001322:	213c      	movs	r1, #60	; 0x3c
 8001324:	6878      	ldr	r0, [r7, #4]
 8001326:	f000 fac1 	bl	80018ac <Display_I2C_Write>
	Display_WriteCommand(oled , 0xA1); //--set segment re-map 0 to 127
 800132a:	2302      	movs	r3, #2
 800132c:	9300      	str	r3, [sp, #0]
 800132e:	23a1      	movs	r3, #161	; 0xa1
 8001330:	2200      	movs	r2, #0
 8001332:	213c      	movs	r1, #60	; 0x3c
 8001334:	6878      	ldr	r0, [r7, #4]
 8001336:	f000 fab9 	bl	80018ac <Display_I2C_Write>
	Display_WriteCommand(oled , 0xA6); //--set normal display
 800133a:	2302      	movs	r3, #2
 800133c:	9300      	str	r3, [sp, #0]
 800133e:	23a6      	movs	r3, #166	; 0xa6
 8001340:	2200      	movs	r2, #0
 8001342:	213c      	movs	r1, #60	; 0x3c
 8001344:	6878      	ldr	r0, [r7, #4]
 8001346:	f000 fab1 	bl	80018ac <Display_I2C_Write>
	Display_WriteCommand(oled , 0xA8); //--set multiplex ratio(1 to 64)
 800134a:	2302      	movs	r3, #2
 800134c:	9300      	str	r3, [sp, #0]
 800134e:	23a8      	movs	r3, #168	; 0xa8
 8001350:	2200      	movs	r2, #0
 8001352:	213c      	movs	r1, #60	; 0x3c
 8001354:	6878      	ldr	r0, [r7, #4]
 8001356:	f000 faa9 	bl	80018ac <Display_I2C_Write>
	Display_WriteCommand(oled , 0x3F); //
 800135a:	2302      	movs	r3, #2
 800135c:	9300      	str	r3, [sp, #0]
 800135e:	233f      	movs	r3, #63	; 0x3f
 8001360:	2200      	movs	r2, #0
 8001362:	213c      	movs	r1, #60	; 0x3c
 8001364:	6878      	ldr	r0, [r7, #4]
 8001366:	f000 faa1 	bl	80018ac <Display_I2C_Write>
	Display_WriteCommand(oled , 0xA4); //0xa4,Output follows RAM content;0xa5,Output ignores RAM content
 800136a:	2302      	movs	r3, #2
 800136c:	9300      	str	r3, [sp, #0]
 800136e:	23a4      	movs	r3, #164	; 0xa4
 8001370:	2200      	movs	r2, #0
 8001372:	213c      	movs	r1, #60	; 0x3c
 8001374:	6878      	ldr	r0, [r7, #4]
 8001376:	f000 fa99 	bl	80018ac <Display_I2C_Write>
	Display_WriteCommand(oled , 0xD3); //-set display offset
 800137a:	2302      	movs	r3, #2
 800137c:	9300      	str	r3, [sp, #0]
 800137e:	23d3      	movs	r3, #211	; 0xd3
 8001380:	2200      	movs	r2, #0
 8001382:	213c      	movs	r1, #60	; 0x3c
 8001384:	6878      	ldr	r0, [r7, #4]
 8001386:	f000 fa91 	bl	80018ac <Display_I2C_Write>
	Display_WriteCommand(oled , 0x00); //-not offset
 800138a:	2302      	movs	r3, #2
 800138c:	9300      	str	r3, [sp, #0]
 800138e:	2300      	movs	r3, #0
 8001390:	2200      	movs	r2, #0
 8001392:	213c      	movs	r1, #60	; 0x3c
 8001394:	6878      	ldr	r0, [r7, #4]
 8001396:	f000 fa89 	bl	80018ac <Display_I2C_Write>
	Display_WriteCommand(oled , 0xD5); //--set display clock divide ratio/oscillator frequency
 800139a:	2302      	movs	r3, #2
 800139c:	9300      	str	r3, [sp, #0]
 800139e:	23d5      	movs	r3, #213	; 0xd5
 80013a0:	2200      	movs	r2, #0
 80013a2:	213c      	movs	r1, #60	; 0x3c
 80013a4:	6878      	ldr	r0, [r7, #4]
 80013a6:	f000 fa81 	bl	80018ac <Display_I2C_Write>
	Display_WriteCommand(oled , 0xF0); //--set divide ratio
 80013aa:	2302      	movs	r3, #2
 80013ac:	9300      	str	r3, [sp, #0]
 80013ae:	23f0      	movs	r3, #240	; 0xf0
 80013b0:	2200      	movs	r2, #0
 80013b2:	213c      	movs	r1, #60	; 0x3c
 80013b4:	6878      	ldr	r0, [r7, #4]
 80013b6:	f000 fa79 	bl	80018ac <Display_I2C_Write>
	Display_WriteCommand(oled , 0xD9); //--set pre-charge period
 80013ba:	2302      	movs	r3, #2
 80013bc:	9300      	str	r3, [sp, #0]
 80013be:	23d9      	movs	r3, #217	; 0xd9
 80013c0:	2200      	movs	r2, #0
 80013c2:	213c      	movs	r1, #60	; 0x3c
 80013c4:	6878      	ldr	r0, [r7, #4]
 80013c6:	f000 fa71 	bl	80018ac <Display_I2C_Write>
	Display_WriteCommand(oled , 0x22); //
 80013ca:	2302      	movs	r3, #2
 80013cc:	9300      	str	r3, [sp, #0]
 80013ce:	2322      	movs	r3, #34	; 0x22
 80013d0:	2200      	movs	r2, #0
 80013d2:	213c      	movs	r1, #60	; 0x3c
 80013d4:	6878      	ldr	r0, [r7, #4]
 80013d6:	f000 fa69 	bl	80018ac <Display_I2C_Write>
	Display_WriteCommand(oled , 0xDA); //--set Com pins hardware configuration
 80013da:	2302      	movs	r3, #2
 80013dc:	9300      	str	r3, [sp, #0]
 80013de:	23da      	movs	r3, #218	; 0xda
 80013e0:	2200      	movs	r2, #0
 80013e2:	213c      	movs	r1, #60	; 0x3c
 80013e4:	6878      	ldr	r0, [r7, #4]
 80013e6:	f000 fa61 	bl	80018ac <Display_I2C_Write>
	Display_WriteCommand(oled , 0x12);
 80013ea:	2302      	movs	r3, #2
 80013ec:	9300      	str	r3, [sp, #0]
 80013ee:	2312      	movs	r3, #18
 80013f0:	2200      	movs	r2, #0
 80013f2:	213c      	movs	r1, #60	; 0x3c
 80013f4:	6878      	ldr	r0, [r7, #4]
 80013f6:	f000 fa59 	bl	80018ac <Display_I2C_Write>
	Display_WriteCommand(oled , 0xDB); //--set vcomh
 80013fa:	2302      	movs	r3, #2
 80013fc:	9300      	str	r3, [sp, #0]
 80013fe:	23db      	movs	r3, #219	; 0xdb
 8001400:	2200      	movs	r2, #0
 8001402:	213c      	movs	r1, #60	; 0x3c
 8001404:	6878      	ldr	r0, [r7, #4]
 8001406:	f000 fa51 	bl	80018ac <Display_I2C_Write>
	Display_WriteCommand(oled , 0x20); //0x20,0.77xVcc
 800140a:	2302      	movs	r3, #2
 800140c:	9300      	str	r3, [sp, #0]
 800140e:	2320      	movs	r3, #32
 8001410:	2200      	movs	r2, #0
 8001412:	213c      	movs	r1, #60	; 0x3c
 8001414:	6878      	ldr	r0, [r7, #4]
 8001416:	f000 fa49 	bl	80018ac <Display_I2C_Write>
	Display_WriteCommand(oled , 0x8D); //--set DC-DC enable
 800141a:	2302      	movs	r3, #2
 800141c:	9300      	str	r3, [sp, #0]
 800141e:	238d      	movs	r3, #141	; 0x8d
 8001420:	2200      	movs	r2, #0
 8001422:	213c      	movs	r1, #60	; 0x3c
 8001424:	6878      	ldr	r0, [r7, #4]
 8001426:	f000 fa41 	bl	80018ac <Display_I2C_Write>
	Display_WriteCommand(oled , 0x14); //
 800142a:	2302      	movs	r3, #2
 800142c:	9300      	str	r3, [sp, #0]
 800142e:	2314      	movs	r3, #20
 8001430:	2200      	movs	r2, #0
 8001432:	213c      	movs	r1, #60	; 0x3c
 8001434:	6878      	ldr	r0, [r7, #4]
 8001436:	f000 fa39 	bl	80018ac <Display_I2C_Write>
	Display_WriteCommand(oled , 0xAF); //--turn on SSD1306 panel
 800143a:	2302      	movs	r3, #2
 800143c:	9300      	str	r3, [sp, #0]
 800143e:	23af      	movs	r3, #175	; 0xaf
 8001440:	2200      	movs	r2, #0
 8001442:	213c      	movs	r1, #60	; 0x3c
 8001444:	6878      	ldr	r0, [r7, #4]
 8001446:	f000 fa31 	bl	80018ac <Display_I2C_Write>


	Display_WriteCommand(oled ,Display_DEACTIVATE_SCROLL);
 800144a:	2302      	movs	r3, #2
 800144c:	9300      	str	r3, [sp, #0]
 800144e:	232e      	movs	r3, #46	; 0x2e
 8001450:	2200      	movs	r2, #0
 8001452:	213c      	movs	r1, #60	; 0x3c
 8001454:	6878      	ldr	r0, [r7, #4]
 8001456:	f000 fa29 	bl	80018ac <Display_I2C_Write>
	//Display_Fill(Display_COLOR_WHITE);	// Clear screen
	Display_Fill(oled ,Display_COLOR_BLACK);	// Clear screen
 800145a:	2100      	movs	r1, #0
 800145c:	6878      	ldr	r0, [r7, #4]
 800145e:	f000 f84c 	bl	80014fa <Display_Fill>
	Display_UpdateScreen(oled);		// Update screen
 8001462:	6878      	ldr	r0, [r7, #4]
 8001464:	f000 f811 	bl	800148a <Display_UpdateScreen>

	// Set default values
	oled->CurrentX = 0;
 8001468:	687b      	ldr	r3, [r7, #4]
 800146a:	2200      	movs	r2, #0
 800146c:	f8a3 2404 	strh.w	r2, [r3, #1028]	; 0x404
	oled->CurrentY = 0;
 8001470:	687b      	ldr	r3, [r7, #4]
 8001472:	2200      	movs	r2, #0
 8001474:	f8a3 2406 	strh.w	r2, [r3, #1030]	; 0x406

	// Initialized OK
	oled->Initialized = 1;
 8001478:	687b      	ldr	r3, [r7, #4]
 800147a:	2201      	movs	r2, #1
 800147c:	f883 2409 	strb.w	r2, [r3, #1033]	; 0x409

	// Return OK
	return 1;
 8001480:	2301      	movs	r3, #1
}
 8001482:	4618      	mov	r0, r3
 8001484:	3710      	adds	r7, #16
 8001486:	46bd      	mov	sp, r7
 8001488:	bd80      	pop	{r7, pc}

0800148a <Display_UpdateScreen>:
 * This function updates the screen of the OLED display by writing the contents of the buffer "oled->Display_Buffer" to the screen.
 * It does this by iterating through each of the 8 pages (m) on the OLED display and setting the page address to the current page (0xB0 + m).
 * It then sets the column address to the start of the page (0x00 and 0x10) and writes the contents
 * of the corresponding section of the buffer (Display_WIDTH * m) to the screen using the Display_I2C_WriteMulti function.
 */
void Display_UpdateScreen(OLED_t * oled) {
 800148a:	b580      	push	{r7, lr}
 800148c:	b086      	sub	sp, #24
 800148e:	af02      	add	r7, sp, #8
 8001490:	6078      	str	r0, [r7, #4]
	uint8_t m;

	for (m = 0; m < 8; m++) {
 8001492:	2300      	movs	r3, #0
 8001494:	73fb      	strb	r3, [r7, #15]
 8001496:	e028      	b.n	80014ea <Display_UpdateScreen+0x60>
		Display_WriteCommand(oled , 0xB0 + m);
 8001498:	7bfb      	ldrb	r3, [r7, #15]
 800149a:	3b50      	subs	r3, #80	; 0x50
 800149c:	b2db      	uxtb	r3, r3
 800149e:	2202      	movs	r2, #2
 80014a0:	9200      	str	r2, [sp, #0]
 80014a2:	2200      	movs	r2, #0
 80014a4:	213c      	movs	r1, #60	; 0x3c
 80014a6:	6878      	ldr	r0, [r7, #4]
 80014a8:	f000 fa00 	bl	80018ac <Display_I2C_Write>
		Display_WriteCommand(oled , 0x00);
 80014ac:	2302      	movs	r3, #2
 80014ae:	9300      	str	r3, [sp, #0]
 80014b0:	2300      	movs	r3, #0
 80014b2:	2200      	movs	r2, #0
 80014b4:	213c      	movs	r1, #60	; 0x3c
 80014b6:	6878      	ldr	r0, [r7, #4]
 80014b8:	f000 f9f8 	bl	80018ac <Display_I2C_Write>
		Display_WriteCommand(oled , 0x10);
 80014bc:	2302      	movs	r3, #2
 80014be:	9300      	str	r3, [sp, #0]
 80014c0:	2310      	movs	r3, #16
 80014c2:	2200      	movs	r2, #0
 80014c4:	213c      	movs	r1, #60	; 0x3c
 80014c6:	6878      	ldr	r0, [r7, #4]
 80014c8:	f000 f9f0 	bl	80018ac <Display_I2C_Write>

		Display_I2C_WriteMulti(oled , 0x3C, 0x40, &(oled->Display_Buffer[Display_WIDTH * m]), Display_WIDTH);
 80014cc:	7bfb      	ldrb	r3, [r7, #15]
 80014ce:	01db      	lsls	r3, r3, #7
 80014d0:	687a      	ldr	r2, [r7, #4]
 80014d2:	4413      	add	r3, r2
 80014d4:	3304      	adds	r3, #4
 80014d6:	2280      	movs	r2, #128	; 0x80
 80014d8:	9200      	str	r2, [sp, #0]
 80014da:	2240      	movs	r2, #64	; 0x40
 80014dc:	213c      	movs	r1, #60	; 0x3c
 80014de:	6878      	ldr	r0, [r7, #4]
 80014e0:	f000 f957 	bl	8001792 <Display_I2C_WriteMulti>
	for (m = 0; m < 8; m++) {
 80014e4:	7bfb      	ldrb	r3, [r7, #15]
 80014e6:	3301      	adds	r3, #1
 80014e8:	73fb      	strb	r3, [r7, #15]
 80014ea:	7bfb      	ldrb	r3, [r7, #15]
 80014ec:	2b07      	cmp	r3, #7
 80014ee:	d9d3      	bls.n	8001498 <Display_UpdateScreen+0xe>

	}
}
 80014f0:	bf00      	nop
 80014f2:	bf00      	nop
 80014f4:	3710      	adds	r7, #16
 80014f6:	46bd      	mov	sp, r7
 80014f8:	bd80      	pop	{r7, pc}

080014fa <Display_Fill>:
 * The function takes in two arguments: a pointer to an OLED structure (oled) and the color to fill the display with (color).
 * The memset function is then used to fill the buffer with either 0x00 (black) or 0xFF (white) depending on the color passed in as an argument.
 * The number of bytes to be filled is equal to the size of the buffer, which is defined by sizeof(oled->Display_Buffer).
 * This function is used to clear the screen and set all pixels to the specified color.
 */
void Display_Fill(OLED_t * oled , Display_COLOR_t color) {
 80014fa:	b580      	push	{r7, lr}
 80014fc:	b082      	sub	sp, #8
 80014fe:	af00      	add	r7, sp, #0
 8001500:	6078      	str	r0, [r7, #4]
 8001502:	460b      	mov	r3, r1
 8001504:	70fb      	strb	r3, [r7, #3]
	// Set memory, fill a block of memory with value
	memset(oled->Display_Buffer, (color == Display_COLOR_BLACK) ? 0x00 : 0xFF, sizeof(oled->Display_Buffer));
 8001506:	687b      	ldr	r3, [r7, #4]
 8001508:	1d18      	adds	r0, r3, #4
 800150a:	78fb      	ldrb	r3, [r7, #3]
 800150c:	2b00      	cmp	r3, #0
 800150e:	d101      	bne.n	8001514 <Display_Fill+0x1a>
 8001510:	2300      	movs	r3, #0
 8001512:	e000      	b.n	8001516 <Display_Fill+0x1c>
 8001514:	23ff      	movs	r3, #255	; 0xff
 8001516:	f44f 6280 	mov.w	r2, #1024	; 0x400
 800151a:	4619      	mov	r1, r3
 800151c:	f001 f95a 	bl	80027d4 <memset>
  //memset(starting address, value to be filled, number of bytes to be filled)
}
 8001520:	bf00      	nop
 8001522:	3708      	adds	r7, #8
 8001524:	46bd      	mov	sp, r7
 8001526:	bd80      	pop	{r7, pc}

08001528 <Display_DrawPixel>:
 * If they are not, the function exits. Next, it checks if the display is set to be inverted and, if it is, it inverts the color of the pixel.
 * Finally, it sets the color of the pixel in the Display_Buffer using bit manipulation. If the color is white, it sets the corresponding bit in the buffer to 1.
 * If the color is black, it sets the corresponding bit to 0.
 * This allows the display to render the pixel on the screen.
 */
void Display_DrawPixel(OLED_t * oled ,uint16_t x, uint16_t y, Display_COLOR_t color) {
 8001528:	b480      	push	{r7}
 800152a:	b085      	sub	sp, #20
 800152c:	af00      	add	r7, sp, #0
 800152e:	60f8      	str	r0, [r7, #12]
 8001530:	4608      	mov	r0, r1
 8001532:	4611      	mov	r1, r2
 8001534:	461a      	mov	r2, r3
 8001536:	4603      	mov	r3, r0
 8001538:	817b      	strh	r3, [r7, #10]
 800153a:	460b      	mov	r3, r1
 800153c:	813b      	strh	r3, [r7, #8]
 800153e:	4613      	mov	r3, r2
 8001540:	71fb      	strb	r3, [r7, #7]

	if (x >= Display_WIDTH || y >= Display_HEIGHT)
 8001542:	897b      	ldrh	r3, [r7, #10]
 8001544:	2b7f      	cmp	r3, #127	; 0x7f
 8001546:	d84f      	bhi.n	80015e8 <Display_DrawPixel+0xc0>
 8001548:	893b      	ldrh	r3, [r7, #8]
 800154a:	2b3f      	cmp	r3, #63	; 0x3f
 800154c:	d84c      	bhi.n	80015e8 <Display_DrawPixel+0xc0>
		// Error
		return;
	}

	// Check if pixels are inverted
	if (oled->Inverted) {
 800154e:	68fb      	ldr	r3, [r7, #12]
 8001550:	f893 3408 	ldrb.w	r3, [r3, #1032]	; 0x408
 8001554:	2b00      	cmp	r3, #0
 8001556:	d006      	beq.n	8001566 <Display_DrawPixel+0x3e>
		color = (Display_COLOR_t)!color;
 8001558:	79fb      	ldrb	r3, [r7, #7]
 800155a:	2b00      	cmp	r3, #0
 800155c:	bf0c      	ite	eq
 800155e:	2301      	moveq	r3, #1
 8001560:	2300      	movne	r3, #0
 8001562:	b2db      	uxtb	r3, r3
 8001564:	71fb      	strb	r3, [r7, #7]
	}

	// Set color
	if (color == Display_COLOR_WHITE) {
 8001566:	79fb      	ldrb	r3, [r7, #7]
 8001568:	2b01      	cmp	r3, #1
 800156a:	d11d      	bne.n	80015a8 <Display_DrawPixel+0x80>
		oled->Display_Buffer[x + (y / 8) * Display_WIDTH] |= 1 << (y % 8);
 800156c:	897a      	ldrh	r2, [r7, #10]
 800156e:	893b      	ldrh	r3, [r7, #8]
 8001570:	08db      	lsrs	r3, r3, #3
 8001572:	b298      	uxth	r0, r3
 8001574:	4603      	mov	r3, r0
 8001576:	01db      	lsls	r3, r3, #7
 8001578:	4413      	add	r3, r2
 800157a:	68fa      	ldr	r2, [r7, #12]
 800157c:	4413      	add	r3, r2
 800157e:	791b      	ldrb	r3, [r3, #4]
 8001580:	b25a      	sxtb	r2, r3
 8001582:	893b      	ldrh	r3, [r7, #8]
 8001584:	f003 0307 	and.w	r3, r3, #7
 8001588:	2101      	movs	r1, #1
 800158a:	fa01 f303 	lsl.w	r3, r1, r3
 800158e:	b25b      	sxtb	r3, r3
 8001590:	4313      	orrs	r3, r2
 8001592:	b259      	sxtb	r1, r3
 8001594:	897a      	ldrh	r2, [r7, #10]
 8001596:	4603      	mov	r3, r0
 8001598:	01db      	lsls	r3, r3, #7
 800159a:	4413      	add	r3, r2
 800159c:	b2c9      	uxtb	r1, r1
 800159e:	68fa      	ldr	r2, [r7, #12]
 80015a0:	4413      	add	r3, r2
 80015a2:	460a      	mov	r2, r1
 80015a4:	711a      	strb	r2, [r3, #4]
 80015a6:	e020      	b.n	80015ea <Display_DrawPixel+0xc2>
	} else {
		oled->Display_Buffer[x + (y / 8) * Display_WIDTH] &= ~(1 << (y % 8));
 80015a8:	897a      	ldrh	r2, [r7, #10]
 80015aa:	893b      	ldrh	r3, [r7, #8]
 80015ac:	08db      	lsrs	r3, r3, #3
 80015ae:	b298      	uxth	r0, r3
 80015b0:	4603      	mov	r3, r0
 80015b2:	01db      	lsls	r3, r3, #7
 80015b4:	4413      	add	r3, r2
 80015b6:	68fa      	ldr	r2, [r7, #12]
 80015b8:	4413      	add	r3, r2
 80015ba:	791b      	ldrb	r3, [r3, #4]
 80015bc:	b25a      	sxtb	r2, r3
 80015be:	893b      	ldrh	r3, [r7, #8]
 80015c0:	f003 0307 	and.w	r3, r3, #7
 80015c4:	2101      	movs	r1, #1
 80015c6:	fa01 f303 	lsl.w	r3, r1, r3
 80015ca:	b25b      	sxtb	r3, r3
 80015cc:	43db      	mvns	r3, r3
 80015ce:	b25b      	sxtb	r3, r3
 80015d0:	4013      	ands	r3, r2
 80015d2:	b259      	sxtb	r1, r3
 80015d4:	897a      	ldrh	r2, [r7, #10]
 80015d6:	4603      	mov	r3, r0
 80015d8:	01db      	lsls	r3, r3, #7
 80015da:	4413      	add	r3, r2
 80015dc:	b2c9      	uxtb	r1, r1
 80015de:	68fa      	ldr	r2, [r7, #12]
 80015e0:	4413      	add	r3, r2
 80015e2:	460a      	mov	r2, r1
 80015e4:	711a      	strb	r2, [r3, #4]
 80015e6:	e000      	b.n	80015ea <Display_DrawPixel+0xc2>
		return;
 80015e8:	bf00      	nop
	}
}
 80015ea:	3714      	adds	r7, #20
 80015ec:	46bd      	mov	sp, r7
 80015ee:	bc80      	pop	{r7}
 80015f0:	4770      	bx	lr

080015f2 <Display_GotoXY>:
 * This function sets the current write position on the OLED display to the specified x and y coordinates.
 * The OLED_t struct pointer "oled" is passed in as a parameter, and the struct contains the current x and y position as members "CurrentX" and "CurrentY", respectively.
 * The function updates these members with the new x and y coordinates passed in as parameters.
 * This allows for easy control over the position for subsequent writes or drawing operations.
 */
void Display_GotoXY(OLED_t * oled ,uint16_t x, uint16_t y) {
 80015f2:	b480      	push	{r7}
 80015f4:	b083      	sub	sp, #12
 80015f6:	af00      	add	r7, sp, #0
 80015f8:	6078      	str	r0, [r7, #4]
 80015fa:	460b      	mov	r3, r1
 80015fc:	807b      	strh	r3, [r7, #2]
 80015fe:	4613      	mov	r3, r2
 8001600:	803b      	strh	r3, [r7, #0]
	// Set write pointers
	oled->CurrentX = x;
 8001602:	687b      	ldr	r3, [r7, #4]
 8001604:	887a      	ldrh	r2, [r7, #2]
 8001606:	f8a3 2404 	strh.w	r2, [r3, #1028]	; 0x404
	oled->CurrentY = y;
 800160a:	687b      	ldr	r3, [r7, #4]
 800160c:	883a      	ldrh	r2, [r7, #0]
 800160e:	f8a3 2406 	strh.w	r2, [r3, #1030]	; 0x406
}
 8001612:	bf00      	nop
 8001614:	370c      	adds	r7, #12
 8001616:	46bd      	mov	sp, r7
 8001618:	bc80      	pop	{r7}
 800161a:	4770      	bx	lr

0800161c <Display_Putc>:
 * It checks if there is enough space on the OLED display to write the character in the current position,
 * and if there is, it uses the font definition to determine which pixels should be turned on or off to write the character.
 * It then increments the current X position on the OLED structure so that the next character can be written in the correct position.
 * The function returns the character that was written.
 */
char Display_Putc(OLED_t * oled ,char ch, FontDef_t *Font, Display_COLOR_t color) {
 800161c:	b580      	push	{r7, lr}
 800161e:	b088      	sub	sp, #32
 8001620:	af00      	add	r7, sp, #0
 8001622:	60f8      	str	r0, [r7, #12]
 8001624:	607a      	str	r2, [r7, #4]
 8001626:	461a      	mov	r2, r3
 8001628:	460b      	mov	r3, r1
 800162a:	72fb      	strb	r3, [r7, #11]
 800162c:	4613      	mov	r3, r2
 800162e:	72bb      	strb	r3, [r7, #10]
	uint32_t i, b, j;

	// Check available space in LCD
	if (
		Display_WIDTH <= (oled->CurrentX + Font->FontWidth) ||
 8001630:	68fb      	ldr	r3, [r7, #12]
 8001632:	f8b3 3404 	ldrh.w	r3, [r3, #1028]	; 0x404
 8001636:	461a      	mov	r2, r3
 8001638:	687b      	ldr	r3, [r7, #4]
 800163a:	781b      	ldrb	r3, [r3, #0]
 800163c:	4413      	add	r3, r2
	if (
 800163e:	2b7f      	cmp	r3, #127	; 0x7f
 8001640:	dc08      	bgt.n	8001654 <Display_Putc+0x38>
		Display_HEIGHT <= (oled->CurrentY + Font->FontHeight)
 8001642:	68fb      	ldr	r3, [r7, #12]
 8001644:	f8b3 3406 	ldrh.w	r3, [r3, #1030]	; 0x406
 8001648:	461a      	mov	r2, r3
 800164a:	687b      	ldr	r3, [r7, #4]
 800164c:	785b      	ldrb	r3, [r3, #1]
 800164e:	4413      	add	r3, r2
		Display_WIDTH <= (oled->CurrentX + Font->FontWidth) ||
 8001650:	2b3f      	cmp	r3, #63	; 0x3f
 8001652:	dd01      	ble.n	8001658 <Display_Putc+0x3c>
	) {
		// Error
		return 0;
 8001654:	2300      	movs	r3, #0
 8001656:	e064      	b.n	8001722 <Display_Putc+0x106>
	}

	// Go through font
	for (i = 0; i < Font->FontHeight; i++) {
 8001658:	2300      	movs	r3, #0
 800165a:	61fb      	str	r3, [r7, #28]
 800165c:	e04f      	b.n	80016fe <Display_Putc+0xe2>
		b = Font->data[(ch - 32) * Font->FontHeight + i];
 800165e:	687b      	ldr	r3, [r7, #4]
 8001660:	685a      	ldr	r2, [r3, #4]
 8001662:	7afb      	ldrb	r3, [r7, #11]
 8001664:	3b20      	subs	r3, #32
 8001666:	6879      	ldr	r1, [r7, #4]
 8001668:	7849      	ldrb	r1, [r1, #1]
 800166a:	fb01 f303 	mul.w	r3, r1, r3
 800166e:	4619      	mov	r1, r3
 8001670:	69fb      	ldr	r3, [r7, #28]
 8001672:	440b      	add	r3, r1
 8001674:	005b      	lsls	r3, r3, #1
 8001676:	4413      	add	r3, r2
 8001678:	881b      	ldrh	r3, [r3, #0]
 800167a:	617b      	str	r3, [r7, #20]
		for (j = 0; j < Font->FontWidth; j++) {
 800167c:	2300      	movs	r3, #0
 800167e:	61bb      	str	r3, [r7, #24]
 8001680:	e034      	b.n	80016ec <Display_Putc+0xd0>
			if ((b << j) & 0x8000) {
 8001682:	697a      	ldr	r2, [r7, #20]
 8001684:	69bb      	ldr	r3, [r7, #24]
 8001686:	fa02 f303 	lsl.w	r3, r2, r3
 800168a:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
 800168e:	2b00      	cmp	r3, #0
 8001690:	d012      	beq.n	80016b8 <Display_Putc+0x9c>
				Display_DrawPixel(oled ,oled->CurrentX + j, (oled->CurrentY + i), (Display_COLOR_t) color);
 8001692:	68fb      	ldr	r3, [r7, #12]
 8001694:	f8b3 2404 	ldrh.w	r2, [r3, #1028]	; 0x404
 8001698:	69bb      	ldr	r3, [r7, #24]
 800169a:	b29b      	uxth	r3, r3
 800169c:	4413      	add	r3, r2
 800169e:	b299      	uxth	r1, r3
 80016a0:	68fb      	ldr	r3, [r7, #12]
 80016a2:	f8b3 2406 	ldrh.w	r2, [r3, #1030]	; 0x406
 80016a6:	69fb      	ldr	r3, [r7, #28]
 80016a8:	b29b      	uxth	r3, r3
 80016aa:	4413      	add	r3, r2
 80016ac:	b29a      	uxth	r2, r3
 80016ae:	7abb      	ldrb	r3, [r7, #10]
 80016b0:	68f8      	ldr	r0, [r7, #12]
 80016b2:	f7ff ff39 	bl	8001528 <Display_DrawPixel>
 80016b6:	e016      	b.n	80016e6 <Display_Putc+0xca>
			} else {
				Display_DrawPixel(oled ,oled->CurrentX + j, (oled->CurrentY + i), (Display_COLOR_t)!color);
 80016b8:	68fb      	ldr	r3, [r7, #12]
 80016ba:	f8b3 2404 	ldrh.w	r2, [r3, #1028]	; 0x404
 80016be:	69bb      	ldr	r3, [r7, #24]
 80016c0:	b29b      	uxth	r3, r3
 80016c2:	4413      	add	r3, r2
 80016c4:	b299      	uxth	r1, r3
 80016c6:	68fb      	ldr	r3, [r7, #12]
 80016c8:	f8b3 2406 	ldrh.w	r2, [r3, #1030]	; 0x406
 80016cc:	69fb      	ldr	r3, [r7, #28]
 80016ce:	b29b      	uxth	r3, r3
 80016d0:	4413      	add	r3, r2
 80016d2:	b29a      	uxth	r2, r3
 80016d4:	7abb      	ldrb	r3, [r7, #10]
 80016d6:	2b00      	cmp	r3, #0
 80016d8:	bf0c      	ite	eq
 80016da:	2301      	moveq	r3, #1
 80016dc:	2300      	movne	r3, #0
 80016de:	b2db      	uxtb	r3, r3
 80016e0:	68f8      	ldr	r0, [r7, #12]
 80016e2:	f7ff ff21 	bl	8001528 <Display_DrawPixel>
		for (j = 0; j < Font->FontWidth; j++) {
 80016e6:	69bb      	ldr	r3, [r7, #24]
 80016e8:	3301      	adds	r3, #1
 80016ea:	61bb      	str	r3, [r7, #24]
 80016ec:	687b      	ldr	r3, [r7, #4]
 80016ee:	781b      	ldrb	r3, [r3, #0]
 80016f0:	461a      	mov	r2, r3
 80016f2:	69bb      	ldr	r3, [r7, #24]
 80016f4:	4293      	cmp	r3, r2
 80016f6:	d3c4      	bcc.n	8001682 <Display_Putc+0x66>
	for (i = 0; i < Font->FontHeight; i++) {
 80016f8:	69fb      	ldr	r3, [r7, #28]
 80016fa:	3301      	adds	r3, #1
 80016fc:	61fb      	str	r3, [r7, #28]
 80016fe:	687b      	ldr	r3, [r7, #4]
 8001700:	785b      	ldrb	r3, [r3, #1]
 8001702:	461a      	mov	r2, r3
 8001704:	69fb      	ldr	r3, [r7, #28]
 8001706:	4293      	cmp	r3, r2
 8001708:	d3a9      	bcc.n	800165e <Display_Putc+0x42>
			}
		}
	}

	// Increase pointer
	oled->CurrentX += Font->FontWidth;
 800170a:	68fb      	ldr	r3, [r7, #12]
 800170c:	f8b3 2404 	ldrh.w	r2, [r3, #1028]	; 0x404
 8001710:	687b      	ldr	r3, [r7, #4]
 8001712:	781b      	ldrb	r3, [r3, #0]
 8001714:	b29b      	uxth	r3, r3
 8001716:	4413      	add	r3, r2
 8001718:	b29a      	uxth	r2, r3
 800171a:	68fb      	ldr	r3, [r7, #12]
 800171c:	f8a3 2404 	strh.w	r2, [r3, #1028]	; 0x404

	// Return character written
	return ch;
 8001720:	7afb      	ldrb	r3, [r7, #11]
}
 8001722:	4618      	mov	r0, r3
 8001724:	3720      	adds	r7, #32
 8001726:	46bd      	mov	sp, r7
 8001728:	bd80      	pop	{r7, pc}

0800172a <Display_Puts>:
 * The function starts by setting a pointer to the first character of the string and then loops through each character of the string. For each character,
 * the function calls the Display_Putc function to write the character to the OLED display and then increments the pointer to the next character in the string.
 * If there is an error while writing a character, the function returns that character.
 * If all the characters in the string are successfully written to the OLED display, the function returns the last character of the string (which should be a null character).
 */
char Display_Puts(OLED_t * oled ,char* str, FontDef_t* Font, Display_COLOR_t color) {
 800172a:	b580      	push	{r7, lr}
 800172c:	b084      	sub	sp, #16
 800172e:	af00      	add	r7, sp, #0
 8001730:	60f8      	str	r0, [r7, #12]
 8001732:	60b9      	str	r1, [r7, #8]
 8001734:	607a      	str	r2, [r7, #4]
 8001736:	70fb      	strb	r3, [r7, #3]
	// Write characters
	while (*str) {
 8001738:	e012      	b.n	8001760 <Display_Puts+0x36>
		// Write character by character
		if (Display_Putc(oled ,*str, Font, color) != *str) {
 800173a:	68bb      	ldr	r3, [r7, #8]
 800173c:	7819      	ldrb	r1, [r3, #0]
 800173e:	78fb      	ldrb	r3, [r7, #3]
 8001740:	687a      	ldr	r2, [r7, #4]
 8001742:	68f8      	ldr	r0, [r7, #12]
 8001744:	f7ff ff6a 	bl	800161c <Display_Putc>
 8001748:	4603      	mov	r3, r0
 800174a:	461a      	mov	r2, r3
 800174c:	68bb      	ldr	r3, [r7, #8]
 800174e:	781b      	ldrb	r3, [r3, #0]
 8001750:	429a      	cmp	r2, r3
 8001752:	d002      	beq.n	800175a <Display_Puts+0x30>
			// Return error
			return *str;
 8001754:	68bb      	ldr	r3, [r7, #8]
 8001756:	781b      	ldrb	r3, [r3, #0]
 8001758:	e008      	b.n	800176c <Display_Puts+0x42>
		}

		// Increase string pointer
		str++;
 800175a:	68bb      	ldr	r3, [r7, #8]
 800175c:	3301      	adds	r3, #1
 800175e:	60bb      	str	r3, [r7, #8]
	while (*str) {
 8001760:	68bb      	ldr	r3, [r7, #8]
 8001762:	781b      	ldrb	r3, [r3, #0]
 8001764:	2b00      	cmp	r3, #0
 8001766:	d1e8      	bne.n	800173a <Display_Puts+0x10>
	}

	// Everything OK, zero should be returned
	return *str;
 8001768:	68bb      	ldr	r3, [r7, #8]
 800176a:	781b      	ldrb	r3, [r3, #0]
}
 800176c:	4618      	mov	r0, r3
 800176e:	3710      	adds	r7, #16
 8001770:	46bd      	mov	sp, r7
 8001772:	bd80      	pop	{r7, pc}

08001774 <Display_Clear>:
 * Then it calls Display_UpdateScreen() to update the OLED screen with the new display buffer.
 * This effectively clears the entire OLED screen and sets it to a blank black display.
 */

void Display_Clear (OLED_t * oled )
{
 8001774:	b580      	push	{r7, lr}
 8001776:	b082      	sub	sp, #8
 8001778:	af00      	add	r7, sp, #0
 800177a:	6078      	str	r0, [r7, #4]
	Display_Fill (oled , 0);
 800177c:	2100      	movs	r1, #0
 800177e:	6878      	ldr	r0, [r7, #4]
 8001780:	f7ff febb 	bl	80014fa <Display_Fill>
	Display_UpdateScreen(oled);
 8001784:	6878      	ldr	r0, [r7, #4]
 8001786:	f7ff fe80 	bl	800148a <Display_UpdateScreen>
}
 800178a:	bf00      	nop
 800178c:	3708      	adds	r7, #8
 800178e:	46bd      	mov	sp, r7
 8001790:	bd80      	pop	{r7, pc}

08001792 <Display_I2C_WriteMulti>:
 * The data is sent one byte at a time, and the function waits for the TXIS flag to be set before sending the next byte. Once all the data has been sent, the function ends.
 */


void Display_I2C_WriteMulti(OLED_t * oled,uint8_t address, uint8_t dataRegister, uint8_t *data , uint16_t numBytes)	//data is a pointer
{
 8001792:	e92d 03b0 	stmdb	sp!, {r4, r5, r7, r8, r9}
 8001796:	b089      	sub	sp, #36	; 0x24
 8001798:	af00      	add	r7, sp, #0
 800179a:	60f8      	str	r0, [r7, #12]
 800179c:	607b      	str	r3, [r7, #4]
 800179e:	460b      	mov	r3, r1
 80017a0:	72fb      	strb	r3, [r7, #11]
 80017a2:	4613      	mov	r3, r2
 80017a4:	72bb      	strb	r3, [r7, #10]
 80017a6:	466b      	mov	r3, sp
 80017a8:	4618      	mov	r0, r3
	uint8_t i;
	uint8_t j;
	uint8_t dt[numBytes];		//necessary for multi Write
 80017aa:	8f39      	ldrh	r1, [r7, #56]	; 0x38
 80017ac:	460b      	mov	r3, r1
 80017ae:	3b01      	subs	r3, #1
 80017b0:	61bb      	str	r3, [r7, #24]
 80017b2:	b28b      	uxth	r3, r1
 80017b4:	2200      	movs	r2, #0
 80017b6:	4698      	mov	r8, r3
 80017b8:	4691      	mov	r9, r2
 80017ba:	f04f 0200 	mov.w	r2, #0
 80017be:	f04f 0300 	mov.w	r3, #0
 80017c2:	ea4f 03c9 	mov.w	r3, r9, lsl #3
 80017c6:	ea43 7358 	orr.w	r3, r3, r8, lsr #29
 80017ca:	ea4f 02c8 	mov.w	r2, r8, lsl #3
 80017ce:	b28b      	uxth	r3, r1
 80017d0:	2200      	movs	r2, #0
 80017d2:	461c      	mov	r4, r3
 80017d4:	4615      	mov	r5, r2
 80017d6:	f04f 0200 	mov.w	r2, #0
 80017da:	f04f 0300 	mov.w	r3, #0
 80017de:	00eb      	lsls	r3, r5, #3
 80017e0:	ea43 7354 	orr.w	r3, r3, r4, lsr #29
 80017e4:	00e2      	lsls	r2, r4, #3
 80017e6:	460b      	mov	r3, r1
 80017e8:	3307      	adds	r3, #7
 80017ea:	08db      	lsrs	r3, r3, #3
 80017ec:	00db      	lsls	r3, r3, #3
 80017ee:	ebad 0d03 	sub.w	sp, sp, r3
 80017f2:	466b      	mov	r3, sp
 80017f4:	3300      	adds	r3, #0
 80017f6:	617b      	str	r3, [r7, #20]
	I2C_TypeDef *  i2c = oled->dev;
 80017f8:	68fb      	ldr	r3, [r7, #12]
 80017fa:	681b      	ldr	r3, [r3, #0]
 80017fc:	613b      	str	r3, [r7, #16]
	i2c->CR2 = ((address << 1) << I2C_CR2_SADD_Pos) | (numBytes << I2C_CR2_NBYTES_Pos) | (0 << I2C_CR2_RD_WRN_Pos | I2C_CR2_AUTOEND);	//send address + data of register + WRITE
 80017fe:	7afb      	ldrb	r3, [r7, #11]
 8001800:	005a      	lsls	r2, r3, #1
 8001802:	8f3b      	ldrh	r3, [r7, #56]	; 0x38
 8001804:	041b      	lsls	r3, r3, #16
 8001806:	4313      	orrs	r3, r2
 8001808:	f043 7200 	orr.w	r2, r3, #33554432	; 0x2000000
 800180c:	693b      	ldr	r3, [r7, #16]
 800180e:	605a      	str	r2, [r3, #4]
	i2c->CR2 |= I2C_CR2_START;
 8001810:	693b      	ldr	r3, [r7, #16]
 8001812:	685b      	ldr	r3, [r3, #4]
 8001814:	f443 5200 	orr.w	r2, r3, #8192	; 0x2000
 8001818:	693b      	ldr	r3, [r7, #16]
 800181a:	605a      	str	r2, [r3, #4]
	while ((i2c->ISR & I2C_ISR_TXIS)==0) {	//TXDR is empty
 800181c:	e007      	b.n	800182e <Display_I2C_WriteMulti+0x9c>
		if ((i2c->ISR & I2C_ISR_NACKF)){
 800181e:	693b      	ldr	r3, [r7, #16]
 8001820:	699b      	ldr	r3, [r3, #24]
 8001822:	f003 0310 	and.w	r3, r3, #16
 8001826:	2b00      	cmp	r3, #0
 8001828:	d001      	beq.n	800182e <Display_I2C_WriteMulti+0x9c>
 800182a:	4685      	mov	sp, r0
 800182c:	e039      	b.n	80018a2 <Display_I2C_WriteMulti+0x110>
	while ((i2c->ISR & I2C_ISR_TXIS)==0) {	//TXDR is empty
 800182e:	693b      	ldr	r3, [r7, #16]
 8001830:	699b      	ldr	r3, [r3, #24]
 8001832:	f003 0302 	and.w	r3, r3, #2
 8001836:	2b00      	cmp	r3, #0
 8001838:	d0f1      	beq.n	800181e <Display_I2C_WriteMulti+0x8c>
			return;}}

	dt[0] = dataRegister;
 800183a:	697b      	ldr	r3, [r7, #20]
 800183c:	7aba      	ldrb	r2, [r7, #10]
 800183e:	701a      	strb	r2, [r3, #0]
	for(i=0; i<numBytes; i++)
 8001840:	2300      	movs	r3, #0
 8001842:	77bb      	strb	r3, [r7, #30]
 8001844:	e00a      	b.n	800185c <Display_I2C_WriteMulti+0xca>
	{
	dt[i+1] = data[i];	//necessary for multi Write
 8001846:	7fbb      	ldrb	r3, [r7, #30]
 8001848:	687a      	ldr	r2, [r7, #4]
 800184a:	441a      	add	r2, r3
 800184c:	7fbb      	ldrb	r3, [r7, #30]
 800184e:	3301      	adds	r3, #1
 8001850:	7811      	ldrb	r1, [r2, #0]
 8001852:	697a      	ldr	r2, [r7, #20]
 8001854:	54d1      	strb	r1, [r2, r3]
	for(i=0; i<numBytes; i++)
 8001856:	7fbb      	ldrb	r3, [r7, #30]
 8001858:	3301      	adds	r3, #1
 800185a:	77bb      	strb	r3, [r7, #30]
 800185c:	7fbb      	ldrb	r3, [r7, #30]
 800185e:	b29b      	uxth	r3, r3
 8001860:	8f3a      	ldrh	r2, [r7, #56]	; 0x38
 8001862:	429a      	cmp	r2, r3
 8001864:	d8ef      	bhi.n	8001846 <Display_I2C_WriteMulti+0xb4>
	}

	for(j=0; j <= (numBytes-1); j++)
 8001866:	2300      	movs	r3, #0
 8001868:	77fb      	strb	r3, [r7, #31]
 800186a:	e014      	b.n	8001896 <Display_I2C_WriteMulti+0x104>
	{
		i2c->TXDR = dt[j];
 800186c:	7ffb      	ldrb	r3, [r7, #31]
 800186e:	697a      	ldr	r2, [r7, #20]
 8001870:	5cd3      	ldrb	r3, [r2, r3]
 8001872:	461a      	mov	r2, r3
 8001874:	693b      	ldr	r3, [r7, #16]
 8001876:	629a      	str	r2, [r3, #40]	; 0x28
		if(j < (numBytes-1))
 8001878:	7ffa      	ldrb	r2, [r7, #31]
 800187a:	8f3b      	ldrh	r3, [r7, #56]	; 0x38
 800187c:	3b01      	subs	r3, #1
 800187e:	429a      	cmp	r2, r3
 8001880:	da06      	bge.n	8001890 <Display_I2C_WriteMulti+0xfe>
		{
			while((i2c->ISR & I2C_ISR_TXIS)==0){}		//ggf TXIS mit TXE ergnzen
 8001882:	bf00      	nop
 8001884:	693b      	ldr	r3, [r7, #16]
 8001886:	699b      	ldr	r3, [r3, #24]
 8001888:	f003 0302 	and.w	r3, r3, #2
 800188c:	2b00      	cmp	r3, #0
 800188e:	d0f9      	beq.n	8001884 <Display_I2C_WriteMulti+0xf2>
	for(j=0; j <= (numBytes-1); j++)
 8001890:	7ffb      	ldrb	r3, [r7, #31]
 8001892:	3301      	adds	r3, #1
 8001894:	77fb      	strb	r3, [r7, #31]
 8001896:	7ffb      	ldrb	r3, [r7, #31]
 8001898:	b29b      	uxth	r3, r3
 800189a:	8f3a      	ldrh	r2, [r7, #56]	; 0x38
 800189c:	429a      	cmp	r2, r3
 800189e:	d8e5      	bhi.n	800186c <Display_I2C_WriteMulti+0xda>
 80018a0:	4685      	mov	sp, r0
		}
	}

}
 80018a2:	3724      	adds	r7, #36	; 0x24
 80018a4:	46bd      	mov	sp, r7
 80018a6:	e8bd 03b0 	ldmia.w	sp!, {r4, r5, r7, r8, r9}
 80018aa:	4770      	bx	lr

080018ac <Display_I2C_Write>:
 * The number of bytes to be written (in this case, 2 bytes, one for the register and one for the data) is also passed as an argument.
 * The function starts the I2C communication and waits for the transmit buffer to be empty before sending the register and data.
 * It then waits for the transmit buffer to be empty again before sending the data. The function will exit and return if a NACK is received during the transmission.
 */
void Display_I2C_Write(OLED_t * oled, uint8_t address, uint8_t dataRegister, uint8_t data , uint8_t numBytes)
{
 80018ac:	b480      	push	{r7}
 80018ae:	b087      	sub	sp, #28
 80018b0:	af00      	add	r7, sp, #0
 80018b2:	6078      	str	r0, [r7, #4]
 80018b4:	4608      	mov	r0, r1
 80018b6:	4611      	mov	r1, r2
 80018b8:	461a      	mov	r2, r3
 80018ba:	4603      	mov	r3, r0
 80018bc:	70fb      	strb	r3, [r7, #3]
 80018be:	460b      	mov	r3, r1
 80018c0:	70bb      	strb	r3, [r7, #2]
 80018c2:	4613      	mov	r3, r2
 80018c4:	707b      	strb	r3, [r7, #1]


	uint8_t j;
	uint8_t dt[2];
	I2C_TypeDef *  i2c = oled->dev;
 80018c6:	687b      	ldr	r3, [r7, #4]
 80018c8:	681b      	ldr	r3, [r3, #0]
 80018ca:	613b      	str	r3, [r7, #16]
	dt[0] = dataRegister;
 80018cc:	78bb      	ldrb	r3, [r7, #2]
 80018ce:	733b      	strb	r3, [r7, #12]
	dt[1] = data;
 80018d0:	787b      	ldrb	r3, [r7, #1]
 80018d2:	737b      	strb	r3, [r7, #13]

	i2c->CR2 = ((address << 1) << I2C_CR2_SADD_Pos) | (numBytes << I2C_CR2_NBYTES_Pos) | (0 << I2C_CR2_RD_WRN_Pos | I2C_CR2_AUTOEND);	//send address + data of register + WRITE
 80018d4:	78fb      	ldrb	r3, [r7, #3]
 80018d6:	005a      	lsls	r2, r3, #1
 80018d8:	f897 3020 	ldrb.w	r3, [r7, #32]
 80018dc:	041b      	lsls	r3, r3, #16
 80018de:	4313      	orrs	r3, r2
 80018e0:	f043 7200 	orr.w	r2, r3, #33554432	; 0x2000000
 80018e4:	693b      	ldr	r3, [r7, #16]
 80018e6:	605a      	str	r2, [r3, #4]
	i2c->CR2 |= I2C_CR2_START;
 80018e8:	693b      	ldr	r3, [r7, #16]
 80018ea:	685b      	ldr	r3, [r3, #4]
 80018ec:	f443 5200 	orr.w	r2, r3, #8192	; 0x2000
 80018f0:	693b      	ldr	r3, [r7, #16]
 80018f2:	605a      	str	r2, [r3, #4]
	while ((i2c->ISR & I2C_ISR_TXIS)==0) {	//TXDR is empty
 80018f4:	e005      	b.n	8001902 <Display_I2C_Write+0x56>
		if ((i2c->ISR & I2C_ISR_NACKF)){
 80018f6:	693b      	ldr	r3, [r7, #16]
 80018f8:	699b      	ldr	r3, [r3, #24]
 80018fa:	f003 0310 	and.w	r3, r3, #16
 80018fe:	2b00      	cmp	r3, #0
 8001900:	d126      	bne.n	8001950 <Display_I2C_Write+0xa4>
	while ((i2c->ISR & I2C_ISR_TXIS)==0) {	//TXDR is empty
 8001902:	693b      	ldr	r3, [r7, #16]
 8001904:	699b      	ldr	r3, [r3, #24]
 8001906:	f003 0302 	and.w	r3, r3, #2
 800190a:	2b00      	cmp	r3, #0
 800190c:	d0f3      	beq.n	80018f6 <Display_I2C_Write+0x4a>
			return;}}

	for(j=0; j <= (numBytes-1); j++)
 800190e:	2300      	movs	r3, #0
 8001910:	75fb      	strb	r3, [r7, #23]
 8001912:	e017      	b.n	8001944 <Display_I2C_Write+0x98>
	{
		i2c->TXDR = dt[j];
 8001914:	7dfb      	ldrb	r3, [r7, #23]
 8001916:	3318      	adds	r3, #24
 8001918:	443b      	add	r3, r7
 800191a:	f813 3c0c 	ldrb.w	r3, [r3, #-12]
 800191e:	461a      	mov	r2, r3
 8001920:	693b      	ldr	r3, [r7, #16]
 8001922:	629a      	str	r2, [r3, #40]	; 0x28
		if(j < (numBytes-1))
 8001924:	7dfa      	ldrb	r2, [r7, #23]
 8001926:	f897 3020 	ldrb.w	r3, [r7, #32]
 800192a:	3b01      	subs	r3, #1
 800192c:	429a      	cmp	r2, r3
 800192e:	da06      	bge.n	800193e <Display_I2C_Write+0x92>
		{
			while((i2c->ISR & I2C_ISR_TXIS)==0){}
 8001930:	bf00      	nop
 8001932:	693b      	ldr	r3, [r7, #16]
 8001934:	699b      	ldr	r3, [r3, #24]
 8001936:	f003 0302 	and.w	r3, r3, #2
 800193a:	2b00      	cmp	r3, #0
 800193c:	d0f9      	beq.n	8001932 <Display_I2C_Write+0x86>
	for(j=0; j <= (numBytes-1); j++)
 800193e:	7dfb      	ldrb	r3, [r7, #23]
 8001940:	3301      	adds	r3, #1
 8001942:	75fb      	strb	r3, [r7, #23]
 8001944:	f897 2020 	ldrb.w	r2, [r7, #32]
 8001948:	7dfb      	ldrb	r3, [r7, #23]
 800194a:	429a      	cmp	r2, r3
 800194c:	d8e2      	bhi.n	8001914 <Display_I2C_Write+0x68>
 800194e:	e000      	b.n	8001952 <Display_I2C_Write+0xa6>
			return;}}
 8001950:	bf00      	nop
		}
	}

}
 8001952:	371c      	adds	r7, #28
 8001954:	46bd      	mov	sp, r7
 8001956:	bc80      	pop	{r7}
 8001958:	4770      	bx	lr
	...

0800195c <gpio_clock_enable>:
 * After each device reset, all peripheral clocks are disabled (except for the SRAM and FLITF).
Before using a peripheral user has to enable its clock in the RCC_AHBENR,
RCC_APB2ENR or RCC_APB1ENR register.  s.50
 */
void gpio_clock_enable(GPIO_TypeDef * Port)
{
 800195c:	b480      	push	{r7}
 800195e:	b083      	sub	sp, #12
 8001960:	af00      	add	r7, sp, #0
 8001962:	6078      	str	r0, [r7, #4]
	if(Port == GPIOA)        //  Bit 17 IOPAEN: I/O port A clock enable
 8001964:	687b      	ldr	r3, [r7, #4]
 8001966:	f1b3 4f90 	cmp.w	r3, #1207959552	; 0x48000000
 800196a:	d106      	bne.n	800197a <gpio_clock_enable+0x1e>
	{
		RCC->AHBENR |= (1 << GPIOA_CLOCK_ENABLE_BIT) ; //(1<<17);
 800196c:	4b2b      	ldr	r3, [pc, #172]	; (8001a1c <gpio_clock_enable+0xc0>)
 800196e:	695b      	ldr	r3, [r3, #20]
 8001970:	4a2a      	ldr	r2, [pc, #168]	; (8001a1c <gpio_clock_enable+0xc0>)
 8001972:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 8001976:	6153      	str	r3, [r2, #20]
	}
	*/
	else{

	}
}
 8001978:	e04b      	b.n	8001a12 <gpio_clock_enable+0xb6>
	else if(Port == GPIOB)  //    Bit 18 IOPBEN: I/O port B  clock enable
 800197a:	687b      	ldr	r3, [r7, #4]
 800197c:	4a28      	ldr	r2, [pc, #160]	; (8001a20 <gpio_clock_enable+0xc4>)
 800197e:	4293      	cmp	r3, r2
 8001980:	d106      	bne.n	8001990 <gpio_clock_enable+0x34>
		RCC->AHBENR |= (1 << GPIOB_CLOCK_ENABLE_BIT) ;
 8001982:	4b26      	ldr	r3, [pc, #152]	; (8001a1c <gpio_clock_enable+0xc0>)
 8001984:	695b      	ldr	r3, [r3, #20]
 8001986:	4a25      	ldr	r2, [pc, #148]	; (8001a1c <gpio_clock_enable+0xc0>)
 8001988:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
 800198c:	6153      	str	r3, [r2, #20]
}
 800198e:	e040      	b.n	8001a12 <gpio_clock_enable+0xb6>
	else if(Port == GPIOC)   //  Bit 19 IOPCEN: I/O port C clock enable
 8001990:	687b      	ldr	r3, [r7, #4]
 8001992:	4a24      	ldr	r2, [pc, #144]	; (8001a24 <gpio_clock_enable+0xc8>)
 8001994:	4293      	cmp	r3, r2
 8001996:	d106      	bne.n	80019a6 <gpio_clock_enable+0x4a>
		RCC->AHBENR |= (1 << GPIOC_CLOCK_ENABLE_BIT) ;
 8001998:	4b20      	ldr	r3, [pc, #128]	; (8001a1c <gpio_clock_enable+0xc0>)
 800199a:	695b      	ldr	r3, [r3, #20]
 800199c:	4a1f      	ldr	r2, [pc, #124]	; (8001a1c <gpio_clock_enable+0xc0>)
 800199e:	f443 2300 	orr.w	r3, r3, #524288	; 0x80000
 80019a2:	6153      	str	r3, [r2, #20]
}
 80019a4:	e035      	b.n	8001a12 <gpio_clock_enable+0xb6>
	else if(Port == GPIOD)    //  Bit 20 IOPDEN: I/O port D clock enable
 80019a6:	687b      	ldr	r3, [r7, #4]
 80019a8:	4a1f      	ldr	r2, [pc, #124]	; (8001a28 <gpio_clock_enable+0xcc>)
 80019aa:	4293      	cmp	r3, r2
 80019ac:	d106      	bne.n	80019bc <gpio_clock_enable+0x60>
		RCC->AHBENR |= (1 << GPIOD_CLOCK_ENABLE_BIT) ;
 80019ae:	4b1b      	ldr	r3, [pc, #108]	; (8001a1c <gpio_clock_enable+0xc0>)
 80019b0:	695b      	ldr	r3, [r3, #20]
 80019b2:	4a1a      	ldr	r2, [pc, #104]	; (8001a1c <gpio_clock_enable+0xc0>)
 80019b4:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 80019b8:	6153      	str	r3, [r2, #20]
}
 80019ba:	e02a      	b.n	8001a12 <gpio_clock_enable+0xb6>
	else if(Port == GPIOE)    //  Bit 21 IOPEEN: I/O port E clock enable
 80019bc:	687b      	ldr	r3, [r7, #4]
 80019be:	4a1b      	ldr	r2, [pc, #108]	; (8001a2c <gpio_clock_enable+0xd0>)
 80019c0:	4293      	cmp	r3, r2
 80019c2:	d106      	bne.n	80019d2 <gpio_clock_enable+0x76>
		RCC->AHBENR |= (1 << GPIOE_CLOCK_ENABLE_BIT) ;
 80019c4:	4b15      	ldr	r3, [pc, #84]	; (8001a1c <gpio_clock_enable+0xc0>)
 80019c6:	695b      	ldr	r3, [r3, #20]
 80019c8:	4a14      	ldr	r2, [pc, #80]	; (8001a1c <gpio_clock_enable+0xc0>)
 80019ca:	f443 1300 	orr.w	r3, r3, #2097152	; 0x200000
 80019ce:	6153      	str	r3, [r2, #20]
}
 80019d0:	e01f      	b.n	8001a12 <gpio_clock_enable+0xb6>
	else if(Port == GPIOF)   //  Bit 22 IOPFEN: I/O port F clock enable
 80019d2:	687b      	ldr	r3, [r7, #4]
 80019d4:	4a16      	ldr	r2, [pc, #88]	; (8001a30 <gpio_clock_enable+0xd4>)
 80019d6:	4293      	cmp	r3, r2
 80019d8:	d106      	bne.n	80019e8 <gpio_clock_enable+0x8c>
		RCC->AHBENR |= (1 << GPIOF_CLOCK_ENABLE_BIT) ;
 80019da:	4b10      	ldr	r3, [pc, #64]	; (8001a1c <gpio_clock_enable+0xc0>)
 80019dc:	695b      	ldr	r3, [r3, #20]
 80019de:	4a0f      	ldr	r2, [pc, #60]	; (8001a1c <gpio_clock_enable+0xc0>)
 80019e0:	f443 0380 	orr.w	r3, r3, #4194304	; 0x400000
 80019e4:	6153      	str	r3, [r2, #20]
}
 80019e6:	e014      	b.n	8001a12 <gpio_clock_enable+0xb6>
	else if(Port == GPIOG)    //  Bit 23 IOPGEN: I/O port G clock enable
 80019e8:	687b      	ldr	r3, [r7, #4]
 80019ea:	4a12      	ldr	r2, [pc, #72]	; (8001a34 <gpio_clock_enable+0xd8>)
 80019ec:	4293      	cmp	r3, r2
 80019ee:	d106      	bne.n	80019fe <gpio_clock_enable+0xa2>
		RCC->AHBENR |= (1 << GPIOG_CLOCK_ENABLE_BIT) ;
 80019f0:	4b0a      	ldr	r3, [pc, #40]	; (8001a1c <gpio_clock_enable+0xc0>)
 80019f2:	695b      	ldr	r3, [r3, #20]
 80019f4:	4a09      	ldr	r2, [pc, #36]	; (8001a1c <gpio_clock_enable+0xc0>)
 80019f6:	f443 0300 	orr.w	r3, r3, #8388608	; 0x800000
 80019fa:	6153      	str	r3, [r2, #20]
}
 80019fc:	e009      	b.n	8001a12 <gpio_clock_enable+0xb6>
	else if(Port == GPIOH)    //  Bit 16 IOPHEN: I/O port H clock enable
 80019fe:	687b      	ldr	r3, [r7, #4]
 8001a00:	4a0d      	ldr	r2, [pc, #52]	; (8001a38 <gpio_clock_enable+0xdc>)
 8001a02:	4293      	cmp	r3, r2
 8001a04:	d105      	bne.n	8001a12 <gpio_clock_enable+0xb6>
		RCC->AHBENR |= (1 << GPIOH_CLOCK_ENABLE_BIT) ;
 8001a06:	4b05      	ldr	r3, [pc, #20]	; (8001a1c <gpio_clock_enable+0xc0>)
 8001a08:	695b      	ldr	r3, [r3, #20]
 8001a0a:	4a04      	ldr	r2, [pc, #16]	; (8001a1c <gpio_clock_enable+0xc0>)
 8001a0c:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8001a10:	6153      	str	r3, [r2, #20]
}
 8001a12:	bf00      	nop
 8001a14:	370c      	adds	r7, #12
 8001a16:	46bd      	mov	sp, r7
 8001a18:	bc80      	pop	{r7}
 8001a1a:	4770      	bx	lr
 8001a1c:	40021000 	.word	0x40021000
 8001a20:	48000400 	.word	0x48000400
 8001a24:	48000800 	.word	0x48000800
 8001a28:	48000c00 	.word	0x48000c00
 8001a2c:	48001000 	.word	0x48001000
 8001a30:	48001400 	.word	0x48001400
 8001a34:	48001800 	.word	0x48001800
 8001a38:	48001c00 	.word	0x48001c00

08001a3c <reset_io>:
 * the OSPEEDR register controls the output speed,
 * and the PUPDR register controls the pull-up/pull-down settings.
 * By setting all of these registers to zero, the function effectively disables all the pins on the specified port
 * and sets them to their default state, which is an input mode with no pull-up/pull-down resistors and no output buffer.
 */
void reset_io(GPIO_TypeDef * Port ) {
 8001a3c:	b480      	push	{r7}
 8001a3e:	b083      	sub	sp, #12
 8001a40:	af00      	add	r7, sp, #0
 8001a42:	6078      	str	r0, [r7, #4]
	Port->MODER   = 0x00 ;             // set pin Mode
 8001a44:	687b      	ldr	r3, [r7, #4]
 8001a46:	2200      	movs	r2, #0
 8001a48:	601a      	str	r2, [r3, #0]
	Port->OTYPER  = 0x00 ;             //set output type OD/PP
 8001a4a:	687b      	ldr	r3, [r7, #4]
 8001a4c:	2200      	movs	r2, #0
 8001a4e:	605a      	str	r2, [r3, #4]
	Port->OSPEEDR = 0x00 ;             //set output speed
 8001a50:	687b      	ldr	r3, [r7, #4]
 8001a52:	2200      	movs	r2, #0
 8001a54:	609a      	str	r2, [r3, #8]
	Port->PUPDR	  = 0x00 ;             //set pin Pull
 8001a56:	687b      	ldr	r3, [r7, #4]
 8001a58:	2200      	movs	r2, #0
 8001a5a:	60da      	str	r2, [r3, #12]
}
 8001a5c:	bf00      	nop
 8001a5e:	370c      	adds	r7, #12
 8001a60:	46bd      	mov	sp, r7
 8001a62:	bc80      	pop	{r7}
 8001a64:	4770      	bx	lr

08001a66 <gpio_config_pin>:
 * And the otype variable sets the pin's output type (open-drain or push-pull).
 * The function sets these parameters by setting the appropriate bits in the MODER, OTYPER, OSPEEDR, and PUPDR registers of the specified port.
 */
void gpio_config_pin(GPIO_TypeDef * Port , int Pin , GPIO_Mode_t Mode ,
					   GPIO_Speed_t speed ,GPIO_Pull_t pull, GPIO_out_type_t otype)
{
 8001a66:	b480      	push	{r7}
 8001a68:	b085      	sub	sp, #20
 8001a6a:	af00      	add	r7, sp, #0
 8001a6c:	60f8      	str	r0, [r7, #12]
 8001a6e:	60b9      	str	r1, [r7, #8]
 8001a70:	4611      	mov	r1, r2
 8001a72:	461a      	mov	r2, r3
 8001a74:	460b      	mov	r3, r1
 8001a76:	71fb      	strb	r3, [r7, #7]
 8001a78:	4613      	mov	r3, r2
 8001a7a:	71bb      	strb	r3, [r7, #6]
	Port->MODER   |= (Mode  << 2 * Pin) ; // set  pin Mode
 8001a7c:	68fb      	ldr	r3, [r7, #12]
 8001a7e:	681b      	ldr	r3, [r3, #0]
 8001a80:	79f9      	ldrb	r1, [r7, #7]
 8001a82:	68ba      	ldr	r2, [r7, #8]
 8001a84:	0052      	lsls	r2, r2, #1
 8001a86:	fa01 f202 	lsl.w	r2, r1, r2
 8001a8a:	431a      	orrs	r2, r3
 8001a8c:	68fb      	ldr	r3, [r7, #12]
 8001a8e:	601a      	str	r2, [r3, #0]
	Port->OTYPER  |= (otype << Pin)     ; //set output type OD/PP
 8001a90:	68fb      	ldr	r3, [r7, #12]
 8001a92:	685b      	ldr	r3, [r3, #4]
 8001a94:	7f39      	ldrb	r1, [r7, #28]
 8001a96:	68ba      	ldr	r2, [r7, #8]
 8001a98:	fa01 f202 	lsl.w	r2, r1, r2
 8001a9c:	431a      	orrs	r2, r3
 8001a9e:	68fb      	ldr	r3, [r7, #12]
 8001aa0:	605a      	str	r2, [r3, #4]
	Port->OSPEEDR |= (speed << 2 * Pin) ; //set output speed
 8001aa2:	68fb      	ldr	r3, [r7, #12]
 8001aa4:	689b      	ldr	r3, [r3, #8]
 8001aa6:	79b9      	ldrb	r1, [r7, #6]
 8001aa8:	68ba      	ldr	r2, [r7, #8]
 8001aaa:	0052      	lsls	r2, r2, #1
 8001aac:	fa01 f202 	lsl.w	r2, r1, r2
 8001ab0:	431a      	orrs	r2, r3
 8001ab2:	68fb      	ldr	r3, [r7, #12]
 8001ab4:	609a      	str	r2, [r3, #8]
	Port->PUPDR	  |= (pull  << 2 * Pin) ; //set pin Pull
 8001ab6:	68fb      	ldr	r3, [r7, #12]
 8001ab8:	68db      	ldr	r3, [r3, #12]
 8001aba:	7e39      	ldrb	r1, [r7, #24]
 8001abc:	68ba      	ldr	r2, [r7, #8]
 8001abe:	0052      	lsls	r2, r2, #1
 8001ac0:	fa01 f202 	lsl.w	r2, r1, r2
 8001ac4:	431a      	orrs	r2, r3
 8001ac6:	68fb      	ldr	r3, [r7, #12]
 8001ac8:	60da      	str	r2, [r3, #12]
}
 8001aca:	bf00      	nop
 8001acc:	3714      	adds	r7, #20
 8001ace:	46bd      	mov	sp, r7
 8001ad0:	bc80      	pop	{r7}
 8001ad2:	4770      	bx	lr

08001ad4 <gpio_set_pinState>:
 * if it is high it uses bitwise OR operator to set the specified pin to high,
 * if it is low it uses bitwise AND operator with NOT operator to set the specified pin to low.
 */

void gpio_set_pinState(GPIO_TypeDef * Port , int Pin , Pin_State State)
{
 8001ad4:	b480      	push	{r7}
 8001ad6:	b085      	sub	sp, #20
 8001ad8:	af00      	add	r7, sp, #0
 8001ada:	60f8      	str	r0, [r7, #12]
 8001adc:	60b9      	str	r1, [r7, #8]
 8001ade:	4613      	mov	r3, r2
 8001ae0:	71fb      	strb	r3, [r7, #7]
    // assert that the pin number is less than 16
    // this is to ensure that the pin number is within the valid range
    // assert(pin < 16);

    if(State == HIGH)
 8001ae2:	79fb      	ldrb	r3, [r7, #7]
 8001ae4:	2b00      	cmp	r3, #0
 8001ae6:	d109      	bne.n	8001afc <gpio_set_pinState+0x28>
    {
        // Use bitwise OR operator to set the specified pin to high
        Port->ODR |= (1 << Pin);
 8001ae8:	68fb      	ldr	r3, [r7, #12]
 8001aea:	695b      	ldr	r3, [r3, #20]
 8001aec:	2101      	movs	r1, #1
 8001aee:	68ba      	ldr	r2, [r7, #8]
 8001af0:	fa01 f202 	lsl.w	r2, r1, r2
 8001af4:	431a      	orrs	r2, r3
 8001af6:	68fb      	ldr	r3, [r7, #12]
 8001af8:	615a      	str	r2, [r3, #20]
    }
    else {
        // Use bitwise AND operator with NOT operator to set the specified pin to low
        Port->ODR &= ~(1 << Pin);
    }
}
 8001afa:	e009      	b.n	8001b10 <gpio_set_pinState+0x3c>
        Port->ODR &= ~(1 << Pin);
 8001afc:	68fb      	ldr	r3, [r7, #12]
 8001afe:	695b      	ldr	r3, [r3, #20]
 8001b00:	2101      	movs	r1, #1
 8001b02:	68ba      	ldr	r2, [r7, #8]
 8001b04:	fa01 f202 	lsl.w	r2, r1, r2
 8001b08:	43d2      	mvns	r2, r2
 8001b0a:	401a      	ands	r2, r3
 8001b0c:	68fb      	ldr	r3, [r7, #12]
 8001b0e:	615a      	str	r2, [r3, #20]
}
 8001b10:	bf00      	nop
 8001b12:	3714      	adds	r7, #20
 8001b14:	46bd      	mov	sp, r7
 8001b16:	bc80      	pop	{r7}
 8001b18:	4770      	bx	lr
	...

08001b1c <I2C_Init>:
 * Depending on which peripheral is being initialized, the function sets up the corresponding GPIO pins as alternate function mode and enables the peripheral clock.
 * After that, the function sets up the timing configuration for the I2C peripheral by setting the PRESC, SCLDEL, and SDADEL bits in the TIMINGR register.
 * Finally, the function enables the I2C peripheral by setting the PE bit in the CR1 register.
 */
void I2C_Init(I2C_TypeDef * i2c)
{
 8001b1c:	b480      	push	{r7}
 8001b1e:	b083      	sub	sp, #12
 8001b20:	af00      	add	r7, sp, #0
 8001b22:	6078      	str	r0, [r7, #4]


 	 if( i2c == I2C1)
 8001b24:	687b      	ldr	r3, [r7, #4]
 8001b26:	4a6e      	ldr	r2, [pc, #440]	; (8001ce0 <I2C_Init+0x1c4>)
 8001b28:	4293      	cmp	r3, r2
 8001b2a:	d118      	bne.n	8001b5e <I2C_Init+0x42>
 	 {
 		// PB6  I2C1_SCL, PB7   I2C1_SDA
 		RCC->AHBENR |= RCC_AHBENR_GPIOBEN;
 8001b2c:	4b6d      	ldr	r3, [pc, #436]	; (8001ce4 <I2C_Init+0x1c8>)
 8001b2e:	695b      	ldr	r3, [r3, #20]
 8001b30:	4a6c      	ldr	r2, [pc, #432]	; (8001ce4 <I2C_Init+0x1c8>)
 8001b32:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
 8001b36:	6153      	str	r3, [r2, #20]
 		GPIOB->MODER |= (0b10 << GPIO_MODER_MODER6_Pos) |
 8001b38:	4b6b      	ldr	r3, [pc, #428]	; (8001ce8 <I2C_Init+0x1cc>)
 8001b3a:	681b      	ldr	r3, [r3, #0]
 8001b3c:	4a6a      	ldr	r2, [pc, #424]	; (8001ce8 <I2C_Init+0x1cc>)
 8001b3e:	f443 4320 	orr.w	r3, r3, #40960	; 0xa000
 8001b42:	6013      	str	r3, [r2, #0]
		   (0b10 << GPIO_MODER_MODER7_Pos); // PB6, PB7: Alternate function
		 GPIOB->AFR[0] |= (4 << GPIO_AFRL_AFRL6_Pos) |
 8001b44:	4b68      	ldr	r3, [pc, #416]	; (8001ce8 <I2C_Init+0x1cc>)
 8001b46:	6a1b      	ldr	r3, [r3, #32]
 8001b48:	4a67      	ldr	r2, [pc, #412]	; (8001ce8 <I2C_Init+0x1cc>)
 8001b4a:	f043 4388 	orr.w	r3, r3, #1140850688	; 0x44000000
 8001b4e:	6213      	str	r3, [r2, #32]
		   (4 << GPIO_AFRL_AFRL7_Pos);         // 0100: AF4

		 RCC->APB1ENR |= RCC_APB1ENR_I2C1EN; //i2c clock enable
 8001b50:	4b64      	ldr	r3, [pc, #400]	; (8001ce4 <I2C_Init+0x1c8>)
 8001b52:	69db      	ldr	r3, [r3, #28]
 8001b54:	4a63      	ldr	r2, [pc, #396]	; (8001ce4 <I2C_Init+0x1c8>)
 8001b56:	f443 1300 	orr.w	r3, r3, #2097152	; 0x200000
 8001b5a:	61d3      	str	r3, [r2, #28]
 8001b5c:	e0ac      	b.n	8001cb8 <I2C_Init+0x19c>
 	 }
 	 else if( i2c == I2C2 )
 8001b5e:	687b      	ldr	r3, [r7, #4]
 8001b60:	4a62      	ldr	r2, [pc, #392]	; (8001cec <I2C_Init+0x1d0>)
 8001b62:	4293      	cmp	r3, r2
 8001b64:	d14c      	bne.n	8001c00 <I2C_Init+0xe4>
 	 {
 		//PA9 I2C2_SCL , PA10 I2C2_SDA
 		RCC->AHBENR |= RCC_AHBENR_GPIOAEN;
 8001b66:	4b5f      	ldr	r3, [pc, #380]	; (8001ce4 <I2C_Init+0x1c8>)
 8001b68:	695b      	ldr	r3, [r3, #20]
 8001b6a:	4a5e      	ldr	r2, [pc, #376]	; (8001ce4 <I2C_Init+0x1c8>)
 8001b6c:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 8001b70:	6153      	str	r3, [r2, #20]
 		GPIOA->MODER |= (2 << 18) ;// PA9 10: Alternate function mode
 8001b72:	f04f 4390 	mov.w	r3, #1207959552	; 0x48000000
 8001b76:	681b      	ldr	r3, [r3, #0]
 8001b78:	f04f 4290 	mov.w	r2, #1207959552	; 0x48000000
 8001b7c:	f443 2300 	orr.w	r3, r3, #524288	; 0x80000
 8001b80:	6013      	str	r3, [r2, #0]
 		GPIOA->MODER |= (2 << 20) ;//PA10 10: Alternate function mode
 8001b82:	f04f 4390 	mov.w	r3, #1207959552	; 0x48000000
 8001b86:	681b      	ldr	r3, [r3, #0]
 8001b88:	f04f 4290 	mov.w	r2, #1207959552	; 0x48000000
 8001b8c:	f443 1300 	orr.w	r3, r3, #2097152	; 0x200000
 8001b90:	6013      	str	r3, [r2, #0]
 		GPIOA->OTYPER |= (1 << 9 ) ;//PA9  GPIO port output type register 1: Output open-drain
 8001b92:	f04f 4390 	mov.w	r3, #1207959552	; 0x48000000
 8001b96:	685b      	ldr	r3, [r3, #4]
 8001b98:	f04f 4290 	mov.w	r2, #1207959552	; 0x48000000
 8001b9c:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 8001ba0:	6053      	str	r3, [r2, #4]
 		GPIOA->OTYPER |= (1 << 10) ;//PA10 Oepn Drain
 8001ba2:	f04f 4390 	mov.w	r3, #1207959552	; 0x48000000
 8001ba6:	685b      	ldr	r3, [r3, #4]
 8001ba8:	f04f 4290 	mov.w	r2, #1207959552	; 0x48000000
 8001bac:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
 8001bb0:	6053      	str	r3, [r2, #4]
 		GPIOA->OSPEEDR |= (3 << 18) | (3 << 20) ; //PA9,PA10  GPIO port output speed register 11: High speed
 8001bb2:	f04f 4390 	mov.w	r3, #1207959552	; 0x48000000
 8001bb6:	689b      	ldr	r3, [r3, #8]
 8001bb8:	f04f 4290 	mov.w	r2, #1207959552	; 0x48000000
 8001bbc:	f443 1370 	orr.w	r3, r3, #3932160	; 0x3c0000
 8001bc0:	6093      	str	r3, [r2, #8]
 		GPIOA->PUPDR  |= (1<<18) | (1<<20) ;//PA9 ,PA10 GPIO port pull-up/pull-down register 01: Pull-up
 8001bc2:	f04f 4390 	mov.w	r3, #1207959552	; 0x48000000
 8001bc6:	68db      	ldr	r3, [r3, #12]
 8001bc8:	f04f 4290 	mov.w	r2, #1207959552	; 0x48000000
 8001bcc:	f443 13a0 	orr.w	r3, r3, #1310720	; 0x140000
 8001bd0:	60d3      	str	r3, [r2, #12]
 		GPIOA->AFR[1] |= ( 4 << 4 );   //select GPIO alternate function high register  PA9  0100: AF4
 8001bd2:	f04f 4390 	mov.w	r3, #1207959552	; 0x48000000
 8001bd6:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8001bd8:	f04f 4290 	mov.w	r2, #1207959552	; 0x48000000
 8001bdc:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8001be0:	6253      	str	r3, [r2, #36]	; 0x24
 		GPIOA->AFR[1] |= (4 << 8);   //select GPIO alternate function high register  PA10   0100: AF4
 8001be2:	f04f 4390 	mov.w	r3, #1207959552	; 0x48000000
 8001be6:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8001be8:	f04f 4290 	mov.w	r2, #1207959552	; 0x48000000
 8001bec:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
 8001bf0:	6253      	str	r3, [r2, #36]	; 0x24

 		RCC->APB1ENR |=RCC_APB1ENR_I2C2EN ; //i2c clock enable
 8001bf2:	4b3c      	ldr	r3, [pc, #240]	; (8001ce4 <I2C_Init+0x1c8>)
 8001bf4:	69db      	ldr	r3, [r3, #28]
 8001bf6:	4a3b      	ldr	r2, [pc, #236]	; (8001ce4 <I2C_Init+0x1c8>)
 8001bf8:	f443 0380 	orr.w	r3, r3, #4194304	; 0x400000
 8001bfc:	61d3      	str	r3, [r2, #28]
 8001bfe:	e05b      	b.n	8001cb8 <I2C_Init+0x19c>
 	 }
 	 else if( i2c == I2C3 )
 8001c00:	687b      	ldr	r3, [r7, #4]
 8001c02:	4a3b      	ldr	r2, [pc, #236]	; (8001cf0 <I2C_Init+0x1d4>)
 8001c04:	4293      	cmp	r3, r2
 8001c06:	d157      	bne.n	8001cb8 <I2C_Init+0x19c>
 	 {
 		//PA8 I2C3_SCL , PB5 I2C3_SDA
 		RCC->AHBENR |= RCC_AHBENR_GPIOBEN;
 8001c08:	4b36      	ldr	r3, [pc, #216]	; (8001ce4 <I2C_Init+0x1c8>)
 8001c0a:	695b      	ldr	r3, [r3, #20]
 8001c0c:	4a35      	ldr	r2, [pc, #212]	; (8001ce4 <I2C_Init+0x1c8>)
 8001c0e:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
 8001c12:	6153      	str	r3, [r2, #20]
 		RCC->AHBENR |= RCC_AHBENR_GPIOAEN;
 8001c14:	4b33      	ldr	r3, [pc, #204]	; (8001ce4 <I2C_Init+0x1c8>)
 8001c16:	695b      	ldr	r3, [r3, #20]
 8001c18:	4a32      	ldr	r2, [pc, #200]	; (8001ce4 <I2C_Init+0x1c8>)
 8001c1a:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 8001c1e:	6153      	str	r3, [r2, #20]

 		GPIOA->MODER   |= (2 << 16) ;// PA8 ALF
 8001c20:	f04f 4390 	mov.w	r3, #1207959552	; 0x48000000
 8001c24:	681b      	ldr	r3, [r3, #0]
 8001c26:	f04f 4290 	mov.w	r2, #1207959552	; 0x48000000
 8001c2a:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 8001c2e:	6013      	str	r3, [r2, #0]
 		GPIOB->MODER   |= (2 << 10) ;//PB5 ALF
 8001c30:	4b2d      	ldr	r3, [pc, #180]	; (8001ce8 <I2C_Init+0x1cc>)
 8001c32:	681b      	ldr	r3, [r3, #0]
 8001c34:	4a2c      	ldr	r2, [pc, #176]	; (8001ce8 <I2C_Init+0x1cc>)
 8001c36:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
 8001c3a:	6013      	str	r3, [r2, #0]
 		GPIOA->OTYPER  |= (1 << 8 ) ;//PA8 Open Drain
 8001c3c:	f04f 4390 	mov.w	r3, #1207959552	; 0x48000000
 8001c40:	685b      	ldr	r3, [r3, #4]
 8001c42:	f04f 4290 	mov.w	r2, #1207959552	; 0x48000000
 8001c46:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8001c4a:	6053      	str	r3, [r2, #4]
 		GPIOB->OTYPER  |= (1 << 5 ) ;//PB5 Oepn Drain
 8001c4c:	4b26      	ldr	r3, [pc, #152]	; (8001ce8 <I2C_Init+0x1cc>)
 8001c4e:	685b      	ldr	r3, [r3, #4]
 8001c50:	4a25      	ldr	r2, [pc, #148]	; (8001ce8 <I2C_Init+0x1cc>)
 8001c52:	f043 0320 	orr.w	r3, r3, #32
 8001c56:	6053      	str	r3, [r2, #4]
 		GPIOA->OSPEEDR |= (3 << 16) ;//PA8 High Speed
 8001c58:	f04f 4390 	mov.w	r3, #1207959552	; 0x48000000
 8001c5c:	689b      	ldr	r3, [r3, #8]
 8001c5e:	f04f 4290 	mov.w	r2, #1207959552	; 0x48000000
 8001c62:	f443 3340 	orr.w	r3, r3, #196608	; 0x30000
 8001c66:	6093      	str	r3, [r2, #8]
 		GPIOB->OSPEEDR |= (3 << 10) ; //PB5 High Speed
 8001c68:	4b1f      	ldr	r3, [pc, #124]	; (8001ce8 <I2C_Init+0x1cc>)
 8001c6a:	689b      	ldr	r3, [r3, #8]
 8001c6c:	4a1e      	ldr	r2, [pc, #120]	; (8001ce8 <I2C_Init+0x1cc>)
 8001c6e:	f443 6340 	orr.w	r3, r3, #3072	; 0xc00
 8001c72:	6093      	str	r3, [r2, #8]
 		GPIOA->PUPDR   |= (1 << 16) ;//PA8 PULL up
 8001c74:	f04f 4390 	mov.w	r3, #1207959552	; 0x48000000
 8001c78:	68db      	ldr	r3, [r3, #12]
 8001c7a:	f04f 4290 	mov.w	r2, #1207959552	; 0x48000000
 8001c7e:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8001c82:	60d3      	str	r3, [r2, #12]
 		GPIOB->PUPDR   |= (1 << 10) ;//PB5 PULL up
 8001c84:	4b18      	ldr	r3, [pc, #96]	; (8001ce8 <I2C_Init+0x1cc>)
 8001c86:	68db      	ldr	r3, [r3, #12]
 8001c88:	4a17      	ldr	r2, [pc, #92]	; (8001ce8 <I2C_Init+0x1cc>)
 8001c8a:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
 8001c8e:	60d3      	str	r3, [r2, #12]
 		GPIOA->AFR[1]  |= ( 3 << 0 );//select Alf PA8    0011: AF3
 8001c90:	f04f 4390 	mov.w	r3, #1207959552	; 0x48000000
 8001c94:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8001c96:	f04f 4290 	mov.w	r2, #1207959552	; 0x48000000
 8001c9a:	f043 0303 	orr.w	r3, r3, #3
 8001c9e:	6253      	str	r3, [r2, #36]	; 0x24
 		GPIOB->AFR[0]  |= (8 << 20) ;//select Alf PB5     1000: AF8
 8001ca0:	4b11      	ldr	r3, [pc, #68]	; (8001ce8 <I2C_Init+0x1cc>)
 8001ca2:	6a1b      	ldr	r3, [r3, #32]
 8001ca4:	4a10      	ldr	r2, [pc, #64]	; (8001ce8 <I2C_Init+0x1cc>)
 8001ca6:	f443 0300 	orr.w	r3, r3, #8388608	; 0x800000
 8001caa:	6213      	str	r3, [r2, #32]

 		RCC->APB1ENR |=RCC_APB1ENR_I2C3EN ; //i2c clock enable
 8001cac:	4b0d      	ldr	r3, [pc, #52]	; (8001ce4 <I2C_Init+0x1c8>)
 8001cae:	69db      	ldr	r3, [r3, #28]
 8001cb0:	4a0c      	ldr	r2, [pc, #48]	; (8001ce4 <I2C_Init+0x1c8>)
 8001cb2:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
 8001cb6:	61d3      	str	r3, [r2, #28]
	 * Enabling and disabling the peripheral
	 * The I2C peripheral clock must be configured and enabled in the clock controller.
	 * Then the I2C can be enabled by setting the PE(PinEnable) bit in the I2C_CR1 register.
	 * When the I2C is disabled (PE=0), the I2C performs a software reset.
	 */
	 i2c->CR1 &= ~I2C_CR1_PE;                // disable the i2c peripheral clock  (clear PE bit in I2C_CR1)
 8001cb8:	687b      	ldr	r3, [r7, #4]
 8001cba:	681b      	ldr	r3, [r3, #0]
 8001cbc:	f023 0201 	bic.w	r2, r3, #1
 8001cc0:	687b      	ldr	r3, [r7, #4]
 8001cc2:	601a      	str	r2, [r3, #0]
	/*
	 * I2C timings
	 * The timings must be configured in order to guarantee a correct data hold and setup time,
	 * used in master and slave modes. This is done by programming the PRESC,SCLDEL and SDADEL bits in the I2C_TIMINGR register.
	 */
	 i2c->TIMINGR = (1 << I2C_TIMINGR_PRESC_Pos) | // Standard mode 100 kHz @ 8 MHz (page 849/1141)
 8001cc4:	687b      	ldr	r3, [r7, #4]
 8001cc6:	4a0b      	ldr	r2, [pc, #44]	; (8001cf4 <I2C_Init+0x1d8>)
 8001cc8:	611a      	str	r2, [r3, #16]
	             (0x13 << I2C_TIMINGR_SCLL_Pos)  |
	             (0xF << I2C_TIMINGR_SCLH_Pos)   |
	             (0x2 << I2C_TIMINGR_SDADEL_Pos) |
	             (0x4 << I2C_TIMINGR_SCLDEL_Pos);

	 i2c->CR1 |= I2C_CR1_PE;// enable the i2c peripheral clock (set PE bit inI2C_CR1)
 8001cca:	687b      	ldr	r3, [r7, #4]
 8001ccc:	681b      	ldr	r3, [r3, #0]
 8001cce:	f043 0201 	orr.w	r2, r3, #1
 8001cd2:	687b      	ldr	r3, [r7, #4]
 8001cd4:	601a      	str	r2, [r3, #0]

}
 8001cd6:	bf00      	nop
 8001cd8:	370c      	adds	r7, #12
 8001cda:	46bd      	mov	sp, r7
 8001cdc:	bc80      	pop	{r7}
 8001cde:	4770      	bx	lr
 8001ce0:	40005400 	.word	0x40005400
 8001ce4:	40021000 	.word	0x40021000
 8001ce8:	48000400 	.word	0x48000400
 8001cec:	40005800 	.word	0x40005800
 8001cf0:	40007800 	.word	0x40007800
 8001cf4:	10420f13 	.word	0x10420f13

08001cf8 <I2C_Write>:

After that, it writes the data buffer to the I2C device using a for loop, the loop iterates len-1 times and writes a byte to the TXDR register each time.
 */

void I2C_Write(I2C_TypeDef * i2c , uint8_t address , uint8_t * data , uint8_t len)
{
 8001cf8:	b480      	push	{r7}
 8001cfa:	b087      	sub	sp, #28
 8001cfc:	af00      	add	r7, sp, #0
 8001cfe:	60f8      	str	r0, [r7, #12]
 8001d00:	607a      	str	r2, [r7, #4]
 8001d02:	461a      	mov	r2, r3
 8001d04:	460b      	mov	r3, r1
 8001d06:	72fb      	strb	r3, [r7, #11]
 8001d08:	4613      	mov	r3, r2
 8001d0a:	72bb      	strb	r3, [r7, #10]
    //configuring the CR2 register to send the device address, the length of the data buffer, and the write bit.
	i2c->CR2 = ((address << 1) << I2C_CR2_SADD_Pos) | (len << I2C_CR2_NBYTES_Pos)
 8001d0c:	7afb      	ldrb	r3, [r7, #11]
 8001d0e:	005a      	lsls	r2, r3, #1
 8001d10:	7abb      	ldrb	r3, [r7, #10]
 8001d12:	041b      	lsls	r3, r3, #16
 8001d14:	4313      	orrs	r3, r2
			                                        | (0 << I2C_CR2_RD_WRN_Pos | I2C_CR2_AUTOEND);
 8001d16:	f043 7200 	orr.w	r2, r3, #33554432	; 0x2000000
	i2c->CR2 = ((address << 1) << I2C_CR2_SADD_Pos) | (len << I2C_CR2_NBYTES_Pos)
 8001d1a:	68fb      	ldr	r3, [r7, #12]
 8001d1c:	605a      	str	r2, [r3, #4]
    //sending start condition
		i2c->CR2 |= I2C_CR2_START;
 8001d1e:	68fb      	ldr	r3, [r7, #12]
 8001d20:	685b      	ldr	r3, [r3, #4]
 8001d22:	f443 5200 	orr.w	r2, r3, #8192	; 0x2000
 8001d26:	68fb      	ldr	r3, [r7, #12]
 8001d28:	605a      	str	r2, [r3, #4]
    //waiting until the TXDR register is empty
		while ((i2c->ISR & I2C_ISR_TXIS)==0) {
 8001d2a:	e005      	b.n	8001d38 <I2C_Write+0x40>
			if ((i2c->ISR & I2C_ISR_NACKF)){
 8001d2c:	68fb      	ldr	r3, [r7, #12]
 8001d2e:	699b      	ldr	r3, [r3, #24]
 8001d30:	f003 0310 	and.w	r3, r3, #16
 8001d34:	2b00      	cmp	r3, #0
 8001d36:	d123      	bne.n	8001d80 <I2C_Write+0x88>
		while ((i2c->ISR & I2C_ISR_TXIS)==0) {
 8001d38:	68fb      	ldr	r3, [r7, #12]
 8001d3a:	699b      	ldr	r3, [r3, #24]
 8001d3c:	f003 0302 	and.w	r3, r3, #2
 8001d40:	2b00      	cmp	r3, #0
 8001d42:	d0f3      	beq.n	8001d2c <I2C_Write+0x34>
				return;}}
    //writing data buffer to the I2C device using a for loop
		for(uint8_t j=0; j <= (len-1); j++)
 8001d44:	2300      	movs	r3, #0
 8001d46:	75fb      	strb	r3, [r7, #23]
 8001d48:	e015      	b.n	8001d76 <I2C_Write+0x7e>
		{
			i2c->TXDR = data[j];
 8001d4a:	7dfb      	ldrb	r3, [r7, #23]
 8001d4c:	687a      	ldr	r2, [r7, #4]
 8001d4e:	4413      	add	r3, r2
 8001d50:	781b      	ldrb	r3, [r3, #0]
 8001d52:	461a      	mov	r2, r3
 8001d54:	68fb      	ldr	r3, [r7, #12]
 8001d56:	629a      	str	r2, [r3, #40]	; 0x28
			if(j < (len-1))
 8001d58:	7dfa      	ldrb	r2, [r7, #23]
 8001d5a:	7abb      	ldrb	r3, [r7, #10]
 8001d5c:	3b01      	subs	r3, #1
 8001d5e:	429a      	cmp	r2, r3
 8001d60:	da06      	bge.n	8001d70 <I2C_Write+0x78>
			{
                //waiting until the TXIS flag is set
				while((i2c->ISR & I2C_ISR_TXIS)==0){}
 8001d62:	bf00      	nop
 8001d64:	68fb      	ldr	r3, [r7, #12]
 8001d66:	699b      	ldr	r3, [r3, #24]
 8001d68:	f003 0302 	and.w	r3, r3, #2
 8001d6c:	2b00      	cmp	r3, #0
 8001d6e:	d0f9      	beq.n	8001d64 <I2C_Write+0x6c>
		for(uint8_t j=0; j <= (len-1); j++)
 8001d70:	7dfb      	ldrb	r3, [r7, #23]
 8001d72:	3301      	adds	r3, #1
 8001d74:	75fb      	strb	r3, [r7, #23]
 8001d76:	7aba      	ldrb	r2, [r7, #10]
 8001d78:	7dfb      	ldrb	r3, [r7, #23]
 8001d7a:	429a      	cmp	r2, r3
 8001d7c:	d8e5      	bhi.n	8001d4a <I2C_Write+0x52>
 8001d7e:	e000      	b.n	8001d82 <I2C_Write+0x8a>
				return;}}
 8001d80:	bf00      	nop
			}
		}
}
 8001d82:	371c      	adds	r7, #28
 8001d84:	46bd      	mov	sp, r7
 8001d86:	bc80      	pop	{r7}
 8001d88:	4770      	bx	lr

08001d8a <I2C_Read>:
This stops the current I2C communication and releases the bus for other devices to use it.
 */


void I2C_Read(I2C_TypeDef * i2c ,uint8_t address , uint8_t * buffer , int len)
{
 8001d8a:	b480      	push	{r7}
 8001d8c:	b087      	sub	sp, #28
 8001d8e:	af00      	add	r7, sp, #0
 8001d90:	60f8      	str	r0, [r7, #12]
 8001d92:	607a      	str	r2, [r7, #4]
 8001d94:	603b      	str	r3, [r7, #0]
 8001d96:	460b      	mov	r3, r1
 8001d98:	72fb      	strb	r3, [r7, #11]
    //setting the slave address and the number of bytes to be transmitted
    i2c->CR2  = ((address << 1) << I2C_CR2_SADD_Pos) ;
 8001d9a:	7afb      	ldrb	r3, [r7, #11]
 8001d9c:	005b      	lsls	r3, r3, #1
 8001d9e:	461a      	mov	r2, r3
 8001da0:	68fb      	ldr	r3, [r7, #12]
 8001da2:	605a      	str	r2, [r3, #4]
	i2c->CR2 |=   (len << I2C_CR2_NBYTES_Pos);
 8001da4:	68fb      	ldr	r3, [r7, #12]
 8001da6:	685b      	ldr	r3, [r3, #4]
 8001da8:	683a      	ldr	r2, [r7, #0]
 8001daa:	0412      	lsls	r2, r2, #16
 8001dac:	431a      	orrs	r2, r3
 8001dae:	68fb      	ldr	r3, [r7, #12]
 8001db0:	605a      	str	r2, [r3, #4]
    //setting the read bit
	i2c->CR2 |= (1<<I2C_CR2_RD_WRN_Pos);
 8001db2:	68fb      	ldr	r3, [r7, #12]
 8001db4:	685b      	ldr	r3, [r3, #4]
 8001db6:	f443 6280 	orr.w	r2, r3, #1024	; 0x400
 8001dba:	68fb      	ldr	r3, [r7, #12]
 8001dbc:	605a      	str	r2, [r3, #4]
    //generating start condition
	i2c->CR2 |= I2C_CR2_START;
 8001dbe:	68fb      	ldr	r3, [r7, #12]
 8001dc0:	685b      	ldr	r3, [r3, #4]
 8001dc2:	f443 5200 	orr.w	r2, r3, #8192	; 0x2000
 8001dc6:	68fb      	ldr	r3, [r7, #12]
 8001dc8:	605a      	str	r2, [r3, #4]

    //reading data from the i2c device using a for loop
	 for( int i = 0 ;i<len ;i++)
 8001dca:	2300      	movs	r3, #0
 8001dcc:	617b      	str	r3, [r7, #20]
 8001dce:	e01d      	b.n	8001e0c <I2C_Read+0x82>
	 {
        //waiting for the RXNE flag to be set
		 while((i2c->ISR & I2C_ISR_RXNE) == 0) ;
 8001dd0:	bf00      	nop
 8001dd2:	68fb      	ldr	r3, [r7, #12]
 8001dd4:	699b      	ldr	r3, [r3, #24]
 8001dd6:	f003 0304 	and.w	r3, r3, #4
 8001dda:	2b00      	cmp	r3, #0
 8001ddc:	d0f9      	beq.n	8001dd2 <I2C_Read+0x48>
        //reading the data from the RXDR register
		 *buffer = i2c->RXDR ;
 8001dde:	68fb      	ldr	r3, [r7, #12]
 8001de0:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8001de2:	b2da      	uxtb	r2, r3
 8001de4:	687b      	ldr	r3, [r7, #4]
 8001de6:	701a      	strb	r2, [r3, #0]
        //incrementing the buffer pointer
		 buffer++ ;
 8001de8:	687b      	ldr	r3, [r7, #4]
 8001dea:	3301      	adds	r3, #1
 8001dec:	607b      	str	r3, [r7, #4]

		 if(i == len - 1)
 8001dee:	683b      	ldr	r3, [r7, #0]
 8001df0:	3b01      	subs	r3, #1
 8001df2:	697a      	ldr	r2, [r7, #20]
 8001df4:	429a      	cmp	r2, r3
 8001df6:	d106      	bne.n	8001e06 <I2C_Read+0x7c>
		 {
            //waiting for the TC flag to be set
			 while((i2c->ISR & I2C_ISR_TC) == 0) ;
 8001df8:	bf00      	nop
 8001dfa:	68fb      	ldr	r3, [r7, #12]
 8001dfc:	699b      	ldr	r3, [r3, #24]
 8001dfe:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8001e02:	2b00      	cmp	r3, #0
 8001e04:	d0f9      	beq.n	8001dfa <I2C_Read+0x70>
	 for( int i = 0 ;i<len ;i++)
 8001e06:	697b      	ldr	r3, [r7, #20]
 8001e08:	3301      	adds	r3, #1
 8001e0a:	617b      	str	r3, [r7, #20]
 8001e0c:	697a      	ldr	r2, [r7, #20]
 8001e0e:	683b      	ldr	r3, [r7, #0]
 8001e10:	429a      	cmp	r2, r3
 8001e12:	dbdd      	blt.n	8001dd0 <I2C_Read+0x46>
		 }
		 else{
			 //nope
		 }
	 }
}
 8001e14:	bf00      	nop
 8001e16:	bf00      	nop
 8001e18:	371c      	adds	r7, #28
 8001e1a:	46bd      	mov	sp, r7
 8001e1c:	bc80      	pop	{r7}
 8001e1e:	4770      	bx	lr

08001e20 <keypad_init>:
 * The function initializes the keypad by setting the keypad port and start pin, enabling the clock for the specified GPIO port,
 * and configuring the keypad's key direction (input or output) using the keypad_config_key_direction() function.

 */
void keypad_init(GPIO_TypeDef * port , int s_pin)
{
 8001e20:	b580      	push	{r7, lr}
 8001e22:	b082      	sub	sp, #8
 8001e24:	af00      	add	r7, sp, #0
 8001e26:	6078      	str	r0, [r7, #4]
 8001e28:	6039      	str	r1, [r7, #0]
	keypad_port = port   ;
 8001e2a:	4a08      	ldr	r2, [pc, #32]	; (8001e4c <keypad_init+0x2c>)
 8001e2c:	687b      	ldr	r3, [r7, #4]
 8001e2e:	6013      	str	r3, [r2, #0]
	start_pin   = s_pin  ;
 8001e30:	4a07      	ldr	r2, [pc, #28]	; (8001e50 <keypad_init+0x30>)
 8001e32:	683b      	ldr	r3, [r7, #0]
 8001e34:	6013      	str	r3, [r2, #0]
	gpio_clock_enable(port) ;
 8001e36:	6878      	ldr	r0, [r7, #4]
 8001e38:	f7ff fd90 	bl	800195c <gpio_clock_enable>
	keypad_config_key_direction(port , s_pin) ;////set  the first 4 pins as output and the second 4 pins as input
 8001e3c:	6839      	ldr	r1, [r7, #0]
 8001e3e:	6878      	ldr	r0, [r7, #4]
 8001e40:	f000 f808 	bl	8001e54 <keypad_config_key_direction>
}
 8001e44:	bf00      	nop
 8001e46:	3708      	adds	r7, #8
 8001e48:	46bd      	mov	sp, r7
 8001e4a:	bd80      	pop	{r7, pc}
 8001e4c:	20000d58 	.word	0x20000d58
 8001e50:	20000d5c 	.word	0x20000d5c

08001e54 <keypad_config_key_direction>:
 */



static void keypad_config_key_direction( GPIO_TypeDef * port , int s_pin)
{
 8001e54:	b580      	push	{r7, lr}
 8001e56:	b084      	sub	sp, #16
 8001e58:	af02      	add	r7, sp, #8
 8001e5a:	6078      	str	r0, [r7, #4]
 8001e5c:	6039      	str	r1, [r7, #0]
	reset_io(port) ;
 8001e5e:	6878      	ldr	r0, [r7, #4]
 8001e60:	f7ff fdec 	bl	8001a3c <reset_io>
	//configure the pins as Output with no pull
	gpio_config_pin(port ,s_pin++  ,GPIO_OUT , GPIO_SPEED_LOW , GPIO_NO_PULL,GPIO_PUSHPULL) ;//r1  1
 8001e64:	6839      	ldr	r1, [r7, #0]
 8001e66:	1c4b      	adds	r3, r1, #1
 8001e68:	603b      	str	r3, [r7, #0]
 8001e6a:	2300      	movs	r3, #0
 8001e6c:	9301      	str	r3, [sp, #4]
 8001e6e:	2300      	movs	r3, #0
 8001e70:	9300      	str	r3, [sp, #0]
 8001e72:	2300      	movs	r3, #0
 8001e74:	2201      	movs	r2, #1
 8001e76:	6878      	ldr	r0, [r7, #4]
 8001e78:	f7ff fdf5 	bl	8001a66 <gpio_config_pin>
	gpio_config_pin(port ,s_pin++  ,GPIO_OUT , GPIO_SPEED_LOW , GPIO_NO_PULL,GPIO_PUSHPULL) ;//r2  0
 8001e7c:	6839      	ldr	r1, [r7, #0]
 8001e7e:	1c4b      	adds	r3, r1, #1
 8001e80:	603b      	str	r3, [r7, #0]
 8001e82:	2300      	movs	r3, #0
 8001e84:	9301      	str	r3, [sp, #4]
 8001e86:	2300      	movs	r3, #0
 8001e88:	9300      	str	r3, [sp, #0]
 8001e8a:	2300      	movs	r3, #0
 8001e8c:	2201      	movs	r2, #1
 8001e8e:	6878      	ldr	r0, [r7, #4]
 8001e90:	f7ff fde9 	bl	8001a66 <gpio_config_pin>
	gpio_config_pin(port ,s_pin++  ,GPIO_OUT , GPIO_SPEED_LOW , GPIO_NO_PULL,GPIO_PUSHPULL) ;//r3  0
 8001e94:	6839      	ldr	r1, [r7, #0]
 8001e96:	1c4b      	adds	r3, r1, #1
 8001e98:	603b      	str	r3, [r7, #0]
 8001e9a:	2300      	movs	r3, #0
 8001e9c:	9301      	str	r3, [sp, #4]
 8001e9e:	2300      	movs	r3, #0
 8001ea0:	9300      	str	r3, [sp, #0]
 8001ea2:	2300      	movs	r3, #0
 8001ea4:	2201      	movs	r2, #1
 8001ea6:	6878      	ldr	r0, [r7, #4]
 8001ea8:	f7ff fddd 	bl	8001a66 <gpio_config_pin>
	gpio_config_pin(port ,s_pin++  ,GPIO_OUT , GPIO_SPEED_LOW , GPIO_NO_PULL,GPIO_PUSHPULL) ;//r4  0
 8001eac:	6839      	ldr	r1, [r7, #0]
 8001eae:	1c4b      	adds	r3, r1, #1
 8001eb0:	603b      	str	r3, [r7, #0]
 8001eb2:	2300      	movs	r3, #0
 8001eb4:	9301      	str	r3, [sp, #4]
 8001eb6:	2300      	movs	r3, #0
 8001eb8:	9300      	str	r3, [sp, #0]
 8001eba:	2300      	movs	r3, #0
 8001ebc:	2201      	movs	r2, #1
 8001ebe:	6878      	ldr	r0, [r7, #4]
 8001ec0:	f7ff fdd1 	bl	8001a66 <gpio_config_pin>
	//configure the pins as Intput with pull-up
	gpio_config_pin(port ,s_pin++ ,GPIO_IN , GPIO_SPEED_LOW , GPIO_PULL_UP,GPIO_PUSHPULL) ;  //C1  1
 8001ec4:	6839      	ldr	r1, [r7, #0]
 8001ec6:	1c4b      	adds	r3, r1, #1
 8001ec8:	603b      	str	r3, [r7, #0]
 8001eca:	2300      	movs	r3, #0
 8001ecc:	9301      	str	r3, [sp, #4]
 8001ece:	2301      	movs	r3, #1
 8001ed0:	9300      	str	r3, [sp, #0]
 8001ed2:	2300      	movs	r3, #0
 8001ed4:	2200      	movs	r2, #0
 8001ed6:	6878      	ldr	r0, [r7, #4]
 8001ed8:	f7ff fdc5 	bl	8001a66 <gpio_config_pin>
	gpio_config_pin(port ,s_pin++ ,GPIO_IN , GPIO_SPEED_LOW , GPIO_PULL_UP,GPIO_PUSHPULL) ;  //C2  0
 8001edc:	6839      	ldr	r1, [r7, #0]
 8001ede:	1c4b      	adds	r3, r1, #1
 8001ee0:	603b      	str	r3, [r7, #0]
 8001ee2:	2300      	movs	r3, #0
 8001ee4:	9301      	str	r3, [sp, #4]
 8001ee6:	2301      	movs	r3, #1
 8001ee8:	9300      	str	r3, [sp, #0]
 8001eea:	2300      	movs	r3, #0
 8001eec:	2200      	movs	r2, #0
 8001eee:	6878      	ldr	r0, [r7, #4]
 8001ef0:	f7ff fdb9 	bl	8001a66 <gpio_config_pin>
	gpio_config_pin(port ,s_pin++ ,GPIO_IN , GPIO_SPEED_LOW , GPIO_PULL_UP,GPIO_PUSHPULL) ;  //C3  1
 8001ef4:	6839      	ldr	r1, [r7, #0]
 8001ef6:	1c4b      	adds	r3, r1, #1
 8001ef8:	603b      	str	r3, [r7, #0]
 8001efa:	2300      	movs	r3, #0
 8001efc:	9301      	str	r3, [sp, #4]
 8001efe:	2301      	movs	r3, #1
 8001f00:	9300      	str	r3, [sp, #0]
 8001f02:	2300      	movs	r3, #0
 8001f04:	2200      	movs	r2, #0
 8001f06:	6878      	ldr	r0, [r7, #4]
 8001f08:	f7ff fdad 	bl	8001a66 <gpio_config_pin>
	gpio_config_pin(port ,s_pin++ ,GPIO_IN , GPIO_SPEED_LOW , GPIO_PULL_UP,GPIO_PUSHPULL) ;  //C4  1
 8001f0c:	6839      	ldr	r1, [r7, #0]
 8001f0e:	1c4b      	adds	r3, r1, #1
 8001f10:	603b      	str	r3, [r7, #0]
 8001f12:	2300      	movs	r3, #0
 8001f14:	9301      	str	r3, [sp, #4]
 8001f16:	2301      	movs	r3, #1
 8001f18:	9300      	str	r3, [sp, #0]
 8001f1a:	2300      	movs	r3, #0
 8001f1c:	2200      	movs	r2, #0
 8001f1e:	6878      	ldr	r0, [r7, #4]
 8001f20:	f7ff fda1 	bl	8001a66 <gpio_config_pin>
}
 8001f24:	bf00      	nop
 8001f26:	3708      	adds	r7, #8
 8001f28:	46bd      	mov	sp, r7
 8001f2a:	bd80      	pop	{r7, pc}

08001f2c <keypad_inverse_pin_direction>:
 * The reset_io() function is used to reset the pin direction and configuration of the specified port.
 * The s_pin argument is used to specify the starting pin number for the keypad pins on the specified port.
 * This is likely to be used in a keypad driver to configure the keypad pins and read keypad input.
 */
static void keypad_inverse_pin_direction( GPIO_TypeDef * port , int s_pin)
{
 8001f2c:	b580      	push	{r7, lr}
 8001f2e:	b084      	sub	sp, #16
 8001f30:	af02      	add	r7, sp, #8
 8001f32:	6078      	str	r0, [r7, #4]
 8001f34:	6039      	str	r1, [r7, #0]
	reset_io(port) ;
 8001f36:	6878      	ldr	r0, [r7, #4]
 8001f38:	f7ff fd80 	bl	8001a3c <reset_io>
	//configure the pins as Intput with pull-down
	gpio_config_pin(port ,s_pin++  ,GPIO_IN , GPIO_SPEED_LOW , GPIO_PULL_DOWN,GPIO_PUSHPULL) ;//R1     0
 8001f3c:	6839      	ldr	r1, [r7, #0]
 8001f3e:	1c4b      	adds	r3, r1, #1
 8001f40:	603b      	str	r3, [r7, #0]
 8001f42:	2300      	movs	r3, #0
 8001f44:	9301      	str	r3, [sp, #4]
 8001f46:	2302      	movs	r3, #2
 8001f48:	9300      	str	r3, [sp, #0]
 8001f4a:	2300      	movs	r3, #0
 8001f4c:	2200      	movs	r2, #0
 8001f4e:	6878      	ldr	r0, [r7, #4]
 8001f50:	f7ff fd89 	bl	8001a66 <gpio_config_pin>
	gpio_config_pin(port ,s_pin++  ,GPIO_IN , GPIO_SPEED_LOW , GPIO_PULL_DOWN,GPIO_PUSHPULL) ;//R2     1
 8001f54:	6839      	ldr	r1, [r7, #0]
 8001f56:	1c4b      	adds	r3, r1, #1
 8001f58:	603b      	str	r3, [r7, #0]
 8001f5a:	2300      	movs	r3, #0
 8001f5c:	9301      	str	r3, [sp, #4]
 8001f5e:	2302      	movs	r3, #2
 8001f60:	9300      	str	r3, [sp, #0]
 8001f62:	2300      	movs	r3, #0
 8001f64:	2200      	movs	r2, #0
 8001f66:	6878      	ldr	r0, [r7, #4]
 8001f68:	f7ff fd7d 	bl	8001a66 <gpio_config_pin>
	gpio_config_pin(port ,s_pin++  ,GPIO_IN , GPIO_SPEED_LOW , GPIO_PULL_DOWN,GPIO_PUSHPULL) ;//R3     1
 8001f6c:	6839      	ldr	r1, [r7, #0]
 8001f6e:	1c4b      	adds	r3, r1, #1
 8001f70:	603b      	str	r3, [r7, #0]
 8001f72:	2300      	movs	r3, #0
 8001f74:	9301      	str	r3, [sp, #4]
 8001f76:	2302      	movs	r3, #2
 8001f78:	9300      	str	r3, [sp, #0]
 8001f7a:	2300      	movs	r3, #0
 8001f7c:	2200      	movs	r2, #0
 8001f7e:	6878      	ldr	r0, [r7, #4]
 8001f80:	f7ff fd71 	bl	8001a66 <gpio_config_pin>
	gpio_config_pin(port ,s_pin++ ,GPIO_IN  , GPIO_SPEED_LOW , GPIO_PULL_DOWN,GPIO_PUSHPULL) ;//R4     1
 8001f84:	6839      	ldr	r1, [r7, #0]
 8001f86:	1c4b      	adds	r3, r1, #1
 8001f88:	603b      	str	r3, [r7, #0]
 8001f8a:	2300      	movs	r3, #0
 8001f8c:	9301      	str	r3, [sp, #4]
 8001f8e:	2302      	movs	r3, #2
 8001f90:	9300      	str	r3, [sp, #0]
 8001f92:	2300      	movs	r3, #0
 8001f94:	2200      	movs	r2, #0
 8001f96:	6878      	ldr	r0, [r7, #4]
 8001f98:	f7ff fd65 	bl	8001a66 <gpio_config_pin>
	//configure the pins as Output with no pull
	gpio_config_pin(port ,s_pin++ ,GPIO_OUT , GPIO_SPEED_LOW , GPIO_NO_PULL,GPIO_PUSHPULL) ;  //C1     0
 8001f9c:	6839      	ldr	r1, [r7, #0]
 8001f9e:	1c4b      	adds	r3, r1, #1
 8001fa0:	603b      	str	r3, [r7, #0]
 8001fa2:	2300      	movs	r3, #0
 8001fa4:	9301      	str	r3, [sp, #4]
 8001fa6:	2300      	movs	r3, #0
 8001fa8:	9300      	str	r3, [sp, #0]
 8001faa:	2300      	movs	r3, #0
 8001fac:	2201      	movs	r2, #1
 8001fae:	6878      	ldr	r0, [r7, #4]
 8001fb0:	f7ff fd59 	bl	8001a66 <gpio_config_pin>
	gpio_config_pin(port ,s_pin++ ,GPIO_OUT , GPIO_SPEED_LOW , GPIO_NO_PULL,GPIO_PUSHPULL) ;  //C2     1
 8001fb4:	6839      	ldr	r1, [r7, #0]
 8001fb6:	1c4b      	adds	r3, r1, #1
 8001fb8:	603b      	str	r3, [r7, #0]
 8001fba:	2300      	movs	r3, #0
 8001fbc:	9301      	str	r3, [sp, #4]
 8001fbe:	2300      	movs	r3, #0
 8001fc0:	9300      	str	r3, [sp, #0]
 8001fc2:	2300      	movs	r3, #0
 8001fc4:	2201      	movs	r2, #1
 8001fc6:	6878      	ldr	r0, [r7, #4]
 8001fc8:	f7ff fd4d 	bl	8001a66 <gpio_config_pin>
	gpio_config_pin(port ,s_pin++ ,GPIO_OUT , GPIO_SPEED_LOW , GPIO_NO_PULL,GPIO_PUSHPULL) ;  //C3     0
 8001fcc:	6839      	ldr	r1, [r7, #0]
 8001fce:	1c4b      	adds	r3, r1, #1
 8001fd0:	603b      	str	r3, [r7, #0]
 8001fd2:	2300      	movs	r3, #0
 8001fd4:	9301      	str	r3, [sp, #4]
 8001fd6:	2300      	movs	r3, #0
 8001fd8:	9300      	str	r3, [sp, #0]
 8001fda:	2300      	movs	r3, #0
 8001fdc:	2201      	movs	r2, #1
 8001fde:	6878      	ldr	r0, [r7, #4]
 8001fe0:	f7ff fd41 	bl	8001a66 <gpio_config_pin>
	gpio_config_pin(port ,s_pin++ ,GPIO_OUT , GPIO_SPEED_LOW , GPIO_NO_PULL,GPIO_PUSHPULL) ;  //C4     0
 8001fe4:	6839      	ldr	r1, [r7, #0]
 8001fe6:	1c4b      	adds	r3, r1, #1
 8001fe8:	603b      	str	r3, [r7, #0]
 8001fea:	2300      	movs	r3, #0
 8001fec:	9301      	str	r3, [sp, #4]
 8001fee:	2300      	movs	r3, #0
 8001ff0:	9300      	str	r3, [sp, #0]
 8001ff2:	2300      	movs	r3, #0
 8001ff4:	2201      	movs	r2, #1
 8001ff6:	6878      	ldr	r0, [r7, #4]
 8001ff8:	f7ff fd35 	bl	8001a66 <gpio_config_pin>

}
 8001ffc:	bf00      	nop
 8001ffe:	3708      	adds	r7, #8
 8002000:	46bd      	mov	sp, r7
 8002002:	bd80      	pop	{r7, pc}

08002004 <keypad_get_pressedkey>:
 * The function then returns the value of the pressed key, or 0 if no key was pressed.
 * Overall, this function uses a combination of bit shifting, bit masking and loops to read the state of the keypad and determine which key is pressed.
 * The function is not very readable and could be improved by adding more comments and breaking it down into smaller functions for better readability and maintainability.
 */
	char keypad_get_pressedkey()
					{
 8002004:	b580      	push	{r7, lr}
 8002006:	b086      	sub	sp, #24
 8002008:	af00      	add	r7, sp, #0
					    uint16_t porte = 0;   // Set a variable to store the state of the GPIOC pins
 800200a:	2300      	movs	r3, #0
 800200c:	817b      	strh	r3, [r7, #10]
					    porte = GPIOC->IDR ; /* IDR is a register of the GPIOC that contains the input states of the pins.
 800200e:	4b51      	ldr	r3, [pc, #324]	; (8002154 <keypad_get_pressedkey+0x150>)
 8002010:	691b      	ldr	r3, [r3, #16]
 8002012:	817b      	strh	r3, [r7, #10]
					                            * We can read the whole pin status of the GPIOC port with the IDR register.
					                            */
					    uint8_t  eidr  = 0;  // Set a variable to store the state of the 8 keypad pins
 8002014:	2300      	movs	r3, #0
 8002016:	727b      	strb	r3, [r7, #9]
					    uint8_t  ch    = 0;
 8002018:	2300      	movs	r3, #0
 800201a:	723b      	strb	r3, [r7, #8]
					    char ret = 0 ;
 800201c:	2300      	movs	r3, #0
 800201e:	75fb      	strb	r3, [r7, #23]

					    // Check the current state of the keypad
					    switch(state)
 8002020:	4b4d      	ldr	r3, [pc, #308]	; (8002158 <keypad_get_pressedkey+0x154>)
 8002022:	781b      	ldrb	r3, [r3, #0]
 8002024:	2b02      	cmp	r3, #2
 8002026:	f000 8087 	beq.w	8002138 <keypad_get_pressedkey+0x134>
 800202a:	2b02      	cmp	r3, #2
 800202c:	f300 8088 	bgt.w	8002140 <keypad_get_pressedkey+0x13c>
 8002030:	2b00      	cmp	r3, #0
 8002032:	d002      	beq.n	800203a <keypad_get_pressedkey+0x36>
 8002034:	2b01      	cmp	r3, #1
 8002036:	d072      	beq.n	800211e <keypad_get_pressedkey+0x11a>

				state = State_free ;
				break ;
			}
		default :
			break ;
 8002038:	e082      	b.n	8002140 <keypad_get_pressedkey+0x13c>
					                eidr = (porte >> start_pin) ; // Get the state of the keypad pins
 800203a:	897a      	ldrh	r2, [r7, #10]
 800203c:	4b47      	ldr	r3, [pc, #284]	; (800215c <keypad_get_pressedkey+0x158>)
 800203e:	681b      	ldr	r3, [r3, #0]
 8002040:	fa42 f303 	asr.w	r3, r2, r3
 8002044:	727b      	strb	r3, [r7, #9]
					                if(eidr != DEFAULT_KEYPAD_PORT_INP) // If the value is different than the default input state
 8002046:	7a7b      	ldrb	r3, [r7, #9]
 8002048:	2bf0      	cmp	r3, #240	; 0xf0
 800204a:	d07b      	beq.n	8002144 <keypad_get_pressedkey+0x140>
					                    ch = ~eidr; // Set the inverse of eidr in ch
 800204c:	7a7b      	ldrb	r3, [r7, #9]
 800204e:	43db      	mvns	r3, r3
 8002050:	723b      	strb	r3, [r7, #8]
					                    ch = ch & DEFAULT_KEYPAD_PORT_INP; // Get the row of the pressed key
 8002052:	7a3b      	ldrb	r3, [r7, #8]
 8002054:	f023 030f 	bic.w	r3, r3, #15
 8002058:	723b      	strb	r3, [r7, #8]
					                    keypad_inverse_pin_direction(keypad_port ,start_pin ) ;
 800205a:	4b41      	ldr	r3, [pc, #260]	; (8002160 <keypad_get_pressedkey+0x15c>)
 800205c:	681b      	ldr	r3, [r3, #0]
 800205e:	4a3f      	ldr	r2, [pc, #252]	; (800215c <keypad_get_pressedkey+0x158>)
 8002060:	6812      	ldr	r2, [r2, #0]
 8002062:	4611      	mov	r1, r2
 8002064:	4618      	mov	r0, r3
 8002066:	f7ff ff61 	bl	8001f2c <keypad_inverse_pin_direction>
					uint16_t out = (ch << start_pin) ;  //
 800206a:	7a3a      	ldrb	r2, [r7, #8]
 800206c:	4b3b      	ldr	r3, [pc, #236]	; (800215c <keypad_get_pressedkey+0x158>)
 800206e:	681b      	ldr	r3, [r3, #0]
 8002070:	fa02 f303 	lsl.w	r3, r2, r3
 8002074:	80fb      	strh	r3, [r7, #6]
					keypad_port->ODR = out ;
 8002076:	4b3a      	ldr	r3, [pc, #232]	; (8002160 <keypad_get_pressedkey+0x15c>)
 8002078:	681b      	ldr	r3, [r3, #0]
 800207a:	88fa      	ldrh	r2, [r7, #6]
 800207c:	615a      	str	r2, [r3, #20]
					delay_ms(1) ;
 800207e:	2001      	movs	r0, #1
 8002080:	f7ff f84e 	bl	8001120 <delay_ms>
					porte = keypad_port->IDR ;//get the state of input port
 8002084:	4b36      	ldr	r3, [pc, #216]	; (8002160 <keypad_get_pressedkey+0x15c>)
 8002086:	681b      	ldr	r3, [r3, #0]
 8002088:	691b      	ldr	r3, [r3, #16]
 800208a:	817b      	strh	r3, [r7, #10]
					eidr = (porte >> start_pin) ;//& 0xff ; //get the state of keypad pins
 800208c:	897a      	ldrh	r2, [r7, #10]
 800208e:	4b33      	ldr	r3, [pc, #204]	; (800215c <keypad_get_pressedkey+0x158>)
 8002090:	681b      	ldr	r3, [r3, #0]
 8002092:	fa42 f303 	asr.w	r3, r2, r3
 8002096:	727b      	strb	r3, [r7, #9]
					int col = 0 ;
 8002098:	2300      	movs	r3, #0
 800209a:	613b      	str	r3, [r7, #16]
					for(col = 0 ; col <4 ; col++)
 800209c:	2300      	movs	r3, #0
 800209e:	613b      	str	r3, [r7, #16]
 80020a0:	e00d      	b.n	80020be <keypad_get_pressedkey+0xba>
						if(   (((eidr & 0xf0) >> 4) &  (1<<col)) != 0 )
 80020a2:	7a7b      	ldrb	r3, [r7, #9]
 80020a4:	091b      	lsrs	r3, r3, #4
 80020a6:	b2db      	uxtb	r3, r3
 80020a8:	461a      	mov	r2, r3
 80020aa:	693b      	ldr	r3, [r7, #16]
 80020ac:	fa42 f303 	asr.w	r3, r2, r3
 80020b0:	f003 0301 	and.w	r3, r3, #1
 80020b4:	2b00      	cmp	r3, #0
 80020b6:	d106      	bne.n	80020c6 <keypad_get_pressedkey+0xc2>
					for(col = 0 ; col <4 ; col++)
 80020b8:	693b      	ldr	r3, [r7, #16]
 80020ba:	3301      	adds	r3, #1
 80020bc:	613b      	str	r3, [r7, #16]
 80020be:	693b      	ldr	r3, [r7, #16]
 80020c0:	2b03      	cmp	r3, #3
 80020c2:	ddee      	ble.n	80020a2 <keypad_get_pressedkey+0x9e>
 80020c4:	e000      	b.n	80020c8 <keypad_get_pressedkey+0xc4>
							break ;
 80020c6:	bf00      	nop
					int row = 0 ;
 80020c8:	2300      	movs	r3, #0
 80020ca:	60fb      	str	r3, [r7, #12]
					for(row = 0 ; row <4 ; row++)
 80020cc:	2300      	movs	r3, #0
 80020ce:	60fb      	str	r3, [r7, #12]
 80020d0:	e00c      	b.n	80020ec <keypad_get_pressedkey+0xe8>
						if( ((eidr & 0x0f) & (1<<row)) != 0)
 80020d2:	7a7b      	ldrb	r3, [r7, #9]
 80020d4:	f003 020f 	and.w	r2, r3, #15
 80020d8:	68fb      	ldr	r3, [r7, #12]
 80020da:	fa42 f303 	asr.w	r3, r2, r3
 80020de:	f003 0301 	and.w	r3, r3, #1
 80020e2:	2b00      	cmp	r3, #0
 80020e4:	d106      	bne.n	80020f4 <keypad_get_pressedkey+0xf0>
					for(row = 0 ; row <4 ; row++)
 80020e6:	68fb      	ldr	r3, [r7, #12]
 80020e8:	3301      	adds	r3, #1
 80020ea:	60fb      	str	r3, [r7, #12]
 80020ec:	68fb      	ldr	r3, [r7, #12]
 80020ee:	2b03      	cmp	r3, #3
 80020f0:	ddef      	ble.n	80020d2 <keypad_get_pressedkey+0xce>
 80020f2:	e000      	b.n	80020f6 <keypad_get_pressedkey+0xf2>
							break ;
 80020f4:	bf00      	nop
					ret = keys[row][col] ;
 80020f6:	4a1b      	ldr	r2, [pc, #108]	; (8002164 <keypad_get_pressedkey+0x160>)
 80020f8:	68fb      	ldr	r3, [r7, #12]
 80020fa:	009b      	lsls	r3, r3, #2
 80020fc:	441a      	add	r2, r3
 80020fe:	693b      	ldr	r3, [r7, #16]
 8002100:	4413      	add	r3, r2
 8002102:	781b      	ldrb	r3, [r3, #0]
 8002104:	75fb      	strb	r3, [r7, #23]
					keypad_config_key_direction(keypad_port ,start_pin ) ;
 8002106:	4b16      	ldr	r3, [pc, #88]	; (8002160 <keypad_get_pressedkey+0x15c>)
 8002108:	681b      	ldr	r3, [r3, #0]
 800210a:	4a14      	ldr	r2, [pc, #80]	; (800215c <keypad_get_pressedkey+0x158>)
 800210c:	6812      	ldr	r2, [r2, #0]
 800210e:	4611      	mov	r1, r2
 8002110:	4618      	mov	r0, r3
 8002112:	f7ff fe9f 	bl	8001e54 <keypad_config_key_direction>
					state = State_key_pressed ;
 8002116:	4b10      	ldr	r3, [pc, #64]	; (8002158 <keypad_get_pressedkey+0x154>)
 8002118:	2201      	movs	r2, #1
 800211a:	701a      	strb	r2, [r3, #0]
				break ;
 800211c:	e012      	b.n	8002144 <keypad_get_pressedkey+0x140>
				eidr = (porte >> start_pin) & 0xff ;
 800211e:	897a      	ldrh	r2, [r7, #10]
 8002120:	4b0e      	ldr	r3, [pc, #56]	; (800215c <keypad_get_pressedkey+0x158>)
 8002122:	681b      	ldr	r3, [r3, #0]
 8002124:	fa42 f303 	asr.w	r3, r2, r3
 8002128:	727b      	strb	r3, [r7, #9]
				if(eidr == DEFAULT_KEYPAD_PORT_INP)
 800212a:	7a7b      	ldrb	r3, [r7, #9]
 800212c:	2bf0      	cmp	r3, #240	; 0xf0
 800212e:	d10b      	bne.n	8002148 <keypad_get_pressedkey+0x144>
					state = State_key_released ;
 8002130:	4b09      	ldr	r3, [pc, #36]	; (8002158 <keypad_get_pressedkey+0x154>)
 8002132:	2202      	movs	r2, #2
 8002134:	701a      	strb	r2, [r3, #0]
				break ;
 8002136:	e007      	b.n	8002148 <keypad_get_pressedkey+0x144>
				state = State_free ;
 8002138:	4b07      	ldr	r3, [pc, #28]	; (8002158 <keypad_get_pressedkey+0x154>)
 800213a:	2200      	movs	r2, #0
 800213c:	701a      	strb	r2, [r3, #0]
				break ;
 800213e:	e004      	b.n	800214a <keypad_get_pressedkey+0x146>
			break ;
 8002140:	bf00      	nop
 8002142:	e002      	b.n	800214a <keypad_get_pressedkey+0x146>
				break ;
 8002144:	bf00      	nop
 8002146:	e000      	b.n	800214a <keypad_get_pressedkey+0x146>
				break ;
 8002148:	bf00      	nop

	}


	return ret ;
 800214a:	7dfb      	ldrb	r3, [r7, #23]
}
 800214c:	4618      	mov	r0, r3
 800214e:	3718      	adds	r7, #24
 8002150:	46bd      	mov	sp, r7
 8002152:	bd80      	pop	{r7, pc}
 8002154:	48000800 	.word	0x48000800
 8002158:	20000d60 	.word	0x20000d60
 800215c:	20000d5c 	.word	0x20000d5c
 8002160:	20000d58 	.word	0x20000d58
 8002164:	20000068 	.word	0x20000068

08002168 <rtc_write_reg>:
 * - The register to write the data to (a uint8_t)
 * - The data to be written (a uint8_t)
 * - the lenght of the data to be written (an int)
 */
static void rtc_write_reg(uint8_t address ,uint8_t reg , uint8_t  data , int len)
{
 8002168:	b580      	push	{r7, lr}
 800216a:	b084      	sub	sp, #16
 800216c:	af00      	add	r7, sp, #0
 800216e:	603b      	str	r3, [r7, #0]
 8002170:	4603      	mov	r3, r0
 8002172:	71fb      	strb	r3, [r7, #7]
 8002174:	460b      	mov	r3, r1
 8002176:	71bb      	strb	r3, [r7, #6]
 8002178:	4613      	mov	r3, r2
 800217a:	717b      	strb	r3, [r7, #5]
    // Declare a temporary array of 2 elements
    uint8_t tmp[2] ;

    // Assign the value of the register to the first element of the temporary array
    tmp[0]  = reg ;
 800217c:	79bb      	ldrb	r3, [r7, #6]
 800217e:	733b      	strb	r3, [r7, #12]
    // Assign the value of the data to the second element of the temporary array
    tmp[1]  = data ;
 8002180:	797b      	ldrb	r3, [r7, #5]
 8002182:	737b      	strb	r3, [r7, #13]

    // Call the I2C_Write function to send the data in the temporary array to the RTC device at the specified address on the I2C bus.
    I2C_Write(rtc_i2c , address , tmp ,2 ) ;
 8002184:	4b05      	ldr	r3, [pc, #20]	; (800219c <rtc_write_reg+0x34>)
 8002186:	6818      	ldr	r0, [r3, #0]
 8002188:	f107 020c 	add.w	r2, r7, #12
 800218c:	79f9      	ldrb	r1, [r7, #7]
 800218e:	2302      	movs	r3, #2
 8002190:	f7ff fdb2 	bl	8001cf8 <I2C_Write>
}
 8002194:	bf00      	nop
 8002196:	3710      	adds	r7, #16
 8002198:	46bd      	mov	sp, r7
 800219a:	bd80      	pop	{r7, pc}
 800219c:	20000d64 	.word	0x20000d64

080021a0 <rtc_init>:
 * This allows the other functions of the RTC driver to use the same I2C peripheral without having to pass it as a parameter every time.
 * It assigns the passed I2C peripheral to a global variable so that the same peripheral can be used by other functions
 *  without having to pass it as a parameter every time.
 */
void rtc_init(I2C_TypeDef * dev)
{
 80021a0:	b480      	push	{r7}
 80021a2:	b083      	sub	sp, #12
 80021a4:	af00      	add	r7, sp, #0
 80021a6:	6078      	str	r0, [r7, #4]
    // Assign the passed I2C peripheral to a global variable
    rtc_i2c = dev ;
 80021a8:	4a03      	ldr	r2, [pc, #12]	; (80021b8 <rtc_init+0x18>)
 80021aa:	687b      	ldr	r3, [r7, #4]
 80021ac:	6013      	str	r3, [r2, #0]
}
 80021ae:	bf00      	nop
 80021b0:	370c      	adds	r7, #12
 80021b2:	46bd      	mov	sp, r7
 80021b4:	bc80      	pop	{r7}
 80021b6:	4770      	bx	lr
 80021b8:	20000d64 	.word	0x20000d64

080021bc <rtc_get_reg>:
 * This function retrieves the value of a specified register from the RTC (Real-time clock) device.
 * The function takes in one parameter:
 * - The address of the register (uint8_t)
 */
uint8_t rtc_get_reg(uint8_t reg)
{
 80021bc:	b580      	push	{r7, lr}
 80021be:	b084      	sub	sp, #16
 80021c0:	af00      	add	r7, sp, #0
 80021c2:	4603      	mov	r3, r0
 80021c4:	71fb      	strb	r3, [r7, #7]
    // Declare a variable to hold the value of the register
    uint8_t val ;

    // Send the register address to the RTC device
    I2C_Write(rtc_i2c , RTC_I2C_ADDR , &reg  , 1) ;
 80021c6:	4b0b      	ldr	r3, [pc, #44]	; (80021f4 <rtc_get_reg+0x38>)
 80021c8:	6818      	ldr	r0, [r3, #0]
 80021ca:	1dfa      	adds	r2, r7, #7
 80021cc:	2301      	movs	r3, #1
 80021ce:	2168      	movs	r1, #104	; 0x68
 80021d0:	f7ff fd92 	bl	8001cf8 <I2C_Write>

    // Wait for 2ms
    delay_ms(2);
 80021d4:	2002      	movs	r0, #2
 80021d6:	f7fe ffa3 	bl	8001120 <delay_ms>

    // Read the value of the register from the RTC device
    I2C_Read(rtc_i2c  , RTC_I2C_ADDR , &val , 1) ;
 80021da:	4b06      	ldr	r3, [pc, #24]	; (80021f4 <rtc_get_reg+0x38>)
 80021dc:	6818      	ldr	r0, [r3, #0]
 80021de:	f107 020f 	add.w	r2, r7, #15
 80021e2:	2301      	movs	r3, #1
 80021e4:	2168      	movs	r1, #104	; 0x68
 80021e6:	f7ff fdd0 	bl	8001d8a <I2C_Read>

    // Return the value of the register
    return val ;
 80021ea:	7bfb      	ldrb	r3, [r7, #15]
}
 80021ec:	4618      	mov	r0, r3
 80021ee:	3710      	adds	r7, #16
 80021f0:	46bd      	mov	sp, r7
 80021f2:	bd80      	pop	{r7, pc}
 80021f4:	20000d64 	.word	0x20000d64

080021f8 <rtc_get_time>:
 * If it is in 12 hour mode, it also checks the AM/PM bit using the RTC_AM_PM_BIT_MASK and stores the value in the "am_pm" field of the struct.
 * After all values are stored, the function returns the struct.
*/

void rtc_get_time(rtc_time_t * rtc_time )
{
 80021f8:	b580      	push	{r7, lr}
 80021fa:	b084      	sub	sp, #16
 80021fc:	af00      	add	r7, sp, #0
 80021fe:	6078      	str	r0, [r7, #4]
	uint8_t tmp = rtc_get_reg(RTC_REG_SECOND) ;
 8002200:	2000      	movs	r0, #0
 8002202:	f7ff ffdb 	bl	80021bc <rtc_get_reg>
 8002206:	4603      	mov	r3, r0
 8002208:	73fb      	strb	r3, [r7, #15]
	tm = tmp ;
 800220a:	4a38      	ldr	r2, [pc, #224]	; (80022ec <rtc_get_time+0xf4>)
 800220c:	7bfb      	ldrb	r3, [r7, #15]
 800220e:	7013      	strb	r3, [r2, #0]
	//BCD --> DEC
	rtc_time->sec  = ((tmp >> 4) & 0x0f) * 10 + (tmp & 0x0f) ;
 8002210:	7bfb      	ldrb	r3, [r7, #15]
 8002212:	091b      	lsrs	r3, r3, #4
 8002214:	b2db      	uxtb	r3, r3
 8002216:	461a      	mov	r2, r3
 8002218:	0092      	lsls	r2, r2, #2
 800221a:	4413      	add	r3, r2
 800221c:	005b      	lsls	r3, r3, #1
 800221e:	b2da      	uxtb	r2, r3
 8002220:	7bfb      	ldrb	r3, [r7, #15]
 8002222:	f003 030f 	and.w	r3, r3, #15
 8002226:	b2db      	uxtb	r3, r3
 8002228:	4413      	add	r3, r2
 800222a:	b2da      	uxtb	r2, r3
 800222c:	687b      	ldr	r3, [r7, #4]
 800222e:	701a      	strb	r2, [r3, #0]

	tmp = rtc_get_reg(RTC_REG_MINUTE) ;
 8002230:	2001      	movs	r0, #1
 8002232:	f7ff ffc3 	bl	80021bc <rtc_get_reg>
 8002236:	4603      	mov	r3, r0
 8002238:	73fb      	strb	r3, [r7, #15]
	//BCD --> DEC
	rtc_time->min  = ((tmp >> 4) & 0x0f) * 10 + (tmp & 0x0f) ;
 800223a:	7bfb      	ldrb	r3, [r7, #15]
 800223c:	091b      	lsrs	r3, r3, #4
 800223e:	b2db      	uxtb	r3, r3
 8002240:	461a      	mov	r2, r3
 8002242:	0092      	lsls	r2, r2, #2
 8002244:	4413      	add	r3, r2
 8002246:	005b      	lsls	r3, r3, #1
 8002248:	b2da      	uxtb	r2, r3
 800224a:	7bfb      	ldrb	r3, [r7, #15]
 800224c:	f003 030f 	and.w	r3, r3, #15
 8002250:	b2db      	uxtb	r3, r3
 8002252:	4413      	add	r3, r2
 8002254:	b2da      	uxtb	r2, r3
 8002256:	687b      	ldr	r3, [r7, #4]
 8002258:	705a      	strb	r2, [r3, #1]

	tmp = rtc_get_reg(RTC_REG_HOUR) ;
 800225a:	2002      	movs	r0, #2
 800225c:	f7ff ffae 	bl	80021bc <rtc_get_reg>
 8002260:	4603      	mov	r3, r0
 8002262:	73fb      	strb	r3, [r7, #15]


	if( (tmp & RTC_BIT_MODE_MASK) != 0)
 8002264:	7bfb      	ldrb	r3, [r7, #15]
 8002266:	f003 0340 	and.w	r3, r3, #64	; 0x40
 800226a:	2b00      	cmp	r3, #0
 800226c:	d022      	beq.n	80022b4 <rtc_get_time+0xbc>
	{
		//12 hour mode
		rtc_time->mode = H_12 ;
 800226e:	687b      	ldr	r3, [r7, #4]
 8002270:	2201      	movs	r2, #1
 8002272:	70da      	strb	r2, [r3, #3]
		if((tmp & RTC_AM_PM_BIT_MASK) != 0)
 8002274:	7bfb      	ldrb	r3, [r7, #15]
 8002276:	f003 0320 	and.w	r3, r3, #32
 800227a:	2b00      	cmp	r3, #0
 800227c:	d003      	beq.n	8002286 <rtc_get_time+0x8e>
		{
			rtc_time->am_pm = PM ;
 800227e:	687b      	ldr	r3, [r7, #4]
 8002280:	2201      	movs	r2, #1
 8002282:	711a      	strb	r2, [r3, #4]
 8002284:	e002      	b.n	800228c <rtc_get_time+0x94>
		}
		else{
			rtc_time->am_pm = AM ;
 8002286:	687b      	ldr	r3, [r7, #4]
 8002288:	2200      	movs	r2, #0
 800228a:	711a      	strb	r2, [r3, #4]
		}

		rtc_time->hr = ((tmp & 0x1f) >> 4) * 10 + (tmp & 0x0f) ;
 800228c:	7bfb      	ldrb	r3, [r7, #15]
 800228e:	111b      	asrs	r3, r3, #4
 8002290:	b2db      	uxtb	r3, r3
 8002292:	f003 0301 	and.w	r3, r3, #1
 8002296:	b2db      	uxtb	r3, r3
 8002298:	461a      	mov	r2, r3
 800229a:	0092      	lsls	r2, r2, #2
 800229c:	4413      	add	r3, r2
 800229e:	005b      	lsls	r3, r3, #1
 80022a0:	b2da      	uxtb	r2, r3
 80022a2:	7bfb      	ldrb	r3, [r7, #15]
 80022a4:	f003 030f 	and.w	r3, r3, #15
 80022a8:	b2db      	uxtb	r3, r3
 80022aa:	4413      	add	r3, r2
 80022ac:	b2da      	uxtb	r2, r3
 80022ae:	687b      	ldr	r3, [r7, #4]
 80022b0:	709a      	strb	r2, [r3, #2]
		rtc_time->mode = H_24 ;
		tmp = RTC_24H_MASK & tmp ;
		rtc_time->hr = (tmp >> 4) * 10 + (tmp & 0x0f) ;
	}

}
 80022b2:	e016      	b.n	80022e2 <rtc_get_time+0xea>
		rtc_time->mode = H_24 ;
 80022b4:	687b      	ldr	r3, [r7, #4]
 80022b6:	2200      	movs	r2, #0
 80022b8:	70da      	strb	r2, [r3, #3]
		tmp = RTC_24H_MASK & tmp ;
 80022ba:	7bfb      	ldrb	r3, [r7, #15]
 80022bc:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 80022c0:	73fb      	strb	r3, [r7, #15]
		rtc_time->hr = (tmp >> 4) * 10 + (tmp & 0x0f) ;
 80022c2:	7bfb      	ldrb	r3, [r7, #15]
 80022c4:	091b      	lsrs	r3, r3, #4
 80022c6:	b2db      	uxtb	r3, r3
 80022c8:	461a      	mov	r2, r3
 80022ca:	0092      	lsls	r2, r2, #2
 80022cc:	4413      	add	r3, r2
 80022ce:	005b      	lsls	r3, r3, #1
 80022d0:	b2da      	uxtb	r2, r3
 80022d2:	7bfb      	ldrb	r3, [r7, #15]
 80022d4:	f003 030f 	and.w	r3, r3, #15
 80022d8:	b2db      	uxtb	r3, r3
 80022da:	4413      	add	r3, r2
 80022dc:	b2da      	uxtb	r2, r3
 80022de:	687b      	ldr	r3, [r7, #4]
 80022e0:	709a      	strb	r2, [r3, #2]
}
 80022e2:	bf00      	nop
 80022e4:	3710      	adds	r7, #16
 80022e6:	46bd      	mov	sp, r7
 80022e8:	bd80      	pop	{r7, pc}
 80022ea:	bf00      	nop
 80022ec:	20000d68 	.word	0x20000d68

080022f0 <rtc_set_time>:
 * The function rtc_write_reg is used to write the value to the RTC device,
 * it takes 4 arguments I2C address of RTC, register address of RTC, data value to be written and a flag indicating whether to wait for the write to complete or not.
 * This function is useful for setting the time on an RTC device, which uses I2C protocol. The BCD format is used to represent the time in a more compact form.
*/
void rtc_set_time(rtc_time_t * rtc_time )
{
 80022f0:	b580      	push	{r7, lr}
 80022f2:	b084      	sub	sp, #16
 80022f4:	af00      	add	r7, sp, #0
 80022f6:	6078      	str	r0, [r7, #4]
    // Separate the tens and ones digits of the seconds
    uint8_t high = rtc_time->sec / 10 ;
 80022f8:	687b      	ldr	r3, [r7, #4]
 80022fa:	781b      	ldrb	r3, [r3, #0]
 80022fc:	4a32      	ldr	r2, [pc, #200]	; (80023c8 <rtc_set_time+0xd8>)
 80022fe:	fba2 2303 	umull	r2, r3, r2, r3
 8002302:	08db      	lsrs	r3, r3, #3
 8002304:	73fb      	strb	r3, [r7, #15]
    uint8_t low  = rtc_time->sec % 10 ;
 8002306:	687b      	ldr	r3, [r7, #4]
 8002308:	781a      	ldrb	r2, [r3, #0]
 800230a:	4b2f      	ldr	r3, [pc, #188]	; (80023c8 <rtc_set_time+0xd8>)
 800230c:	fba3 1302 	umull	r1, r3, r3, r2
 8002310:	08d9      	lsrs	r1, r3, #3
 8002312:	460b      	mov	r3, r1
 8002314:	009b      	lsls	r3, r3, #2
 8002316:	440b      	add	r3, r1
 8002318:	005b      	lsls	r3, r3, #1
 800231a:	1ad3      	subs	r3, r2, r3
 800231c:	73bb      	strb	r3, [r7, #14]

    // Concatenate the tens and ones digits to create a BCD value
    uint8_t tmp = (high << 4) | low ;
 800231e:	7bfb      	ldrb	r3, [r7, #15]
 8002320:	011b      	lsls	r3, r3, #4
 8002322:	b25a      	sxtb	r2, r3
 8002324:	f997 300e 	ldrsb.w	r3, [r7, #14]
 8002328:	4313      	orrs	r3, r2
 800232a:	b25b      	sxtb	r3, r3
 800232c:	737b      	strb	r3, [r7, #13]

    // Write the BCD value to the seconds register on the RTC device
    rtc_write_reg( RTC_I2C_ADDR ,RTC_REG_SECOND ,tmp , 1) ;
 800232e:	7b7a      	ldrb	r2, [r7, #13]
 8002330:	2301      	movs	r3, #1
 8002332:	2100      	movs	r1, #0
 8002334:	2068      	movs	r0, #104	; 0x68
 8002336:	f7ff ff17 	bl	8002168 <rtc_write_reg>

    // Repeat the process for the minutes
    high = rtc_time->min / 10 ;
 800233a:	687b      	ldr	r3, [r7, #4]
 800233c:	785b      	ldrb	r3, [r3, #1]
 800233e:	4a22      	ldr	r2, [pc, #136]	; (80023c8 <rtc_set_time+0xd8>)
 8002340:	fba2 2303 	umull	r2, r3, r2, r3
 8002344:	08db      	lsrs	r3, r3, #3
 8002346:	73fb      	strb	r3, [r7, #15]
    low  = rtc_time->min % 10 ;
 8002348:	687b      	ldr	r3, [r7, #4]
 800234a:	785a      	ldrb	r2, [r3, #1]
 800234c:	4b1e      	ldr	r3, [pc, #120]	; (80023c8 <rtc_set_time+0xd8>)
 800234e:	fba3 1302 	umull	r1, r3, r3, r2
 8002352:	08d9      	lsrs	r1, r3, #3
 8002354:	460b      	mov	r3, r1
 8002356:	009b      	lsls	r3, r3, #2
 8002358:	440b      	add	r3, r1
 800235a:	005b      	lsls	r3, r3, #1
 800235c:	1ad3      	subs	r3, r2, r3
 800235e:	73bb      	strb	r3, [r7, #14]
    tmp = (high << 4) | low ;
 8002360:	7bfb      	ldrb	r3, [r7, #15]
 8002362:	011b      	lsls	r3, r3, #4
 8002364:	b25a      	sxtb	r2, r3
 8002366:	f997 300e 	ldrsb.w	r3, [r7, #14]
 800236a:	4313      	orrs	r3, r2
 800236c:	b25b      	sxtb	r3, r3
 800236e:	737b      	strb	r3, [r7, #13]
    rtc_write_reg( RTC_I2C_ADDR ,RTC_REG_MINUTE ,tmp , 1) ;
 8002370:	7b7a      	ldrb	r2, [r7, #13]
 8002372:	2301      	movs	r3, #1
 8002374:	2101      	movs	r1, #1
 8002376:	2068      	movs	r0, #104	; 0x68
 8002378:	f7ff fef6 	bl	8002168 <rtc_write_reg>

    // Repeat the process for the hours
    high = rtc_time->hr / 10 ;
 800237c:	687b      	ldr	r3, [r7, #4]
 800237e:	789b      	ldrb	r3, [r3, #2]
 8002380:	4a11      	ldr	r2, [pc, #68]	; (80023c8 <rtc_set_time+0xd8>)
 8002382:	fba2 2303 	umull	r2, r3, r2, r3
 8002386:	08db      	lsrs	r3, r3, #3
 8002388:	73fb      	strb	r3, [r7, #15]
	low  = rtc_time->hr % 10 ;
 800238a:	687b      	ldr	r3, [r7, #4]
 800238c:	789a      	ldrb	r2, [r3, #2]
 800238e:	4b0e      	ldr	r3, [pc, #56]	; (80023c8 <rtc_set_time+0xd8>)
 8002390:	fba3 1302 	umull	r1, r3, r3, r2
 8002394:	08d9      	lsrs	r1, r3, #3
 8002396:	460b      	mov	r3, r1
 8002398:	009b      	lsls	r3, r3, #2
 800239a:	440b      	add	r3, r1
 800239c:	005b      	lsls	r3, r3, #1
 800239e:	1ad3      	subs	r3, r2, r3
 80023a0:	73bb      	strb	r3, [r7, #14]

	tmp = (high << 4) | low ;
 80023a2:	7bfb      	ldrb	r3, [r7, #15]
 80023a4:	011b      	lsls	r3, r3, #4
 80023a6:	b25a      	sxtb	r2, r3
 80023a8:	f997 300e 	ldrsb.w	r3, [r7, #14]
 80023ac:	4313      	orrs	r3, r2
 80023ae:	b25b      	sxtb	r3, r3
 80023b0:	737b      	strb	r3, [r7, #13]

	rtc_write_reg( RTC_I2C_ADDR ,RTC_REG_HOUR ,tmp , 1) ;
 80023b2:	7b7a      	ldrb	r2, [r7, #13]
 80023b4:	2301      	movs	r3, #1
 80023b6:	2102      	movs	r1, #2
 80023b8:	2068      	movs	r0, #104	; 0x68
 80023ba:	f7ff fed5 	bl	8002168 <rtc_write_reg>

}
 80023be:	bf00      	nop
 80023c0:	3710      	adds	r7, #16
 80023c2:	46bd      	mov	sp, r7
 80023c4:	bd80      	pop	{r7, pc}
 80023c6:	bf00      	nop
 80023c8:	cccccccd 	.word	0xcccccccd

080023cc <rtc_set_date>:
 * The function then repeats the process for the month and year, getting the tens and ones digits, concatenating them to create a BCD value,
 * and writing the BCD value to the month and year registers on the RTC device.
 * his function is useful for setting the date on an RTC device, which uses I2C protocol. The BCD format is used to represent the date in a more compact form.
 */
void rtc_set_date(rtc_date_t *date)
{
 80023cc:	b580      	push	{r7, lr}
 80023ce:	b084      	sub	sp, #16
 80023d0:	af00      	add	r7, sp, #0
 80023d2:	6078      	str	r0, [r7, #4]
    // Separate the tens and ones digits of the day
    uint8_t high = date->day / 10 ;
 80023d4:	687b      	ldr	r3, [r7, #4]
 80023d6:	781b      	ldrb	r3, [r3, #0]
 80023d8:	4a32      	ldr	r2, [pc, #200]	; (80024a4 <rtc_set_date+0xd8>)
 80023da:	fba2 2303 	umull	r2, r3, r2, r3
 80023de:	08db      	lsrs	r3, r3, #3
 80023e0:	73fb      	strb	r3, [r7, #15]
    uint8_t low  = date->day % 10 ;
 80023e2:	687b      	ldr	r3, [r7, #4]
 80023e4:	781a      	ldrb	r2, [r3, #0]
 80023e6:	4b2f      	ldr	r3, [pc, #188]	; (80024a4 <rtc_set_date+0xd8>)
 80023e8:	fba3 1302 	umull	r1, r3, r3, r2
 80023ec:	08d9      	lsrs	r1, r3, #3
 80023ee:	460b      	mov	r3, r1
 80023f0:	009b      	lsls	r3, r3, #2
 80023f2:	440b      	add	r3, r1
 80023f4:	005b      	lsls	r3, r3, #1
 80023f6:	1ad3      	subs	r3, r2, r3
 80023f8:	73bb      	strb	r3, [r7, #14]

    // Concatenate the tens and ones digits to create a BCD value
    uint8_t tmp  = (high << 4 )|low ;
 80023fa:	7bfb      	ldrb	r3, [r7, #15]
 80023fc:	011b      	lsls	r3, r3, #4
 80023fe:	b25a      	sxtb	r2, r3
 8002400:	f997 300e 	ldrsb.w	r3, [r7, #14]
 8002404:	4313      	orrs	r3, r2
 8002406:	b25b      	sxtb	r3, r3
 8002408:	737b      	strb	r3, [r7, #13]

    // Write the BCD value to the day register on the RTC device
    rtc_write_reg( RTC_I2C_ADDR , RTC_REG_DATE ,tmp , 1) ;
 800240a:	7b7a      	ldrb	r2, [r7, #13]
 800240c:	2301      	movs	r3, #1
 800240e:	2104      	movs	r1, #4
 8002410:	2068      	movs	r0, #104	; 0x68
 8002412:	f7ff fea9 	bl	8002168 <rtc_write_reg>

    // Repeat the process for the month
    high = date->month / 10 ;
 8002416:	687b      	ldr	r3, [r7, #4]
 8002418:	785b      	ldrb	r3, [r3, #1]
 800241a:	4a22      	ldr	r2, [pc, #136]	; (80024a4 <rtc_set_date+0xd8>)
 800241c:	fba2 2303 	umull	r2, r3, r2, r3
 8002420:	08db      	lsrs	r3, r3, #3
 8002422:	73fb      	strb	r3, [r7, #15]
    low  = date->month % 10 ;
 8002424:	687b      	ldr	r3, [r7, #4]
 8002426:	785a      	ldrb	r2, [r3, #1]
 8002428:	4b1e      	ldr	r3, [pc, #120]	; (80024a4 <rtc_set_date+0xd8>)
 800242a:	fba3 1302 	umull	r1, r3, r3, r2
 800242e:	08d9      	lsrs	r1, r3, #3
 8002430:	460b      	mov	r3, r1
 8002432:	009b      	lsls	r3, r3, #2
 8002434:	440b      	add	r3, r1
 8002436:	005b      	lsls	r3, r3, #1
 8002438:	1ad3      	subs	r3, r2, r3
 800243a:	73bb      	strb	r3, [r7, #14]
    tmp  = (high << 4 )|low ;
 800243c:	7bfb      	ldrb	r3, [r7, #15]
 800243e:	011b      	lsls	r3, r3, #4
 8002440:	b25a      	sxtb	r2, r3
 8002442:	f997 300e 	ldrsb.w	r3, [r7, #14]
 8002446:	4313      	orrs	r3, r2
 8002448:	b25b      	sxtb	r3, r3
 800244a:	737b      	strb	r3, [r7, #13]
    rtc_write_reg( RTC_I2C_ADDR , RTC_REG_MONTH ,tmp , 1) ;
 800244c:	7b7a      	ldrb	r2, [r7, #13]
 800244e:	2301      	movs	r3, #1
 8002450:	2105      	movs	r1, #5
 8002452:	2068      	movs	r0, #104	; 0x68
 8002454:	f7ff fe88 	bl	8002168 <rtc_write_reg>

    // Repeat the process for the year
    high = date->year / 10 ;
 8002458:	687b      	ldr	r3, [r7, #4]
 800245a:	789b      	ldrb	r3, [r3, #2]
 800245c:	4a11      	ldr	r2, [pc, #68]	; (80024a4 <rtc_set_date+0xd8>)
 800245e:	fba2 2303 	umull	r2, r3, r2, r3
 8002462:	08db      	lsrs	r3, r3, #3
 8002464:	73fb      	strb	r3, [r7, #15]
    low  = date->year % 10 ;
 8002466:	687b      	ldr	r3, [r7, #4]
 8002468:	789a      	ldrb	r2, [r3, #2]
 800246a:	4b0e      	ldr	r3, [pc, #56]	; (80024a4 <rtc_set_date+0xd8>)
 800246c:	fba3 1302 	umull	r1, r3, r3, r2
 8002470:	08d9      	lsrs	r1, r3, #3
 8002472:	460b      	mov	r3, r1
 8002474:	009b      	lsls	r3, r3, #2
 8002476:	440b      	add	r3, r1
 8002478:	005b      	lsls	r3, r3, #1
 800247a:	1ad3      	subs	r3, r2, r3
 800247c:	73bb      	strb	r3, [r7, #14]
    tmp  = (high << 4 )|low ;
 800247e:	7bfb      	ldrb	r3, [r7, #15]
 8002480:	011b      	lsls	r3, r3, #4
 8002482:	b25a      	sxtb	r2, r3
 8002484:	f997 300e 	ldrsb.w	r3, [r7, #14]
 8002488:	4313      	orrs	r3, r2
 800248a:	b25b      	sxtb	r3, r3
 800248c:	737b      	strb	r3, [r7, #13]
    rtc_write_reg( RTC_I2C_ADDR , RTC_REG_YEAR ,tmp , 1) ;
 800248e:	7b7a      	ldrb	r2, [r7, #13]
 8002490:	2301      	movs	r3, #1
 8002492:	2106      	movs	r1, #6
 8002494:	2068      	movs	r0, #104	; 0x68
 8002496:	f7ff fe67 	bl	8002168 <rtc_write_reg>
}
 800249a:	bf00      	nop
 800249c:	3710      	adds	r7, #16
 800249e:	46bd      	mov	sp, r7
 80024a0:	bd80      	pop	{r7, pc}
 80024a2:	bf00      	nop
 80024a4:	cccccccd 	.word	0xcccccccd

080024a8 <rtc_get_date>:
 * The function then reads the month register from the RTC device and clears the century bit by ANDing it with 0x7f.
 * It then extracts the tens and ones digits of the month from the BCD value in the same way as the day.
 * Finally, the function reads the year register from the RTC device and extracts the tens and ones digits of the year from the BCD value using bitwise operations.
 */
void rtc_get_date(rtc_date_t * date)
{
 80024a8:	b580      	push	{r7, lr}
 80024aa:	b084      	sub	sp, #16
 80024ac:	af00      	add	r7, sp, #0
 80024ae:	6078      	str	r0, [r7, #4]
    // Read the date register from the RTC device
    uint8_t tmp = rtc_get_reg(RTC_REG_DATE) ;
 80024b0:	2004      	movs	r0, #4
 80024b2:	f7ff fe83 	bl	80021bc <rtc_get_reg>
 80024b6:	4603      	mov	r3, r0
 80024b8:	73fb      	strb	r3, [r7, #15]

    // Extract the tens and ones digits from the BCD value
    date->day = (tmp >> 4)*10 + (tmp & 0x0f) ;
 80024ba:	7bfb      	ldrb	r3, [r7, #15]
 80024bc:	091b      	lsrs	r3, r3, #4
 80024be:	b2db      	uxtb	r3, r3
 80024c0:	461a      	mov	r2, r3
 80024c2:	0092      	lsls	r2, r2, #2
 80024c4:	4413      	add	r3, r2
 80024c6:	005b      	lsls	r3, r3, #1
 80024c8:	b2da      	uxtb	r2, r3
 80024ca:	7bfb      	ldrb	r3, [r7, #15]
 80024cc:	f003 030f 	and.w	r3, r3, #15
 80024d0:	b2db      	uxtb	r3, r3
 80024d2:	4413      	add	r3, r2
 80024d4:	b2da      	uxtb	r2, r3
 80024d6:	687b      	ldr	r3, [r7, #4]
 80024d8:	701a      	strb	r2, [r3, #0]

    // Read the month register from the RTC device
    tmp = rtc_get_reg(RTC_REG_MONTH) ;
 80024da:	2005      	movs	r0, #5
 80024dc:	f7ff fe6e 	bl	80021bc <rtc_get_reg>
 80024e0:	4603      	mov	r3, r0
 80024e2:	73fb      	strb	r3, [r7, #15]

    // Clear the century bit
    tmp &= 0x7f ;
 80024e4:	7bfb      	ldrb	r3, [r7, #15]
 80024e6:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 80024ea:	73fb      	strb	r3, [r7, #15]

    // Extract the tens and ones digits from the BCD value
    date->month = (tmp >> 4) *10 +(tmp & 0x0f) ;
 80024ec:	7bfb      	ldrb	r3, [r7, #15]
 80024ee:	091b      	lsrs	r3, r3, #4
 80024f0:	b2db      	uxtb	r3, r3
 80024f2:	461a      	mov	r2, r3
 80024f4:	0092      	lsls	r2, r2, #2
 80024f6:	4413      	add	r3, r2
 80024f8:	005b      	lsls	r3, r3, #1
 80024fa:	b2da      	uxtb	r2, r3
 80024fc:	7bfb      	ldrb	r3, [r7, #15]
 80024fe:	f003 030f 	and.w	r3, r3, #15
 8002502:	b2db      	uxtb	r3, r3
 8002504:	4413      	add	r3, r2
 8002506:	b2da      	uxtb	r2, r3
 8002508:	687b      	ldr	r3, [r7, #4]
 800250a:	705a      	strb	r2, [r3, #1]

    // Read the year register from the RTC device
    tmp = rtc_get_reg(RTC_REG_YEAR) ;
 800250c:	2006      	movs	r0, #6
 800250e:	f7ff fe55 	bl	80021bc <rtc_get_reg>
 8002512:	4603      	mov	r3, r0
 8002514:	73fb      	strb	r3, [r7, #15]

    // Extract the tens and ones digits from the BCD value
    date->year = (tmp >> 4) *10 +(tmp & 0x0f) ;
 8002516:	7bfb      	ldrb	r3, [r7, #15]
 8002518:	091b      	lsrs	r3, r3, #4
 800251a:	b2db      	uxtb	r3, r3
 800251c:	461a      	mov	r2, r3
 800251e:	0092      	lsls	r2, r2, #2
 8002520:	4413      	add	r3, r2
 8002522:	005b      	lsls	r3, r3, #1
 8002524:	b2da      	uxtb	r2, r3
 8002526:	7bfb      	ldrb	r3, [r7, #15]
 8002528:	f003 030f 	and.w	r3, r3, #15
 800252c:	b2db      	uxtb	r3, r3
 800252e:	4413      	add	r3, r2
 8002530:	b2da      	uxtb	r2, r3
 8002532:	687b      	ldr	r3, [r7, #4]
 8002534:	709a      	strb	r2, [r3, #2]
}
 8002536:	bf00      	nop
 8002538:	3710      	adds	r7, #16
 800253a:	46bd      	mov	sp, r7
 800253c:	bd80      	pop	{r7, pc}
	...

08002540 <rtc_set_alarm>:
 * The function then clears the alarm flag by ANDing the status register with 0xfe, and enables the alarm by setting the AE1 bit in the control register.
*/


void rtc_set_alarm(rtc_time_t * alarm)
{
 8002540:	b580      	push	{r7, lr}
 8002542:	b084      	sub	sp, #16
 8002544:	af00      	add	r7, sp, #0
 8002546:	6078      	str	r0, [r7, #4]
// Convert the alarm time to BCD format
uint8_t tmp = GET_BCD_HIGH(alarm->sec) | GET_BCD_LOW(alarm->sec);
 8002548:	687b      	ldr	r3, [r7, #4]
 800254a:	781b      	ldrb	r3, [r3, #0]
 800254c:	4a44      	ldr	r2, [pc, #272]	; (8002660 <rtc_set_alarm+0x120>)
 800254e:	fba2 2303 	umull	r2, r3, r2, r3
 8002552:	08db      	lsrs	r3, r3, #3
 8002554:	b2db      	uxtb	r3, r3
 8002556:	011b      	lsls	r3, r3, #4
 8002558:	b258      	sxtb	r0, r3
 800255a:	687b      	ldr	r3, [r7, #4]
 800255c:	781a      	ldrb	r2, [r3, #0]
 800255e:	4b40      	ldr	r3, [pc, #256]	; (8002660 <rtc_set_alarm+0x120>)
 8002560:	fba3 1302 	umull	r1, r3, r3, r2
 8002564:	08d9      	lsrs	r1, r3, #3
 8002566:	460b      	mov	r3, r1
 8002568:	009b      	lsls	r3, r3, #2
 800256a:	440b      	add	r3, r1
 800256c:	005b      	lsls	r3, r3, #1
 800256e:	1ad3      	subs	r3, r2, r3
 8002570:	b2db      	uxtb	r3, r3
 8002572:	b25b      	sxtb	r3, r3
 8002574:	4303      	orrs	r3, r0
 8002576:	b25b      	sxtb	r3, r3
 8002578:	73fb      	strb	r3, [r7, #15]

// Write the BCD-formatted alarm time to the seconds register
rtc_write_reg( RTC_I2C_ADDR , RTC_A1_SECOND ,tmp , 1) ;
 800257a:	7bfa      	ldrb	r2, [r7, #15]
 800257c:	2301      	movs	r3, #1
 800257e:	2107      	movs	r1, #7
 8002580:	2068      	movs	r0, #104	; 0x68
 8002582:	f7ff fdf1 	bl	8002168 <rtc_write_reg>

	tmp = GET_BCD_HIGH(alarm->min)  | GET_BCD_LOW(alarm->min)   ;
 8002586:	687b      	ldr	r3, [r7, #4]
 8002588:	785b      	ldrb	r3, [r3, #1]
 800258a:	4a35      	ldr	r2, [pc, #212]	; (8002660 <rtc_set_alarm+0x120>)
 800258c:	fba2 2303 	umull	r2, r3, r2, r3
 8002590:	08db      	lsrs	r3, r3, #3
 8002592:	b2db      	uxtb	r3, r3
 8002594:	011b      	lsls	r3, r3, #4
 8002596:	b258      	sxtb	r0, r3
 8002598:	687b      	ldr	r3, [r7, #4]
 800259a:	785a      	ldrb	r2, [r3, #1]
 800259c:	4b30      	ldr	r3, [pc, #192]	; (8002660 <rtc_set_alarm+0x120>)
 800259e:	fba3 1302 	umull	r1, r3, r3, r2
 80025a2:	08d9      	lsrs	r1, r3, #3
 80025a4:	460b      	mov	r3, r1
 80025a6:	009b      	lsls	r3, r3, #2
 80025a8:	440b      	add	r3, r1
 80025aa:	005b      	lsls	r3, r3, #1
 80025ac:	1ad3      	subs	r3, r2, r3
 80025ae:	b2db      	uxtb	r3, r3
 80025b0:	b25b      	sxtb	r3, r3
 80025b2:	4303      	orrs	r3, r0
 80025b4:	b25b      	sxtb	r3, r3
 80025b6:	73fb      	strb	r3, [r7, #15]

	rtc_write_reg( RTC_I2C_ADDR , RTC_A1_MINUTE ,tmp , 1) ;
 80025b8:	7bfa      	ldrb	r2, [r7, #15]
 80025ba:	2301      	movs	r3, #1
 80025bc:	2108      	movs	r1, #8
 80025be:	2068      	movs	r0, #104	; 0x68
 80025c0:	f7ff fdd2 	bl	8002168 <rtc_write_reg>

	tmp = GET_BCD_HIGH(alarm->hr)  | GET_BCD_LOW(alarm->hr)     ;
 80025c4:	687b      	ldr	r3, [r7, #4]
 80025c6:	789b      	ldrb	r3, [r3, #2]
 80025c8:	4a25      	ldr	r2, [pc, #148]	; (8002660 <rtc_set_alarm+0x120>)
 80025ca:	fba2 2303 	umull	r2, r3, r2, r3
 80025ce:	08db      	lsrs	r3, r3, #3
 80025d0:	b2db      	uxtb	r3, r3
 80025d2:	011b      	lsls	r3, r3, #4
 80025d4:	b258      	sxtb	r0, r3
 80025d6:	687b      	ldr	r3, [r7, #4]
 80025d8:	789a      	ldrb	r2, [r3, #2]
 80025da:	4b21      	ldr	r3, [pc, #132]	; (8002660 <rtc_set_alarm+0x120>)
 80025dc:	fba3 1302 	umull	r1, r3, r3, r2
 80025e0:	08d9      	lsrs	r1, r3, #3
 80025e2:	460b      	mov	r3, r1
 80025e4:	009b      	lsls	r3, r3, #2
 80025e6:	440b      	add	r3, r1
 80025e8:	005b      	lsls	r3, r3, #1
 80025ea:	1ad3      	subs	r3, r2, r3
 80025ec:	b2db      	uxtb	r3, r3
 80025ee:	b25b      	sxtb	r3, r3
 80025f0:	4303      	orrs	r3, r0
 80025f2:	b25b      	sxtb	r3, r3
 80025f4:	73fb      	strb	r3, [r7, #15]

	rtc_write_reg( RTC_I2C_ADDR , RTC_A1_HOUR ,tmp , 1) ;
 80025f6:	7bfa      	ldrb	r2, [r7, #15]
 80025f8:	2301      	movs	r3, #1
 80025fa:	2109      	movs	r1, #9
 80025fc:	2068      	movs	r0, #104	; 0x68
 80025fe:	f7ff fdb3 	bl	8002168 <rtc_write_reg>

	//set alarm when sec ,mi, and hour matchs

	tmp = rtc_get_reg(RTC_A1_DATE) ;
 8002602:	200a      	movs	r0, #10
 8002604:	f7ff fdda 	bl	80021bc <rtc_get_reg>
 8002608:	4603      	mov	r3, r0
 800260a:	73fb      	strb	r3, [r7, #15]

	//set A1M4 bit to one
	tmp |= 0x80 ;
 800260c:	7bfb      	ldrb	r3, [r7, #15]
 800260e:	f063 037f 	orn	r3, r3, #127	; 0x7f
 8002612:	73fb      	strb	r3, [r7, #15]

	rtc_write_reg( RTC_I2C_ADDR , RTC_A1_DATE ,tmp , 1) ;
 8002614:	7bfa      	ldrb	r2, [r7, #15]
 8002616:	2301      	movs	r3, #1
 8002618:	210a      	movs	r1, #10
 800261a:	2068      	movs	r0, #104	; 0x68
 800261c:	f7ff fda4 	bl	8002168 <rtc_write_reg>

	//clear alarm flag
	tmp  = rtc_get_reg(RTC_STATUS_REG) & 0xfe; // set A1F to 0
 8002620:	200f      	movs	r0, #15
 8002622:	f7ff fdcb 	bl	80021bc <rtc_get_reg>
 8002626:	4603      	mov	r3, r0
 8002628:	f023 0301 	bic.w	r3, r3, #1
 800262c:	73fb      	strb	r3, [r7, #15]

	rtc_write_reg( RTC_I2C_ADDR , RTC_STATUS_REG ,tmp , 1) ;
 800262e:	7bfa      	ldrb	r2, [r7, #15]
 8002630:	2301      	movs	r3, #1
 8002632:	210f      	movs	r1, #15
 8002634:	2068      	movs	r0, #104	; 0x68
 8002636:	f7ff fd97 	bl	8002168 <rtc_write_reg>

	//enable rtc alarm
	tmp = rtc_get_reg(RTC_CONTROL_REG) ;
 800263a:	200e      	movs	r0, #14
 800263c:	f7ff fdbe 	bl	80021bc <rtc_get_reg>
 8002640:	4603      	mov	r3, r0
 8002642:	73fb      	strb	r3, [r7, #15]

	//set AE1 in control reg
	tmp |= 0x01;
 8002644:	7bfb      	ldrb	r3, [r7, #15]
 8002646:	f043 0301 	orr.w	r3, r3, #1
 800264a:	73fb      	strb	r3, [r7, #15]

	rtc_write_reg( RTC_I2C_ADDR , RTC_CONTROL_REG ,tmp , 1) ;
 800264c:	7bfa      	ldrb	r2, [r7, #15]
 800264e:	2301      	movs	r3, #1
 8002650:	210e      	movs	r1, #14
 8002652:	2068      	movs	r0, #104	; 0x68
 8002654:	f7ff fd88 	bl	8002168 <rtc_write_reg>

}
 8002658:	bf00      	nop
 800265a:	3710      	adds	r7, #16
 800265c:	46bd      	mov	sp, r7
 800265e:	bd80      	pop	{r7, pc}
 8002660:	cccccccd 	.word	0xcccccccd

08002664 <rtc_get_alarm>:
 * It then extracts the tens and ones digits of the seconds from the BCD value using bitwise operations.
 * The function then reads the alarm minutes register from the RTC device and extracts the tens and ones digits of the minutes from the BCD value in the same way as the seconds.
 * Finally, the function reads the alarm hours register from the RTC device and extracts the tens and ones digits of the hours from the BCD value using bitwise operations.
*/
void rtc_get_alarm(rtc_time_t * tm)
{
 8002664:	b580      	push	{r7, lr}
 8002666:	b084      	sub	sp, #16
 8002668:	af00      	add	r7, sp, #0
 800266a:	6078      	str	r0, [r7, #4]
// Read the alarm seconds register from the RTC device
uint8_t tmp = rtc_get_reg(RTC_A1_SECOND) ;
 800266c:	2007      	movs	r0, #7
 800266e:	f7ff fda5 	bl	80021bc <rtc_get_reg>
 8002672:	4603      	mov	r3, r0
 8002674:	73fb      	strb	r3, [r7, #15]

// Extract the tens and ones digits from the BCD value
tm->sec = (tmp >> 4) *10 + (tmp & 0x0f) ;
 8002676:	7bfb      	ldrb	r3, [r7, #15]
 8002678:	091b      	lsrs	r3, r3, #4
 800267a:	b2db      	uxtb	r3, r3
 800267c:	461a      	mov	r2, r3
 800267e:	0092      	lsls	r2, r2, #2
 8002680:	4413      	add	r3, r2
 8002682:	005b      	lsls	r3, r3, #1
 8002684:	b2da      	uxtb	r2, r3
 8002686:	7bfb      	ldrb	r3, [r7, #15]
 8002688:	f003 030f 	and.w	r3, r3, #15
 800268c:	b2db      	uxtb	r3, r3
 800268e:	4413      	add	r3, r2
 8002690:	b2da      	uxtb	r2, r3
 8002692:	687b      	ldr	r3, [r7, #4]
 8002694:	701a      	strb	r2, [r3, #0]

// Read the alarm minutes register from the RTC device
tmp = rtc_get_reg(RTC_A1_MINUTE) ;
 8002696:	2008      	movs	r0, #8
 8002698:	f7ff fd90 	bl	80021bc <rtc_get_reg>
 800269c:	4603      	mov	r3, r0
 800269e:	73fb      	strb	r3, [r7, #15]

// Extract the tens and ones digits from the BCD value
tm->min = (tmp >> 4) *10 + (tmp & 0x0f) ;
 80026a0:	7bfb      	ldrb	r3, [r7, #15]
 80026a2:	091b      	lsrs	r3, r3, #4
 80026a4:	b2db      	uxtb	r3, r3
 80026a6:	461a      	mov	r2, r3
 80026a8:	0092      	lsls	r2, r2, #2
 80026aa:	4413      	add	r3, r2
 80026ac:	005b      	lsls	r3, r3, #1
 80026ae:	b2da      	uxtb	r2, r3
 80026b0:	7bfb      	ldrb	r3, [r7, #15]
 80026b2:	f003 030f 	and.w	r3, r3, #15
 80026b6:	b2db      	uxtb	r3, r3
 80026b8:	4413      	add	r3, r2
 80026ba:	b2da      	uxtb	r2, r3
 80026bc:	687b      	ldr	r3, [r7, #4]
 80026be:	705a      	strb	r2, [r3, #1]

// Read the alarm hours register from the RTC device
tmp = rtc_get_reg(RTC_A1_HOUR) ;
 80026c0:	2009      	movs	r0, #9
 80026c2:	f7ff fd7b 	bl	80021bc <rtc_get_reg>
 80026c6:	4603      	mov	r3, r0
 80026c8:	73fb      	strb	r3, [r7, #15]

// Extract the tens and ones digits from the BCD value
tm->hr = (tmp >> 4) *10 + (tmp & 0x0f) ;
 80026ca:	7bfb      	ldrb	r3, [r7, #15]
 80026cc:	091b      	lsrs	r3, r3, #4
 80026ce:	b2db      	uxtb	r3, r3
 80026d0:	461a      	mov	r2, r3
 80026d2:	0092      	lsls	r2, r2, #2
 80026d4:	4413      	add	r3, r2
 80026d6:	005b      	lsls	r3, r3, #1
 80026d8:	b2da      	uxtb	r2, r3
 80026da:	7bfb      	ldrb	r3, [r7, #15]
 80026dc:	f003 030f 	and.w	r3, r3, #15
 80026e0:	b2db      	uxtb	r3, r3
 80026e2:	4413      	add	r3, r2
 80026e4:	b2da      	uxtb	r2, r3
 80026e6:	687b      	ldr	r3, [r7, #4]
 80026e8:	709a      	strb	r2, [r3, #2]
}
 80026ea:	bf00      	nop
 80026ec:	3710      	adds	r7, #16
 80026ee:	46bd      	mov	sp, r7
 80026f0:	bd80      	pop	{r7, pc}

080026f2 <rtc_is_alarm_set>:
 * Then it checks if the A1F bit is set in the status register by ANDing it with the RTC_STATUS_AF1_MASK.
 * If the A1F bit is set, it returns true, indicating that the alarm is set.
 * Otherwise, it returns false, indicating that the alarm is not set.
*/
bool rtc_is_alarm_set( )
{
 80026f2:	b580      	push	{r7, lr}
 80026f4:	b082      	sub	sp, #8
 80026f6:	af00      	add	r7, sp, #0
bool ret = false ;
 80026f8:	2300      	movs	r3, #0
 80026fa:	71fb      	strb	r3, [r7, #7]
// Check if A1F in status register is set
if( (rtc_get_reg(RTC_STATUS_REG) & RTC_STATUS_AF1_MASK ) != 0 )
 80026fc:	200f      	movs	r0, #15
 80026fe:	f7ff fd5d 	bl	80021bc <rtc_get_reg>
 8002702:	4603      	mov	r3, r0
 8002704:	f003 0301 	and.w	r3, r3, #1
 8002708:	2b00      	cmp	r3, #0
 800270a:	d002      	beq.n	8002712 <rtc_is_alarm_set+0x20>
{
ret = true ;
 800270c:	2301      	movs	r3, #1
 800270e:	71fb      	strb	r3, [r7, #7]
 8002710:	e001      	b.n	8002716 <rtc_is_alarm_set+0x24>
}
else{
ret = false ;
 8002712:	2300      	movs	r3, #0
 8002714:	71fb      	strb	r3, [r7, #7]
}
return ret ;
 8002716:	79fb      	ldrb	r3, [r7, #7]
}
 8002718:	4618      	mov	r0, r3
 800271a:	3708      	adds	r7, #8
 800271c:	46bd      	mov	sp, r7
 800271e:	bd80      	pop	{r7, pc}

08002720 <rtc_alarm_clear>:
 * It first reads the status register using the "rtc_get_reg" function.
 * Then it uses bitwise operations to clear the A1F bit in the register.
 * Finally, it writes the updated value back to the status register using the "rtc_write_reg" function.
*/
void rtc_alarm_clear()
{
 8002720:	b580      	push	{r7, lr}
 8002722:	b082      	sub	sp, #8
 8002724:	af00      	add	r7, sp, #0
// Read the status register
uint8_t tmp = rtc_get_reg(RTC_STATUS_REG) ;
 8002726:	200f      	movs	r0, #15
 8002728:	f7ff fd48 	bl	80021bc <rtc_get_reg>
 800272c:	4603      	mov	r3, r0
 800272e:	71fb      	strb	r3, [r7, #7]

// Clear the A1F bit
tmp &= ~RTC_STATUS_AF1_MASK ;
 8002730:	79fb      	ldrb	r3, [r7, #7]
 8002732:	f023 0301 	bic.w	r3, r3, #1
 8002736:	71fb      	strb	r3, [r7, #7]

// Write the updated value back to the status register
rtc_write_reg( RTC_I2C_ADDR , RTC_STATUS_REG ,tmp , 1) ;
 8002738:	79fa      	ldrb	r2, [r7, #7]
 800273a:	2301      	movs	r3, #1
 800273c:	210f      	movs	r1, #15
 800273e:	2068      	movs	r0, #104	; 0x68
 8002740:	f7ff fd12 	bl	8002168 <rtc_write_reg>
}
 8002744:	bf00      	nop
 8002746:	3708      	adds	r7, #8
 8002748:	46bd      	mov	sp, r7
 800274a:	bd80      	pop	{r7, pc}

0800274c <rtc_set_alarm_callback>:
 * so that it can be called later when the alarm goes off.
 */
callback_t 	alarm1_callback  ;

void rtc_set_alarm_callback(callback_t  callback)
{
 800274c:	b480      	push	{r7}
 800274e:	b083      	sub	sp, #12
 8002750:	af00      	add	r7, sp, #0
 8002752:	6078      	str	r0, [r7, #4]
	alarm1_callback = callback ;
 8002754:	4a03      	ldr	r2, [pc, #12]	; (8002764 <rtc_set_alarm_callback+0x18>)
 8002756:	687b      	ldr	r3, [r7, #4]
 8002758:	6013      	str	r3, [r2, #0]
}
 800275a:	bf00      	nop
 800275c:	370c      	adds	r7, #12
 800275e:	46bd      	mov	sp, r7
 8002760:	bc80      	pop	{r7}
 8002762:	4770      	bx	lr
 8002764:	20000d6c 	.word	0x20000d6c

08002768 <rtc_update>:
 * it calls the callback function that was previously set using rtc_set_alarm_callback().
 * If the alarm is not set, the function does nothing.
 * This function should be called periodically in the main loop of the program to check for the alarm status and respond accordingly.
 */
void rtc_update(void)
{
 8002768:	b580      	push	{r7, lr}
 800276a:	af00      	add	r7, sp, #0
	if(rtc_is_alarm_set( ) == true && alarm1_callback != NULL)
 800276c:	f7ff ffc1 	bl	80026f2 <rtc_is_alarm_set>
 8002770:	4603      	mov	r3, r0
 8002772:	2b00      	cmp	r3, #0
 8002774:	d006      	beq.n	8002784 <rtc_update+0x1c>
 8002776:	4b04      	ldr	r3, [pc, #16]	; (8002788 <rtc_update+0x20>)
 8002778:	681b      	ldr	r3, [r3, #0]
 800277a:	2b00      	cmp	r3, #0
 800277c:	d002      	beq.n	8002784 <rtc_update+0x1c>
	{
		alarm1_callback() ;//NULL
 800277e:	4b02      	ldr	r3, [pc, #8]	; (8002788 <rtc_update+0x20>)
 8002780:	681b      	ldr	r3, [r3, #0]
 8002782:	4798      	blx	r3
	}
	else
	{

	}
}
 8002784:	bf00      	nop
 8002786:	bd80      	pop	{r7, pc}
 8002788:	20000d6c 	.word	0x20000d6c

0800278c <__libc_init_array>:
 800278c:	b570      	push	{r4, r5, r6, lr}
 800278e:	4d0d      	ldr	r5, [pc, #52]	; (80027c4 <__libc_init_array+0x38>)
 8002790:	4c0d      	ldr	r4, [pc, #52]	; (80027c8 <__libc_init_array+0x3c>)
 8002792:	1b64      	subs	r4, r4, r5
 8002794:	10a4      	asrs	r4, r4, #2
 8002796:	2600      	movs	r6, #0
 8002798:	42a6      	cmp	r6, r4
 800279a:	d109      	bne.n	80027b0 <__libc_init_array+0x24>
 800279c:	4d0b      	ldr	r5, [pc, #44]	; (80027cc <__libc_init_array+0x40>)
 800279e:	4c0c      	ldr	r4, [pc, #48]	; (80027d0 <__libc_init_array+0x44>)
 80027a0:	f000 fcae 	bl	8003100 <_init>
 80027a4:	1b64      	subs	r4, r4, r5
 80027a6:	10a4      	asrs	r4, r4, #2
 80027a8:	2600      	movs	r6, #0
 80027aa:	42a6      	cmp	r6, r4
 80027ac:	d105      	bne.n	80027ba <__libc_init_array+0x2e>
 80027ae:	bd70      	pop	{r4, r5, r6, pc}
 80027b0:	f855 3b04 	ldr.w	r3, [r5], #4
 80027b4:	4798      	blx	r3
 80027b6:	3601      	adds	r6, #1
 80027b8:	e7ee      	b.n	8002798 <__libc_init_array+0xc>
 80027ba:	f855 3b04 	ldr.w	r3, [r5], #4
 80027be:	4798      	blx	r3
 80027c0:	3601      	adds	r6, #1
 80027c2:	e7f2      	b.n	80027aa <__libc_init_array+0x1e>
 80027c4:	08004aec 	.word	0x08004aec
 80027c8:	08004aec 	.word	0x08004aec
 80027cc:	08004aec 	.word	0x08004aec
 80027d0:	08004af0 	.word	0x08004af0

080027d4 <memset>:
 80027d4:	4402      	add	r2, r0
 80027d6:	4603      	mov	r3, r0
 80027d8:	4293      	cmp	r3, r2
 80027da:	d100      	bne.n	80027de <memset+0xa>
 80027dc:	4770      	bx	lr
 80027de:	f803 1b01 	strb.w	r1, [r3], #1
 80027e2:	e7f9      	b.n	80027d8 <memset+0x4>

080027e4 <siprintf>:
 80027e4:	b40e      	push	{r1, r2, r3}
 80027e6:	b500      	push	{lr}
 80027e8:	b09c      	sub	sp, #112	; 0x70
 80027ea:	ab1d      	add	r3, sp, #116	; 0x74
 80027ec:	9002      	str	r0, [sp, #8]
 80027ee:	9006      	str	r0, [sp, #24]
 80027f0:	f06f 4100 	mvn.w	r1, #2147483648	; 0x80000000
 80027f4:	4809      	ldr	r0, [pc, #36]	; (800281c <siprintf+0x38>)
 80027f6:	9107      	str	r1, [sp, #28]
 80027f8:	9104      	str	r1, [sp, #16]
 80027fa:	4909      	ldr	r1, [pc, #36]	; (8002820 <siprintf+0x3c>)
 80027fc:	f853 2b04 	ldr.w	r2, [r3], #4
 8002800:	9105      	str	r1, [sp, #20]
 8002802:	6800      	ldr	r0, [r0, #0]
 8002804:	9301      	str	r3, [sp, #4]
 8002806:	a902      	add	r1, sp, #8
 8002808:	f000 f87c 	bl	8002904 <_svfiprintf_r>
 800280c:	9b02      	ldr	r3, [sp, #8]
 800280e:	2200      	movs	r2, #0
 8002810:	701a      	strb	r2, [r3, #0]
 8002812:	b01c      	add	sp, #112	; 0x70
 8002814:	f85d eb04 	ldr.w	lr, [sp], #4
 8002818:	b003      	add	sp, #12
 800281a:	4770      	bx	lr
 800281c:	20000078 	.word	0x20000078
 8002820:	ffff0208 	.word	0xffff0208

08002824 <strncmp>:
 8002824:	b510      	push	{r4, lr}
 8002826:	4603      	mov	r3, r0
 8002828:	b172      	cbz	r2, 8002848 <strncmp+0x24>
 800282a:	3901      	subs	r1, #1
 800282c:	1884      	adds	r4, r0, r2
 800282e:	f813 0b01 	ldrb.w	r0, [r3], #1
 8002832:	f811 2f01 	ldrb.w	r2, [r1, #1]!
 8002836:	4290      	cmp	r0, r2
 8002838:	d101      	bne.n	800283e <strncmp+0x1a>
 800283a:	42a3      	cmp	r3, r4
 800283c:	d101      	bne.n	8002842 <strncmp+0x1e>
 800283e:	1a80      	subs	r0, r0, r2
 8002840:	bd10      	pop	{r4, pc}
 8002842:	2800      	cmp	r0, #0
 8002844:	d1f3      	bne.n	800282e <strncmp+0xa>
 8002846:	e7fa      	b.n	800283e <strncmp+0x1a>
 8002848:	4610      	mov	r0, r2
 800284a:	e7f9      	b.n	8002840 <strncmp+0x1c>

0800284c <__ssputs_r>:
 800284c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8002850:	688e      	ldr	r6, [r1, #8]
 8002852:	429e      	cmp	r6, r3
 8002854:	4682      	mov	sl, r0
 8002856:	460c      	mov	r4, r1
 8002858:	4690      	mov	r8, r2
 800285a:	461f      	mov	r7, r3
 800285c:	d838      	bhi.n	80028d0 <__ssputs_r+0x84>
 800285e:	898a      	ldrh	r2, [r1, #12]
 8002860:	f412 6f90 	tst.w	r2, #1152	; 0x480
 8002864:	d032      	beq.n	80028cc <__ssputs_r+0x80>
 8002866:	6825      	ldr	r5, [r4, #0]
 8002868:	6909      	ldr	r1, [r1, #16]
 800286a:	eba5 0901 	sub.w	r9, r5, r1
 800286e:	6965      	ldr	r5, [r4, #20]
 8002870:	eb05 0545 	add.w	r5, r5, r5, lsl #1
 8002874:	eb05 75d5 	add.w	r5, r5, r5, lsr #31
 8002878:	3301      	adds	r3, #1
 800287a:	444b      	add	r3, r9
 800287c:	106d      	asrs	r5, r5, #1
 800287e:	429d      	cmp	r5, r3
 8002880:	bf38      	it	cc
 8002882:	461d      	movcc	r5, r3
 8002884:	0553      	lsls	r3, r2, #21
 8002886:	d531      	bpl.n	80028ec <__ssputs_r+0xa0>
 8002888:	4629      	mov	r1, r5
 800288a:	f000 fb61 	bl	8002f50 <_malloc_r>
 800288e:	4606      	mov	r6, r0
 8002890:	b950      	cbnz	r0, 80028a8 <__ssputs_r+0x5c>
 8002892:	230c      	movs	r3, #12
 8002894:	f8ca 3000 	str.w	r3, [sl]
 8002898:	89a3      	ldrh	r3, [r4, #12]
 800289a:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 800289e:	81a3      	strh	r3, [r4, #12]
 80028a0:	f04f 30ff 	mov.w	r0, #4294967295
 80028a4:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 80028a8:	6921      	ldr	r1, [r4, #16]
 80028aa:	464a      	mov	r2, r9
 80028ac:	f000 fabe 	bl	8002e2c <memcpy>
 80028b0:	89a3      	ldrh	r3, [r4, #12]
 80028b2:	f423 6390 	bic.w	r3, r3, #1152	; 0x480
 80028b6:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 80028ba:	81a3      	strh	r3, [r4, #12]
 80028bc:	6126      	str	r6, [r4, #16]
 80028be:	6165      	str	r5, [r4, #20]
 80028c0:	444e      	add	r6, r9
 80028c2:	eba5 0509 	sub.w	r5, r5, r9
 80028c6:	6026      	str	r6, [r4, #0]
 80028c8:	60a5      	str	r5, [r4, #8]
 80028ca:	463e      	mov	r6, r7
 80028cc:	42be      	cmp	r6, r7
 80028ce:	d900      	bls.n	80028d2 <__ssputs_r+0x86>
 80028d0:	463e      	mov	r6, r7
 80028d2:	6820      	ldr	r0, [r4, #0]
 80028d4:	4632      	mov	r2, r6
 80028d6:	4641      	mov	r1, r8
 80028d8:	f000 fab6 	bl	8002e48 <memmove>
 80028dc:	68a3      	ldr	r3, [r4, #8]
 80028de:	1b9b      	subs	r3, r3, r6
 80028e0:	60a3      	str	r3, [r4, #8]
 80028e2:	6823      	ldr	r3, [r4, #0]
 80028e4:	4433      	add	r3, r6
 80028e6:	6023      	str	r3, [r4, #0]
 80028e8:	2000      	movs	r0, #0
 80028ea:	e7db      	b.n	80028a4 <__ssputs_r+0x58>
 80028ec:	462a      	mov	r2, r5
 80028ee:	f000 fba3 	bl	8003038 <_realloc_r>
 80028f2:	4606      	mov	r6, r0
 80028f4:	2800      	cmp	r0, #0
 80028f6:	d1e1      	bne.n	80028bc <__ssputs_r+0x70>
 80028f8:	6921      	ldr	r1, [r4, #16]
 80028fa:	4650      	mov	r0, sl
 80028fc:	f000 fabe 	bl	8002e7c <_free_r>
 8002900:	e7c7      	b.n	8002892 <__ssputs_r+0x46>
	...

08002904 <_svfiprintf_r>:
 8002904:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8002908:	4698      	mov	r8, r3
 800290a:	898b      	ldrh	r3, [r1, #12]
 800290c:	061b      	lsls	r3, r3, #24
 800290e:	b09d      	sub	sp, #116	; 0x74
 8002910:	4607      	mov	r7, r0
 8002912:	460d      	mov	r5, r1
 8002914:	4614      	mov	r4, r2
 8002916:	d50e      	bpl.n	8002936 <_svfiprintf_r+0x32>
 8002918:	690b      	ldr	r3, [r1, #16]
 800291a:	b963      	cbnz	r3, 8002936 <_svfiprintf_r+0x32>
 800291c:	2140      	movs	r1, #64	; 0x40
 800291e:	f000 fb17 	bl	8002f50 <_malloc_r>
 8002922:	6028      	str	r0, [r5, #0]
 8002924:	6128      	str	r0, [r5, #16]
 8002926:	b920      	cbnz	r0, 8002932 <_svfiprintf_r+0x2e>
 8002928:	230c      	movs	r3, #12
 800292a:	603b      	str	r3, [r7, #0]
 800292c:	f04f 30ff 	mov.w	r0, #4294967295
 8002930:	e0d1      	b.n	8002ad6 <_svfiprintf_r+0x1d2>
 8002932:	2340      	movs	r3, #64	; 0x40
 8002934:	616b      	str	r3, [r5, #20]
 8002936:	2300      	movs	r3, #0
 8002938:	9309      	str	r3, [sp, #36]	; 0x24
 800293a:	2320      	movs	r3, #32
 800293c:	f88d 3029 	strb.w	r3, [sp, #41]	; 0x29
 8002940:	f8cd 800c 	str.w	r8, [sp, #12]
 8002944:	2330      	movs	r3, #48	; 0x30
 8002946:	f8df 81a8 	ldr.w	r8, [pc, #424]	; 8002af0 <_svfiprintf_r+0x1ec>
 800294a:	f88d 302a 	strb.w	r3, [sp, #42]	; 0x2a
 800294e:	f04f 0901 	mov.w	r9, #1
 8002952:	4623      	mov	r3, r4
 8002954:	469a      	mov	sl, r3
 8002956:	f813 2b01 	ldrb.w	r2, [r3], #1
 800295a:	b10a      	cbz	r2, 8002960 <_svfiprintf_r+0x5c>
 800295c:	2a25      	cmp	r2, #37	; 0x25
 800295e:	d1f9      	bne.n	8002954 <_svfiprintf_r+0x50>
 8002960:	ebba 0b04 	subs.w	fp, sl, r4
 8002964:	d00b      	beq.n	800297e <_svfiprintf_r+0x7a>
 8002966:	465b      	mov	r3, fp
 8002968:	4622      	mov	r2, r4
 800296a:	4629      	mov	r1, r5
 800296c:	4638      	mov	r0, r7
 800296e:	f7ff ff6d 	bl	800284c <__ssputs_r>
 8002972:	3001      	adds	r0, #1
 8002974:	f000 80aa 	beq.w	8002acc <_svfiprintf_r+0x1c8>
 8002978:	9a09      	ldr	r2, [sp, #36]	; 0x24
 800297a:	445a      	add	r2, fp
 800297c:	9209      	str	r2, [sp, #36]	; 0x24
 800297e:	f89a 3000 	ldrb.w	r3, [sl]
 8002982:	2b00      	cmp	r3, #0
 8002984:	f000 80a2 	beq.w	8002acc <_svfiprintf_r+0x1c8>
 8002988:	2300      	movs	r3, #0
 800298a:	f04f 32ff 	mov.w	r2, #4294967295
 800298e:	e9cd 2305 	strd	r2, r3, [sp, #20]
 8002992:	f10a 0a01 	add.w	sl, sl, #1
 8002996:	9304      	str	r3, [sp, #16]
 8002998:	9307      	str	r3, [sp, #28]
 800299a:	f88d 3053 	strb.w	r3, [sp, #83]	; 0x53
 800299e:	931a      	str	r3, [sp, #104]	; 0x68
 80029a0:	4654      	mov	r4, sl
 80029a2:	2205      	movs	r2, #5
 80029a4:	f814 1b01 	ldrb.w	r1, [r4], #1
 80029a8:	4851      	ldr	r0, [pc, #324]	; (8002af0 <_svfiprintf_r+0x1ec>)
 80029aa:	f7fd fc21 	bl	80001f0 <memchr>
 80029ae:	9a04      	ldr	r2, [sp, #16]
 80029b0:	b9d8      	cbnz	r0, 80029ea <_svfiprintf_r+0xe6>
 80029b2:	06d0      	lsls	r0, r2, #27
 80029b4:	bf44      	itt	mi
 80029b6:	2320      	movmi	r3, #32
 80029b8:	f88d 3053 	strbmi.w	r3, [sp, #83]	; 0x53
 80029bc:	0711      	lsls	r1, r2, #28
 80029be:	bf44      	itt	mi
 80029c0:	232b      	movmi	r3, #43	; 0x2b
 80029c2:	f88d 3053 	strbmi.w	r3, [sp, #83]	; 0x53
 80029c6:	f89a 3000 	ldrb.w	r3, [sl]
 80029ca:	2b2a      	cmp	r3, #42	; 0x2a
 80029cc:	d015      	beq.n	80029fa <_svfiprintf_r+0xf6>
 80029ce:	9a07      	ldr	r2, [sp, #28]
 80029d0:	4654      	mov	r4, sl
 80029d2:	2000      	movs	r0, #0
 80029d4:	f04f 0c0a 	mov.w	ip, #10
 80029d8:	4621      	mov	r1, r4
 80029da:	f811 3b01 	ldrb.w	r3, [r1], #1
 80029de:	3b30      	subs	r3, #48	; 0x30
 80029e0:	2b09      	cmp	r3, #9
 80029e2:	d94e      	bls.n	8002a82 <_svfiprintf_r+0x17e>
 80029e4:	b1b0      	cbz	r0, 8002a14 <_svfiprintf_r+0x110>
 80029e6:	9207      	str	r2, [sp, #28]
 80029e8:	e014      	b.n	8002a14 <_svfiprintf_r+0x110>
 80029ea:	eba0 0308 	sub.w	r3, r0, r8
 80029ee:	fa09 f303 	lsl.w	r3, r9, r3
 80029f2:	4313      	orrs	r3, r2
 80029f4:	9304      	str	r3, [sp, #16]
 80029f6:	46a2      	mov	sl, r4
 80029f8:	e7d2      	b.n	80029a0 <_svfiprintf_r+0x9c>
 80029fa:	9b03      	ldr	r3, [sp, #12]
 80029fc:	1d19      	adds	r1, r3, #4
 80029fe:	681b      	ldr	r3, [r3, #0]
 8002a00:	9103      	str	r1, [sp, #12]
 8002a02:	2b00      	cmp	r3, #0
 8002a04:	bfbb      	ittet	lt
 8002a06:	425b      	neglt	r3, r3
 8002a08:	f042 0202 	orrlt.w	r2, r2, #2
 8002a0c:	9307      	strge	r3, [sp, #28]
 8002a0e:	9307      	strlt	r3, [sp, #28]
 8002a10:	bfb8      	it	lt
 8002a12:	9204      	strlt	r2, [sp, #16]
 8002a14:	7823      	ldrb	r3, [r4, #0]
 8002a16:	2b2e      	cmp	r3, #46	; 0x2e
 8002a18:	d10c      	bne.n	8002a34 <_svfiprintf_r+0x130>
 8002a1a:	7863      	ldrb	r3, [r4, #1]
 8002a1c:	2b2a      	cmp	r3, #42	; 0x2a
 8002a1e:	d135      	bne.n	8002a8c <_svfiprintf_r+0x188>
 8002a20:	9b03      	ldr	r3, [sp, #12]
 8002a22:	1d1a      	adds	r2, r3, #4
 8002a24:	681b      	ldr	r3, [r3, #0]
 8002a26:	9203      	str	r2, [sp, #12]
 8002a28:	2b00      	cmp	r3, #0
 8002a2a:	bfb8      	it	lt
 8002a2c:	f04f 33ff 	movlt.w	r3, #4294967295
 8002a30:	3402      	adds	r4, #2
 8002a32:	9305      	str	r3, [sp, #20]
 8002a34:	f8df a0bc 	ldr.w	sl, [pc, #188]	; 8002af4 <_svfiprintf_r+0x1f0>
 8002a38:	7821      	ldrb	r1, [r4, #0]
 8002a3a:	2203      	movs	r2, #3
 8002a3c:	4650      	mov	r0, sl
 8002a3e:	f7fd fbd7 	bl	80001f0 <memchr>
 8002a42:	b140      	cbz	r0, 8002a56 <_svfiprintf_r+0x152>
 8002a44:	2340      	movs	r3, #64	; 0x40
 8002a46:	eba0 000a 	sub.w	r0, r0, sl
 8002a4a:	fa03 f000 	lsl.w	r0, r3, r0
 8002a4e:	9b04      	ldr	r3, [sp, #16]
 8002a50:	4303      	orrs	r3, r0
 8002a52:	3401      	adds	r4, #1
 8002a54:	9304      	str	r3, [sp, #16]
 8002a56:	f814 1b01 	ldrb.w	r1, [r4], #1
 8002a5a:	4827      	ldr	r0, [pc, #156]	; (8002af8 <_svfiprintf_r+0x1f4>)
 8002a5c:	f88d 1028 	strb.w	r1, [sp, #40]	; 0x28
 8002a60:	2206      	movs	r2, #6
 8002a62:	f7fd fbc5 	bl	80001f0 <memchr>
 8002a66:	2800      	cmp	r0, #0
 8002a68:	d038      	beq.n	8002adc <_svfiprintf_r+0x1d8>
 8002a6a:	4b24      	ldr	r3, [pc, #144]	; (8002afc <_svfiprintf_r+0x1f8>)
 8002a6c:	bb1b      	cbnz	r3, 8002ab6 <_svfiprintf_r+0x1b2>
 8002a6e:	9b03      	ldr	r3, [sp, #12]
 8002a70:	3307      	adds	r3, #7
 8002a72:	f023 0307 	bic.w	r3, r3, #7
 8002a76:	3308      	adds	r3, #8
 8002a78:	9303      	str	r3, [sp, #12]
 8002a7a:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8002a7c:	4433      	add	r3, r6
 8002a7e:	9309      	str	r3, [sp, #36]	; 0x24
 8002a80:	e767      	b.n	8002952 <_svfiprintf_r+0x4e>
 8002a82:	fb0c 3202 	mla	r2, ip, r2, r3
 8002a86:	460c      	mov	r4, r1
 8002a88:	2001      	movs	r0, #1
 8002a8a:	e7a5      	b.n	80029d8 <_svfiprintf_r+0xd4>
 8002a8c:	2300      	movs	r3, #0
 8002a8e:	3401      	adds	r4, #1
 8002a90:	9305      	str	r3, [sp, #20]
 8002a92:	4619      	mov	r1, r3
 8002a94:	f04f 0c0a 	mov.w	ip, #10
 8002a98:	4620      	mov	r0, r4
 8002a9a:	f810 2b01 	ldrb.w	r2, [r0], #1
 8002a9e:	3a30      	subs	r2, #48	; 0x30
 8002aa0:	2a09      	cmp	r2, #9
 8002aa2:	d903      	bls.n	8002aac <_svfiprintf_r+0x1a8>
 8002aa4:	2b00      	cmp	r3, #0
 8002aa6:	d0c5      	beq.n	8002a34 <_svfiprintf_r+0x130>
 8002aa8:	9105      	str	r1, [sp, #20]
 8002aaa:	e7c3      	b.n	8002a34 <_svfiprintf_r+0x130>
 8002aac:	fb0c 2101 	mla	r1, ip, r1, r2
 8002ab0:	4604      	mov	r4, r0
 8002ab2:	2301      	movs	r3, #1
 8002ab4:	e7f0      	b.n	8002a98 <_svfiprintf_r+0x194>
 8002ab6:	ab03      	add	r3, sp, #12
 8002ab8:	9300      	str	r3, [sp, #0]
 8002aba:	462a      	mov	r2, r5
 8002abc:	4b10      	ldr	r3, [pc, #64]	; (8002b00 <_svfiprintf_r+0x1fc>)
 8002abe:	a904      	add	r1, sp, #16
 8002ac0:	4638      	mov	r0, r7
 8002ac2:	f3af 8000 	nop.w
 8002ac6:	1c42      	adds	r2, r0, #1
 8002ac8:	4606      	mov	r6, r0
 8002aca:	d1d6      	bne.n	8002a7a <_svfiprintf_r+0x176>
 8002acc:	89ab      	ldrh	r3, [r5, #12]
 8002ace:	065b      	lsls	r3, r3, #25
 8002ad0:	f53f af2c 	bmi.w	800292c <_svfiprintf_r+0x28>
 8002ad4:	9809      	ldr	r0, [sp, #36]	; 0x24
 8002ad6:	b01d      	add	sp, #116	; 0x74
 8002ad8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8002adc:	ab03      	add	r3, sp, #12
 8002ade:	9300      	str	r3, [sp, #0]
 8002ae0:	462a      	mov	r2, r5
 8002ae2:	4b07      	ldr	r3, [pc, #28]	; (8002b00 <_svfiprintf_r+0x1fc>)
 8002ae4:	a904      	add	r1, sp, #16
 8002ae6:	4638      	mov	r0, r7
 8002ae8:	f000 f87a 	bl	8002be0 <_printf_i>
 8002aec:	e7eb      	b.n	8002ac6 <_svfiprintf_r+0x1c2>
 8002aee:	bf00      	nop
 8002af0:	08004ab8 	.word	0x08004ab8
 8002af4:	08004abe 	.word	0x08004abe
 8002af8:	08004ac2 	.word	0x08004ac2
 8002afc:	00000000 	.word	0x00000000
 8002b00:	0800284d 	.word	0x0800284d

08002b04 <_printf_common>:
 8002b04:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8002b08:	4616      	mov	r6, r2
 8002b0a:	4699      	mov	r9, r3
 8002b0c:	688a      	ldr	r2, [r1, #8]
 8002b0e:	690b      	ldr	r3, [r1, #16]
 8002b10:	f8dd 8020 	ldr.w	r8, [sp, #32]
 8002b14:	4293      	cmp	r3, r2
 8002b16:	bfb8      	it	lt
 8002b18:	4613      	movlt	r3, r2
 8002b1a:	6033      	str	r3, [r6, #0]
 8002b1c:	f891 2043 	ldrb.w	r2, [r1, #67]	; 0x43
 8002b20:	4607      	mov	r7, r0
 8002b22:	460c      	mov	r4, r1
 8002b24:	b10a      	cbz	r2, 8002b2a <_printf_common+0x26>
 8002b26:	3301      	adds	r3, #1
 8002b28:	6033      	str	r3, [r6, #0]
 8002b2a:	6823      	ldr	r3, [r4, #0]
 8002b2c:	0699      	lsls	r1, r3, #26
 8002b2e:	bf42      	ittt	mi
 8002b30:	6833      	ldrmi	r3, [r6, #0]
 8002b32:	3302      	addmi	r3, #2
 8002b34:	6033      	strmi	r3, [r6, #0]
 8002b36:	6825      	ldr	r5, [r4, #0]
 8002b38:	f015 0506 	ands.w	r5, r5, #6
 8002b3c:	d106      	bne.n	8002b4c <_printf_common+0x48>
 8002b3e:	f104 0a19 	add.w	sl, r4, #25
 8002b42:	68e3      	ldr	r3, [r4, #12]
 8002b44:	6832      	ldr	r2, [r6, #0]
 8002b46:	1a9b      	subs	r3, r3, r2
 8002b48:	42ab      	cmp	r3, r5
 8002b4a:	dc26      	bgt.n	8002b9a <_printf_common+0x96>
 8002b4c:	f894 2043 	ldrb.w	r2, [r4, #67]	; 0x43
 8002b50:	1e13      	subs	r3, r2, #0
 8002b52:	6822      	ldr	r2, [r4, #0]
 8002b54:	bf18      	it	ne
 8002b56:	2301      	movne	r3, #1
 8002b58:	0692      	lsls	r2, r2, #26
 8002b5a:	d42b      	bmi.n	8002bb4 <_printf_common+0xb0>
 8002b5c:	f104 0243 	add.w	r2, r4, #67	; 0x43
 8002b60:	4649      	mov	r1, r9
 8002b62:	4638      	mov	r0, r7
 8002b64:	47c0      	blx	r8
 8002b66:	3001      	adds	r0, #1
 8002b68:	d01e      	beq.n	8002ba8 <_printf_common+0xa4>
 8002b6a:	6823      	ldr	r3, [r4, #0]
 8002b6c:	68e5      	ldr	r5, [r4, #12]
 8002b6e:	6832      	ldr	r2, [r6, #0]
 8002b70:	f003 0306 	and.w	r3, r3, #6
 8002b74:	2b04      	cmp	r3, #4
 8002b76:	bf08      	it	eq
 8002b78:	1aad      	subeq	r5, r5, r2
 8002b7a:	68a3      	ldr	r3, [r4, #8]
 8002b7c:	6922      	ldr	r2, [r4, #16]
 8002b7e:	bf0c      	ite	eq
 8002b80:	ea25 75e5 	biceq.w	r5, r5, r5, asr #31
 8002b84:	2500      	movne	r5, #0
 8002b86:	4293      	cmp	r3, r2
 8002b88:	bfc4      	itt	gt
 8002b8a:	1a9b      	subgt	r3, r3, r2
 8002b8c:	18ed      	addgt	r5, r5, r3
 8002b8e:	2600      	movs	r6, #0
 8002b90:	341a      	adds	r4, #26
 8002b92:	42b5      	cmp	r5, r6
 8002b94:	d11a      	bne.n	8002bcc <_printf_common+0xc8>
 8002b96:	2000      	movs	r0, #0
 8002b98:	e008      	b.n	8002bac <_printf_common+0xa8>
 8002b9a:	2301      	movs	r3, #1
 8002b9c:	4652      	mov	r2, sl
 8002b9e:	4649      	mov	r1, r9
 8002ba0:	4638      	mov	r0, r7
 8002ba2:	47c0      	blx	r8
 8002ba4:	3001      	adds	r0, #1
 8002ba6:	d103      	bne.n	8002bb0 <_printf_common+0xac>
 8002ba8:	f04f 30ff 	mov.w	r0, #4294967295
 8002bac:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8002bb0:	3501      	adds	r5, #1
 8002bb2:	e7c6      	b.n	8002b42 <_printf_common+0x3e>
 8002bb4:	18e1      	adds	r1, r4, r3
 8002bb6:	1c5a      	adds	r2, r3, #1
 8002bb8:	2030      	movs	r0, #48	; 0x30
 8002bba:	f881 0043 	strb.w	r0, [r1, #67]	; 0x43
 8002bbe:	4422      	add	r2, r4
 8002bc0:	f894 1045 	ldrb.w	r1, [r4, #69]	; 0x45
 8002bc4:	f882 1043 	strb.w	r1, [r2, #67]	; 0x43
 8002bc8:	3302      	adds	r3, #2
 8002bca:	e7c7      	b.n	8002b5c <_printf_common+0x58>
 8002bcc:	2301      	movs	r3, #1
 8002bce:	4622      	mov	r2, r4
 8002bd0:	4649      	mov	r1, r9
 8002bd2:	4638      	mov	r0, r7
 8002bd4:	47c0      	blx	r8
 8002bd6:	3001      	adds	r0, #1
 8002bd8:	d0e6      	beq.n	8002ba8 <_printf_common+0xa4>
 8002bda:	3601      	adds	r6, #1
 8002bdc:	e7d9      	b.n	8002b92 <_printf_common+0x8e>
	...

08002be0 <_printf_i>:
 8002be0:	e92d 47ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, lr}
 8002be4:	7e0f      	ldrb	r7, [r1, #24]
 8002be6:	9d0c      	ldr	r5, [sp, #48]	; 0x30
 8002be8:	2f78      	cmp	r7, #120	; 0x78
 8002bea:	4691      	mov	r9, r2
 8002bec:	4680      	mov	r8, r0
 8002bee:	460c      	mov	r4, r1
 8002bf0:	469a      	mov	sl, r3
 8002bf2:	f101 0243 	add.w	r2, r1, #67	; 0x43
 8002bf6:	d807      	bhi.n	8002c08 <_printf_i+0x28>
 8002bf8:	2f62      	cmp	r7, #98	; 0x62
 8002bfa:	d80a      	bhi.n	8002c12 <_printf_i+0x32>
 8002bfc:	2f00      	cmp	r7, #0
 8002bfe:	f000 80d8 	beq.w	8002db2 <_printf_i+0x1d2>
 8002c02:	2f58      	cmp	r7, #88	; 0x58
 8002c04:	f000 80a3 	beq.w	8002d4e <_printf_i+0x16e>
 8002c08:	f104 0542 	add.w	r5, r4, #66	; 0x42
 8002c0c:	f884 7042 	strb.w	r7, [r4, #66]	; 0x42
 8002c10:	e03a      	b.n	8002c88 <_printf_i+0xa8>
 8002c12:	f1a7 0363 	sub.w	r3, r7, #99	; 0x63
 8002c16:	2b15      	cmp	r3, #21
 8002c18:	d8f6      	bhi.n	8002c08 <_printf_i+0x28>
 8002c1a:	a101      	add	r1, pc, #4	; (adr r1, 8002c20 <_printf_i+0x40>)
 8002c1c:	f851 f023 	ldr.w	pc, [r1, r3, lsl #2]
 8002c20:	08002c79 	.word	0x08002c79
 8002c24:	08002c8d 	.word	0x08002c8d
 8002c28:	08002c09 	.word	0x08002c09
 8002c2c:	08002c09 	.word	0x08002c09
 8002c30:	08002c09 	.word	0x08002c09
 8002c34:	08002c09 	.word	0x08002c09
 8002c38:	08002c8d 	.word	0x08002c8d
 8002c3c:	08002c09 	.word	0x08002c09
 8002c40:	08002c09 	.word	0x08002c09
 8002c44:	08002c09 	.word	0x08002c09
 8002c48:	08002c09 	.word	0x08002c09
 8002c4c:	08002d99 	.word	0x08002d99
 8002c50:	08002cbd 	.word	0x08002cbd
 8002c54:	08002d7b 	.word	0x08002d7b
 8002c58:	08002c09 	.word	0x08002c09
 8002c5c:	08002c09 	.word	0x08002c09
 8002c60:	08002dbb 	.word	0x08002dbb
 8002c64:	08002c09 	.word	0x08002c09
 8002c68:	08002cbd 	.word	0x08002cbd
 8002c6c:	08002c09 	.word	0x08002c09
 8002c70:	08002c09 	.word	0x08002c09
 8002c74:	08002d83 	.word	0x08002d83
 8002c78:	682b      	ldr	r3, [r5, #0]
 8002c7a:	1d1a      	adds	r2, r3, #4
 8002c7c:	681b      	ldr	r3, [r3, #0]
 8002c7e:	602a      	str	r2, [r5, #0]
 8002c80:	f104 0542 	add.w	r5, r4, #66	; 0x42
 8002c84:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
 8002c88:	2301      	movs	r3, #1
 8002c8a:	e0a3      	b.n	8002dd4 <_printf_i+0x1f4>
 8002c8c:	6820      	ldr	r0, [r4, #0]
 8002c8e:	6829      	ldr	r1, [r5, #0]
 8002c90:	0606      	lsls	r6, r0, #24
 8002c92:	f101 0304 	add.w	r3, r1, #4
 8002c96:	d50a      	bpl.n	8002cae <_printf_i+0xce>
 8002c98:	680e      	ldr	r6, [r1, #0]
 8002c9a:	602b      	str	r3, [r5, #0]
 8002c9c:	2e00      	cmp	r6, #0
 8002c9e:	da03      	bge.n	8002ca8 <_printf_i+0xc8>
 8002ca0:	232d      	movs	r3, #45	; 0x2d
 8002ca2:	4276      	negs	r6, r6
 8002ca4:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
 8002ca8:	485e      	ldr	r0, [pc, #376]	; (8002e24 <_printf_i+0x244>)
 8002caa:	230a      	movs	r3, #10
 8002cac:	e019      	b.n	8002ce2 <_printf_i+0x102>
 8002cae:	680e      	ldr	r6, [r1, #0]
 8002cb0:	602b      	str	r3, [r5, #0]
 8002cb2:	f010 0f40 	tst.w	r0, #64	; 0x40
 8002cb6:	bf18      	it	ne
 8002cb8:	b236      	sxthne	r6, r6
 8002cba:	e7ef      	b.n	8002c9c <_printf_i+0xbc>
 8002cbc:	682b      	ldr	r3, [r5, #0]
 8002cbe:	6820      	ldr	r0, [r4, #0]
 8002cc0:	1d19      	adds	r1, r3, #4
 8002cc2:	6029      	str	r1, [r5, #0]
 8002cc4:	0601      	lsls	r1, r0, #24
 8002cc6:	d501      	bpl.n	8002ccc <_printf_i+0xec>
 8002cc8:	681e      	ldr	r6, [r3, #0]
 8002cca:	e002      	b.n	8002cd2 <_printf_i+0xf2>
 8002ccc:	0646      	lsls	r6, r0, #25
 8002cce:	d5fb      	bpl.n	8002cc8 <_printf_i+0xe8>
 8002cd0:	881e      	ldrh	r6, [r3, #0]
 8002cd2:	4854      	ldr	r0, [pc, #336]	; (8002e24 <_printf_i+0x244>)
 8002cd4:	2f6f      	cmp	r7, #111	; 0x6f
 8002cd6:	bf0c      	ite	eq
 8002cd8:	2308      	moveq	r3, #8
 8002cda:	230a      	movne	r3, #10
 8002cdc:	2100      	movs	r1, #0
 8002cde:	f884 1043 	strb.w	r1, [r4, #67]	; 0x43
 8002ce2:	6865      	ldr	r5, [r4, #4]
 8002ce4:	60a5      	str	r5, [r4, #8]
 8002ce6:	2d00      	cmp	r5, #0
 8002ce8:	bfa2      	ittt	ge
 8002cea:	6821      	ldrge	r1, [r4, #0]
 8002cec:	f021 0104 	bicge.w	r1, r1, #4
 8002cf0:	6021      	strge	r1, [r4, #0]
 8002cf2:	b90e      	cbnz	r6, 8002cf8 <_printf_i+0x118>
 8002cf4:	2d00      	cmp	r5, #0
 8002cf6:	d04d      	beq.n	8002d94 <_printf_i+0x1b4>
 8002cf8:	4615      	mov	r5, r2
 8002cfa:	fbb6 f1f3 	udiv	r1, r6, r3
 8002cfe:	fb03 6711 	mls	r7, r3, r1, r6
 8002d02:	5dc7      	ldrb	r7, [r0, r7]
 8002d04:	f805 7d01 	strb.w	r7, [r5, #-1]!
 8002d08:	4637      	mov	r7, r6
 8002d0a:	42bb      	cmp	r3, r7
 8002d0c:	460e      	mov	r6, r1
 8002d0e:	d9f4      	bls.n	8002cfa <_printf_i+0x11a>
 8002d10:	2b08      	cmp	r3, #8
 8002d12:	d10b      	bne.n	8002d2c <_printf_i+0x14c>
 8002d14:	6823      	ldr	r3, [r4, #0]
 8002d16:	07de      	lsls	r6, r3, #31
 8002d18:	d508      	bpl.n	8002d2c <_printf_i+0x14c>
 8002d1a:	6923      	ldr	r3, [r4, #16]
 8002d1c:	6861      	ldr	r1, [r4, #4]
 8002d1e:	4299      	cmp	r1, r3
 8002d20:	bfde      	ittt	le
 8002d22:	2330      	movle	r3, #48	; 0x30
 8002d24:	f805 3c01 	strble.w	r3, [r5, #-1]
 8002d28:	f105 35ff 	addle.w	r5, r5, #4294967295
 8002d2c:	1b52      	subs	r2, r2, r5
 8002d2e:	6122      	str	r2, [r4, #16]
 8002d30:	f8cd a000 	str.w	sl, [sp]
 8002d34:	464b      	mov	r3, r9
 8002d36:	aa03      	add	r2, sp, #12
 8002d38:	4621      	mov	r1, r4
 8002d3a:	4640      	mov	r0, r8
 8002d3c:	f7ff fee2 	bl	8002b04 <_printf_common>
 8002d40:	3001      	adds	r0, #1
 8002d42:	d14c      	bne.n	8002dde <_printf_i+0x1fe>
 8002d44:	f04f 30ff 	mov.w	r0, #4294967295
 8002d48:	b004      	add	sp, #16
 8002d4a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8002d4e:	4835      	ldr	r0, [pc, #212]	; (8002e24 <_printf_i+0x244>)
 8002d50:	f881 7045 	strb.w	r7, [r1, #69]	; 0x45
 8002d54:	6829      	ldr	r1, [r5, #0]
 8002d56:	6823      	ldr	r3, [r4, #0]
 8002d58:	f851 6b04 	ldr.w	r6, [r1], #4
 8002d5c:	6029      	str	r1, [r5, #0]
 8002d5e:	061d      	lsls	r5, r3, #24
 8002d60:	d514      	bpl.n	8002d8c <_printf_i+0x1ac>
 8002d62:	07df      	lsls	r7, r3, #31
 8002d64:	bf44      	itt	mi
 8002d66:	f043 0320 	orrmi.w	r3, r3, #32
 8002d6a:	6023      	strmi	r3, [r4, #0]
 8002d6c:	b91e      	cbnz	r6, 8002d76 <_printf_i+0x196>
 8002d6e:	6823      	ldr	r3, [r4, #0]
 8002d70:	f023 0320 	bic.w	r3, r3, #32
 8002d74:	6023      	str	r3, [r4, #0]
 8002d76:	2310      	movs	r3, #16
 8002d78:	e7b0      	b.n	8002cdc <_printf_i+0xfc>
 8002d7a:	6823      	ldr	r3, [r4, #0]
 8002d7c:	f043 0320 	orr.w	r3, r3, #32
 8002d80:	6023      	str	r3, [r4, #0]
 8002d82:	2378      	movs	r3, #120	; 0x78
 8002d84:	4828      	ldr	r0, [pc, #160]	; (8002e28 <_printf_i+0x248>)
 8002d86:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
 8002d8a:	e7e3      	b.n	8002d54 <_printf_i+0x174>
 8002d8c:	0659      	lsls	r1, r3, #25
 8002d8e:	bf48      	it	mi
 8002d90:	b2b6      	uxthmi	r6, r6
 8002d92:	e7e6      	b.n	8002d62 <_printf_i+0x182>
 8002d94:	4615      	mov	r5, r2
 8002d96:	e7bb      	b.n	8002d10 <_printf_i+0x130>
 8002d98:	682b      	ldr	r3, [r5, #0]
 8002d9a:	6826      	ldr	r6, [r4, #0]
 8002d9c:	6961      	ldr	r1, [r4, #20]
 8002d9e:	1d18      	adds	r0, r3, #4
 8002da0:	6028      	str	r0, [r5, #0]
 8002da2:	0635      	lsls	r5, r6, #24
 8002da4:	681b      	ldr	r3, [r3, #0]
 8002da6:	d501      	bpl.n	8002dac <_printf_i+0x1cc>
 8002da8:	6019      	str	r1, [r3, #0]
 8002daa:	e002      	b.n	8002db2 <_printf_i+0x1d2>
 8002dac:	0670      	lsls	r0, r6, #25
 8002dae:	d5fb      	bpl.n	8002da8 <_printf_i+0x1c8>
 8002db0:	8019      	strh	r1, [r3, #0]
 8002db2:	2300      	movs	r3, #0
 8002db4:	6123      	str	r3, [r4, #16]
 8002db6:	4615      	mov	r5, r2
 8002db8:	e7ba      	b.n	8002d30 <_printf_i+0x150>
 8002dba:	682b      	ldr	r3, [r5, #0]
 8002dbc:	1d1a      	adds	r2, r3, #4
 8002dbe:	602a      	str	r2, [r5, #0]
 8002dc0:	681d      	ldr	r5, [r3, #0]
 8002dc2:	6862      	ldr	r2, [r4, #4]
 8002dc4:	2100      	movs	r1, #0
 8002dc6:	4628      	mov	r0, r5
 8002dc8:	f7fd fa12 	bl	80001f0 <memchr>
 8002dcc:	b108      	cbz	r0, 8002dd2 <_printf_i+0x1f2>
 8002dce:	1b40      	subs	r0, r0, r5
 8002dd0:	6060      	str	r0, [r4, #4]
 8002dd2:	6863      	ldr	r3, [r4, #4]
 8002dd4:	6123      	str	r3, [r4, #16]
 8002dd6:	2300      	movs	r3, #0
 8002dd8:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
 8002ddc:	e7a8      	b.n	8002d30 <_printf_i+0x150>
 8002dde:	6923      	ldr	r3, [r4, #16]
 8002de0:	462a      	mov	r2, r5
 8002de2:	4649      	mov	r1, r9
 8002de4:	4640      	mov	r0, r8
 8002de6:	47d0      	blx	sl
 8002de8:	3001      	adds	r0, #1
 8002dea:	d0ab      	beq.n	8002d44 <_printf_i+0x164>
 8002dec:	6823      	ldr	r3, [r4, #0]
 8002dee:	079b      	lsls	r3, r3, #30
 8002df0:	d413      	bmi.n	8002e1a <_printf_i+0x23a>
 8002df2:	68e0      	ldr	r0, [r4, #12]
 8002df4:	9b03      	ldr	r3, [sp, #12]
 8002df6:	4298      	cmp	r0, r3
 8002df8:	bfb8      	it	lt
 8002dfa:	4618      	movlt	r0, r3
 8002dfc:	e7a4      	b.n	8002d48 <_printf_i+0x168>
 8002dfe:	2301      	movs	r3, #1
 8002e00:	4632      	mov	r2, r6
 8002e02:	4649      	mov	r1, r9
 8002e04:	4640      	mov	r0, r8
 8002e06:	47d0      	blx	sl
 8002e08:	3001      	adds	r0, #1
 8002e0a:	d09b      	beq.n	8002d44 <_printf_i+0x164>
 8002e0c:	3501      	adds	r5, #1
 8002e0e:	68e3      	ldr	r3, [r4, #12]
 8002e10:	9903      	ldr	r1, [sp, #12]
 8002e12:	1a5b      	subs	r3, r3, r1
 8002e14:	42ab      	cmp	r3, r5
 8002e16:	dcf2      	bgt.n	8002dfe <_printf_i+0x21e>
 8002e18:	e7eb      	b.n	8002df2 <_printf_i+0x212>
 8002e1a:	2500      	movs	r5, #0
 8002e1c:	f104 0619 	add.w	r6, r4, #25
 8002e20:	e7f5      	b.n	8002e0e <_printf_i+0x22e>
 8002e22:	bf00      	nop
 8002e24:	08004ac9 	.word	0x08004ac9
 8002e28:	08004ada 	.word	0x08004ada

08002e2c <memcpy>:
 8002e2c:	440a      	add	r2, r1
 8002e2e:	4291      	cmp	r1, r2
 8002e30:	f100 33ff 	add.w	r3, r0, #4294967295
 8002e34:	d100      	bne.n	8002e38 <memcpy+0xc>
 8002e36:	4770      	bx	lr
 8002e38:	b510      	push	{r4, lr}
 8002e3a:	f811 4b01 	ldrb.w	r4, [r1], #1
 8002e3e:	f803 4f01 	strb.w	r4, [r3, #1]!
 8002e42:	4291      	cmp	r1, r2
 8002e44:	d1f9      	bne.n	8002e3a <memcpy+0xe>
 8002e46:	bd10      	pop	{r4, pc}

08002e48 <memmove>:
 8002e48:	4288      	cmp	r0, r1
 8002e4a:	b510      	push	{r4, lr}
 8002e4c:	eb01 0402 	add.w	r4, r1, r2
 8002e50:	d902      	bls.n	8002e58 <memmove+0x10>
 8002e52:	4284      	cmp	r4, r0
 8002e54:	4623      	mov	r3, r4
 8002e56:	d807      	bhi.n	8002e68 <memmove+0x20>
 8002e58:	1e43      	subs	r3, r0, #1
 8002e5a:	42a1      	cmp	r1, r4
 8002e5c:	d008      	beq.n	8002e70 <memmove+0x28>
 8002e5e:	f811 2b01 	ldrb.w	r2, [r1], #1
 8002e62:	f803 2f01 	strb.w	r2, [r3, #1]!
 8002e66:	e7f8      	b.n	8002e5a <memmove+0x12>
 8002e68:	4402      	add	r2, r0
 8002e6a:	4601      	mov	r1, r0
 8002e6c:	428a      	cmp	r2, r1
 8002e6e:	d100      	bne.n	8002e72 <memmove+0x2a>
 8002e70:	bd10      	pop	{r4, pc}
 8002e72:	f813 4d01 	ldrb.w	r4, [r3, #-1]!
 8002e76:	f802 4d01 	strb.w	r4, [r2, #-1]!
 8002e7a:	e7f7      	b.n	8002e6c <memmove+0x24>

08002e7c <_free_r>:
 8002e7c:	b538      	push	{r3, r4, r5, lr}
 8002e7e:	4605      	mov	r5, r0
 8002e80:	2900      	cmp	r1, #0
 8002e82:	d041      	beq.n	8002f08 <_free_r+0x8c>
 8002e84:	f851 3c04 	ldr.w	r3, [r1, #-4]
 8002e88:	1f0c      	subs	r4, r1, #4
 8002e8a:	2b00      	cmp	r3, #0
 8002e8c:	bfb8      	it	lt
 8002e8e:	18e4      	addlt	r4, r4, r3
 8002e90:	f000 f912 	bl	80030b8 <__malloc_lock>
 8002e94:	4a1d      	ldr	r2, [pc, #116]	; (8002f0c <_free_r+0x90>)
 8002e96:	6813      	ldr	r3, [r2, #0]
 8002e98:	b933      	cbnz	r3, 8002ea8 <_free_r+0x2c>
 8002e9a:	6063      	str	r3, [r4, #4]
 8002e9c:	6014      	str	r4, [r2, #0]
 8002e9e:	4628      	mov	r0, r5
 8002ea0:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 8002ea4:	f000 b90e 	b.w	80030c4 <__malloc_unlock>
 8002ea8:	42a3      	cmp	r3, r4
 8002eaa:	d908      	bls.n	8002ebe <_free_r+0x42>
 8002eac:	6820      	ldr	r0, [r4, #0]
 8002eae:	1821      	adds	r1, r4, r0
 8002eb0:	428b      	cmp	r3, r1
 8002eb2:	bf01      	itttt	eq
 8002eb4:	6819      	ldreq	r1, [r3, #0]
 8002eb6:	685b      	ldreq	r3, [r3, #4]
 8002eb8:	1809      	addeq	r1, r1, r0
 8002eba:	6021      	streq	r1, [r4, #0]
 8002ebc:	e7ed      	b.n	8002e9a <_free_r+0x1e>
 8002ebe:	461a      	mov	r2, r3
 8002ec0:	685b      	ldr	r3, [r3, #4]
 8002ec2:	b10b      	cbz	r3, 8002ec8 <_free_r+0x4c>
 8002ec4:	42a3      	cmp	r3, r4
 8002ec6:	d9fa      	bls.n	8002ebe <_free_r+0x42>
 8002ec8:	6811      	ldr	r1, [r2, #0]
 8002eca:	1850      	adds	r0, r2, r1
 8002ecc:	42a0      	cmp	r0, r4
 8002ece:	d10b      	bne.n	8002ee8 <_free_r+0x6c>
 8002ed0:	6820      	ldr	r0, [r4, #0]
 8002ed2:	4401      	add	r1, r0
 8002ed4:	1850      	adds	r0, r2, r1
 8002ed6:	4283      	cmp	r3, r0
 8002ed8:	6011      	str	r1, [r2, #0]
 8002eda:	d1e0      	bne.n	8002e9e <_free_r+0x22>
 8002edc:	6818      	ldr	r0, [r3, #0]
 8002ede:	685b      	ldr	r3, [r3, #4]
 8002ee0:	6053      	str	r3, [r2, #4]
 8002ee2:	4401      	add	r1, r0
 8002ee4:	6011      	str	r1, [r2, #0]
 8002ee6:	e7da      	b.n	8002e9e <_free_r+0x22>
 8002ee8:	d902      	bls.n	8002ef0 <_free_r+0x74>
 8002eea:	230c      	movs	r3, #12
 8002eec:	602b      	str	r3, [r5, #0]
 8002eee:	e7d6      	b.n	8002e9e <_free_r+0x22>
 8002ef0:	6820      	ldr	r0, [r4, #0]
 8002ef2:	1821      	adds	r1, r4, r0
 8002ef4:	428b      	cmp	r3, r1
 8002ef6:	bf04      	itt	eq
 8002ef8:	6819      	ldreq	r1, [r3, #0]
 8002efa:	685b      	ldreq	r3, [r3, #4]
 8002efc:	6063      	str	r3, [r4, #4]
 8002efe:	bf04      	itt	eq
 8002f00:	1809      	addeq	r1, r1, r0
 8002f02:	6021      	streq	r1, [r4, #0]
 8002f04:	6054      	str	r4, [r2, #4]
 8002f06:	e7ca      	b.n	8002e9e <_free_r+0x22>
 8002f08:	bd38      	pop	{r3, r4, r5, pc}
 8002f0a:	bf00      	nop
 8002f0c:	20000d70 	.word	0x20000d70

08002f10 <sbrk_aligned>:
 8002f10:	b570      	push	{r4, r5, r6, lr}
 8002f12:	4e0e      	ldr	r6, [pc, #56]	; (8002f4c <sbrk_aligned+0x3c>)
 8002f14:	460c      	mov	r4, r1
 8002f16:	6831      	ldr	r1, [r6, #0]
 8002f18:	4605      	mov	r5, r0
 8002f1a:	b911      	cbnz	r1, 8002f22 <sbrk_aligned+0x12>
 8002f1c:	f000 f8bc 	bl	8003098 <_sbrk_r>
 8002f20:	6030      	str	r0, [r6, #0]
 8002f22:	4621      	mov	r1, r4
 8002f24:	4628      	mov	r0, r5
 8002f26:	f000 f8b7 	bl	8003098 <_sbrk_r>
 8002f2a:	1c43      	adds	r3, r0, #1
 8002f2c:	d00a      	beq.n	8002f44 <sbrk_aligned+0x34>
 8002f2e:	1cc4      	adds	r4, r0, #3
 8002f30:	f024 0403 	bic.w	r4, r4, #3
 8002f34:	42a0      	cmp	r0, r4
 8002f36:	d007      	beq.n	8002f48 <sbrk_aligned+0x38>
 8002f38:	1a21      	subs	r1, r4, r0
 8002f3a:	4628      	mov	r0, r5
 8002f3c:	f000 f8ac 	bl	8003098 <_sbrk_r>
 8002f40:	3001      	adds	r0, #1
 8002f42:	d101      	bne.n	8002f48 <sbrk_aligned+0x38>
 8002f44:	f04f 34ff 	mov.w	r4, #4294967295
 8002f48:	4620      	mov	r0, r4
 8002f4a:	bd70      	pop	{r4, r5, r6, pc}
 8002f4c:	20000d74 	.word	0x20000d74

08002f50 <_malloc_r>:
 8002f50:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8002f54:	1ccd      	adds	r5, r1, #3
 8002f56:	f025 0503 	bic.w	r5, r5, #3
 8002f5a:	3508      	adds	r5, #8
 8002f5c:	2d0c      	cmp	r5, #12
 8002f5e:	bf38      	it	cc
 8002f60:	250c      	movcc	r5, #12
 8002f62:	2d00      	cmp	r5, #0
 8002f64:	4607      	mov	r7, r0
 8002f66:	db01      	blt.n	8002f6c <_malloc_r+0x1c>
 8002f68:	42a9      	cmp	r1, r5
 8002f6a:	d905      	bls.n	8002f78 <_malloc_r+0x28>
 8002f6c:	230c      	movs	r3, #12
 8002f6e:	603b      	str	r3, [r7, #0]
 8002f70:	2600      	movs	r6, #0
 8002f72:	4630      	mov	r0, r6
 8002f74:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8002f78:	4e2e      	ldr	r6, [pc, #184]	; (8003034 <_malloc_r+0xe4>)
 8002f7a:	f000 f89d 	bl	80030b8 <__malloc_lock>
 8002f7e:	6833      	ldr	r3, [r6, #0]
 8002f80:	461c      	mov	r4, r3
 8002f82:	bb34      	cbnz	r4, 8002fd2 <_malloc_r+0x82>
 8002f84:	4629      	mov	r1, r5
 8002f86:	4638      	mov	r0, r7
 8002f88:	f7ff ffc2 	bl	8002f10 <sbrk_aligned>
 8002f8c:	1c43      	adds	r3, r0, #1
 8002f8e:	4604      	mov	r4, r0
 8002f90:	d14d      	bne.n	800302e <_malloc_r+0xde>
 8002f92:	6834      	ldr	r4, [r6, #0]
 8002f94:	4626      	mov	r6, r4
 8002f96:	2e00      	cmp	r6, #0
 8002f98:	d140      	bne.n	800301c <_malloc_r+0xcc>
 8002f9a:	6823      	ldr	r3, [r4, #0]
 8002f9c:	4631      	mov	r1, r6
 8002f9e:	4638      	mov	r0, r7
 8002fa0:	eb04 0803 	add.w	r8, r4, r3
 8002fa4:	f000 f878 	bl	8003098 <_sbrk_r>
 8002fa8:	4580      	cmp	r8, r0
 8002faa:	d13a      	bne.n	8003022 <_malloc_r+0xd2>
 8002fac:	6821      	ldr	r1, [r4, #0]
 8002fae:	3503      	adds	r5, #3
 8002fb0:	1a6d      	subs	r5, r5, r1
 8002fb2:	f025 0503 	bic.w	r5, r5, #3
 8002fb6:	3508      	adds	r5, #8
 8002fb8:	2d0c      	cmp	r5, #12
 8002fba:	bf38      	it	cc
 8002fbc:	250c      	movcc	r5, #12
 8002fbe:	4629      	mov	r1, r5
 8002fc0:	4638      	mov	r0, r7
 8002fc2:	f7ff ffa5 	bl	8002f10 <sbrk_aligned>
 8002fc6:	3001      	adds	r0, #1
 8002fc8:	d02b      	beq.n	8003022 <_malloc_r+0xd2>
 8002fca:	6823      	ldr	r3, [r4, #0]
 8002fcc:	442b      	add	r3, r5
 8002fce:	6023      	str	r3, [r4, #0]
 8002fd0:	e00e      	b.n	8002ff0 <_malloc_r+0xa0>
 8002fd2:	6822      	ldr	r2, [r4, #0]
 8002fd4:	1b52      	subs	r2, r2, r5
 8002fd6:	d41e      	bmi.n	8003016 <_malloc_r+0xc6>
 8002fd8:	2a0b      	cmp	r2, #11
 8002fda:	d916      	bls.n	800300a <_malloc_r+0xba>
 8002fdc:	1961      	adds	r1, r4, r5
 8002fde:	42a3      	cmp	r3, r4
 8002fe0:	6025      	str	r5, [r4, #0]
 8002fe2:	bf18      	it	ne
 8002fe4:	6059      	strne	r1, [r3, #4]
 8002fe6:	6863      	ldr	r3, [r4, #4]
 8002fe8:	bf08      	it	eq
 8002fea:	6031      	streq	r1, [r6, #0]
 8002fec:	5162      	str	r2, [r4, r5]
 8002fee:	604b      	str	r3, [r1, #4]
 8002ff0:	4638      	mov	r0, r7
 8002ff2:	f104 060b 	add.w	r6, r4, #11
 8002ff6:	f000 f865 	bl	80030c4 <__malloc_unlock>
 8002ffa:	f026 0607 	bic.w	r6, r6, #7
 8002ffe:	1d23      	adds	r3, r4, #4
 8003000:	1af2      	subs	r2, r6, r3
 8003002:	d0b6      	beq.n	8002f72 <_malloc_r+0x22>
 8003004:	1b9b      	subs	r3, r3, r6
 8003006:	50a3      	str	r3, [r4, r2]
 8003008:	e7b3      	b.n	8002f72 <_malloc_r+0x22>
 800300a:	6862      	ldr	r2, [r4, #4]
 800300c:	42a3      	cmp	r3, r4
 800300e:	bf0c      	ite	eq
 8003010:	6032      	streq	r2, [r6, #0]
 8003012:	605a      	strne	r2, [r3, #4]
 8003014:	e7ec      	b.n	8002ff0 <_malloc_r+0xa0>
 8003016:	4623      	mov	r3, r4
 8003018:	6864      	ldr	r4, [r4, #4]
 800301a:	e7b2      	b.n	8002f82 <_malloc_r+0x32>
 800301c:	4634      	mov	r4, r6
 800301e:	6876      	ldr	r6, [r6, #4]
 8003020:	e7b9      	b.n	8002f96 <_malloc_r+0x46>
 8003022:	230c      	movs	r3, #12
 8003024:	603b      	str	r3, [r7, #0]
 8003026:	4638      	mov	r0, r7
 8003028:	f000 f84c 	bl	80030c4 <__malloc_unlock>
 800302c:	e7a1      	b.n	8002f72 <_malloc_r+0x22>
 800302e:	6025      	str	r5, [r4, #0]
 8003030:	e7de      	b.n	8002ff0 <_malloc_r+0xa0>
 8003032:	bf00      	nop
 8003034:	20000d70 	.word	0x20000d70

08003038 <_realloc_r>:
 8003038:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800303c:	4680      	mov	r8, r0
 800303e:	4614      	mov	r4, r2
 8003040:	460e      	mov	r6, r1
 8003042:	b921      	cbnz	r1, 800304e <_realloc_r+0x16>
 8003044:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
 8003048:	4611      	mov	r1, r2
 800304a:	f7ff bf81 	b.w	8002f50 <_malloc_r>
 800304e:	b92a      	cbnz	r2, 800305c <_realloc_r+0x24>
 8003050:	f7ff ff14 	bl	8002e7c <_free_r>
 8003054:	4625      	mov	r5, r4
 8003056:	4628      	mov	r0, r5
 8003058:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800305c:	f000 f838 	bl	80030d0 <_malloc_usable_size_r>
 8003060:	4284      	cmp	r4, r0
 8003062:	4607      	mov	r7, r0
 8003064:	d802      	bhi.n	800306c <_realloc_r+0x34>
 8003066:	ebb4 0f50 	cmp.w	r4, r0, lsr #1
 800306a:	d812      	bhi.n	8003092 <_realloc_r+0x5a>
 800306c:	4621      	mov	r1, r4
 800306e:	4640      	mov	r0, r8
 8003070:	f7ff ff6e 	bl	8002f50 <_malloc_r>
 8003074:	4605      	mov	r5, r0
 8003076:	2800      	cmp	r0, #0
 8003078:	d0ed      	beq.n	8003056 <_realloc_r+0x1e>
 800307a:	42bc      	cmp	r4, r7
 800307c:	4622      	mov	r2, r4
 800307e:	4631      	mov	r1, r6
 8003080:	bf28      	it	cs
 8003082:	463a      	movcs	r2, r7
 8003084:	f7ff fed2 	bl	8002e2c <memcpy>
 8003088:	4631      	mov	r1, r6
 800308a:	4640      	mov	r0, r8
 800308c:	f7ff fef6 	bl	8002e7c <_free_r>
 8003090:	e7e1      	b.n	8003056 <_realloc_r+0x1e>
 8003092:	4635      	mov	r5, r6
 8003094:	e7df      	b.n	8003056 <_realloc_r+0x1e>
	...

08003098 <_sbrk_r>:
 8003098:	b538      	push	{r3, r4, r5, lr}
 800309a:	4d06      	ldr	r5, [pc, #24]	; (80030b4 <_sbrk_r+0x1c>)
 800309c:	2300      	movs	r3, #0
 800309e:	4604      	mov	r4, r0
 80030a0:	4608      	mov	r0, r1
 80030a2:	602b      	str	r3, [r5, #0]
 80030a4:	f000 f81e 	bl	80030e4 <_sbrk>
 80030a8:	1c43      	adds	r3, r0, #1
 80030aa:	d102      	bne.n	80030b2 <_sbrk_r+0x1a>
 80030ac:	682b      	ldr	r3, [r5, #0]
 80030ae:	b103      	cbz	r3, 80030b2 <_sbrk_r+0x1a>
 80030b0:	6023      	str	r3, [r4, #0]
 80030b2:	bd38      	pop	{r3, r4, r5, pc}
 80030b4:	20000d78 	.word	0x20000d78

080030b8 <__malloc_lock>:
 80030b8:	4801      	ldr	r0, [pc, #4]	; (80030c0 <__malloc_lock+0x8>)
 80030ba:	f000 b811 	b.w	80030e0 <__retarget_lock_acquire_recursive>
 80030be:	bf00      	nop
 80030c0:	20000d7c 	.word	0x20000d7c

080030c4 <__malloc_unlock>:
 80030c4:	4801      	ldr	r0, [pc, #4]	; (80030cc <__malloc_unlock+0x8>)
 80030c6:	f000 b80c 	b.w	80030e2 <__retarget_lock_release_recursive>
 80030ca:	bf00      	nop
 80030cc:	20000d7c 	.word	0x20000d7c

080030d0 <_malloc_usable_size_r>:
 80030d0:	f851 3c04 	ldr.w	r3, [r1, #-4]
 80030d4:	1f18      	subs	r0, r3, #4
 80030d6:	2b00      	cmp	r3, #0
 80030d8:	bfbc      	itt	lt
 80030da:	580b      	ldrlt	r3, [r1, r0]
 80030dc:	18c0      	addlt	r0, r0, r3
 80030de:	4770      	bx	lr

080030e0 <__retarget_lock_acquire_recursive>:
 80030e0:	4770      	bx	lr

080030e2 <__retarget_lock_release_recursive>:
 80030e2:	4770      	bx	lr

080030e4 <_sbrk>:
 80030e4:	4a04      	ldr	r2, [pc, #16]	; (80030f8 <_sbrk+0x14>)
 80030e6:	6811      	ldr	r1, [r2, #0]
 80030e8:	4603      	mov	r3, r0
 80030ea:	b909      	cbnz	r1, 80030f0 <_sbrk+0xc>
 80030ec:	4903      	ldr	r1, [pc, #12]	; (80030fc <_sbrk+0x18>)
 80030ee:	6011      	str	r1, [r2, #0]
 80030f0:	6810      	ldr	r0, [r2, #0]
 80030f2:	4403      	add	r3, r0
 80030f4:	6013      	str	r3, [r2, #0]
 80030f6:	4770      	bx	lr
 80030f8:	20000d80 	.word	0x20000d80
 80030fc:	20000d88 	.word	0x20000d88

08003100 <_init>:
 8003100:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8003102:	bf00      	nop
 8003104:	bcf8      	pop	{r3, r4, r5, r6, r7}
 8003106:	bc08      	pop	{r3}
 8003108:	469e      	mov	lr, r3
 800310a:	4770      	bx	lr

0800310c <_fini>:
 800310c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800310e:	bf00      	nop
 8003110:	bcf8      	pop	{r3, r4, r5, r6, r7}
 8003112:	bc08      	pop	{r3}
 8003114:	469e      	mov	lr, r3
 8003116:	4770      	bx	lr
